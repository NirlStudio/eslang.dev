{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./es.js","webpack:///./es/compiler.js","webpack:///./es/generic/array.js","webpack:///./es/generic/bool.js","webpack:///./es/generic/class.js","webpack:///./es/generic/date.js","webpack:///./es/generic/encoding.js","webpack:///./es/generic/function.js","webpack:///./es/generic/genesis.js","webpack:///./es/generic/global.js","webpack:///./es/generic/iterator.js","webpack:///./es/generic/lambda.js","webpack:///./es/generic/null.js","webpack:///./es/generic/number.js","webpack:///./es/generic/object.js","webpack:///./es/generic/operator.js","webpack:///./es/generic/promise.js","webpack:///./es/generic/range.js","webpack:///./es/generic/string.js","webpack:///./es/generic/symbol.js","webpack:///./es/generic/tuple.js","webpack:///./es/generic/type.js","webpack:///./es/generic/void.js","webpack:///./es/lib/emitter.js","webpack:///./es/lib/espress.js","webpack:///./es/lib/format.js","webpack:///./es/lib/json.js","webpack:///./es/lib/math.js","webpack:///./es/lib/stdout.js","webpack:///./es/lib/timer.js","webpack:///./es/lib/uri.js","webpack:///./es/operators/arithmetic.js","webpack:///./es/operators/assignment.js","webpack:///./es/operators/bitwise.js","webpack:///./es/operators/control.js","webpack:///./es/operators/fetch.js","webpack:///./es/operators/function.js","webpack:///./es/operators/general.js","webpack:///./es/operators/import.js","webpack:///./es/operators/literal.js","webpack:///./es/operators/load.js","webpack:///./es/operators/logical.js","webpack:///./es/operators/operator.js","webpack:///./es/operators/pattern.js","webpack:///./es/operators/quote.js","webpack:///./es/runtime/env.js","webpack:///./es/runtime/eval.js","webpack:///./es/runtime/evaluate.js","webpack:///./es/runtime/execute.js","webpack:///./es/runtime/function.js","webpack:///./es/runtime/interpreter.js","webpack:///./es/runtime/operator.js","webpack:///./es/runtime/run.js","webpack:///./es/runtime/signal-of.js","webpack:///./es/runtime/signal.js","webpack:///./es/runtime/space.js","webpack:///./es/start.js","webpack:///./es/tokenizer.js","webpack:///./lib/loader-cache.js","webpack:///./lib/loader-http.js","webpack:///./lib/loader.js","webpack:///./lib/polyfill.js","webpack:///./lib/shell.js","webpack:///./lib/stdout.js","webpack:///./modules/index.js","webpack:///./modules/io.js","webpack:///./modules/restful.js","webpack:///./modules/shell.js","webpack:///./modules/symbols.js","webpack:///./modules/window.js","webpack:///./node_modules/axios/index.js","webpack:///./node_modules/axios/lib/adapters/xhr.js","webpack:///./node_modules/axios/lib/axios.js","webpack:///./node_modules/axios/lib/cancel/Cancel.js","webpack:///./node_modules/axios/lib/cancel/CancelToken.js","webpack:///./node_modules/axios/lib/cancel/isCancel.js","webpack:///./node_modules/axios/lib/core/Axios.js","webpack:///./node_modules/axios/lib/core/InterceptorManager.js","webpack:///./node_modules/axios/lib/core/createError.js","webpack:///./node_modules/axios/lib/core/dispatchRequest.js","webpack:///./node_modules/axios/lib/core/enhanceError.js","webpack:///./node_modules/axios/lib/core/mergeConfig.js","webpack:///./node_modules/axios/lib/core/settle.js","webpack:///./node_modules/axios/lib/core/transformData.js","webpack:///./node_modules/axios/lib/defaults.js","webpack:///./node_modules/axios/lib/helpers/bind.js","webpack:///./node_modules/axios/lib/helpers/buildURL.js","webpack:///./node_modules/axios/lib/helpers/combineURLs.js","webpack:///./node_modules/axios/lib/helpers/cookies.js","webpack:///./node_modules/axios/lib/helpers/isAbsoluteURL.js","webpack:///./node_modules/axios/lib/helpers/isURLSameOrigin.js","webpack:///./node_modules/axios/lib/helpers/normalizeHeaderName.js","webpack:///./node_modules/axios/lib/helpers/parseHeaders.js","webpack:///./node_modules/axios/lib/helpers/spread.js","webpack:///./node_modules/axios/lib/utils.js","webpack:///./node_modules/axios/node_modules/is-buffer/index.js","webpack:///./node_modules/process/browser.js","webpack:///(webpack)/buildin/global.js","webpack:///./test/test.js","webpack:///./web/index.js","webpack:///./web/lib/console.js","webpack:///./web/lib/io.js","webpack:///./web/lib/process.js","webpack:///./web/lib/shell.js","webpack:///./web/lib/stdin.js","webpack:///./web/lib/stdout.js","webpack:///./web/lib/term.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA,iDAAY;;AAEZ,mBAAO,CAAC,yCAAgB;;AAExB;AACA;AACA,cAAc,mBAAO,CAAC,iCAAY;AAClC;AACA;AACA,kBAAkB,mBAAO,CAAC,qCAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnBY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wDAAwD;AACxD;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;AACtC;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;ACxWY;;AAEZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB,6BAA6B;AAC7B,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA,KAAK;AACL,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mCAAmC,QAAQ;AAC3C,uBAAuB,UAAU;AACjC;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA,4BAA4B;AAC5B;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA,uBAAuB;AACvB;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,OAAO;AACP,KAAK;AACL;AACA,0BAA0B;AAC1B;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK,OAAO;AACZ,wCAAwC,iBAAiB;AACzD;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK,OAAO;AACZ,qCAAqC,iBAAiB;AACtD;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,gBAAgB;AAChB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACv0BY;;AAEZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC1CY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,eAAe;AACf;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK,OAAO;AACZ;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACtZA,+CAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;ACrOY;;AAEZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5MY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;;;;;;;;;;;;ACzCY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;;;;;;;;;;;;AC1RY;;AAEZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;;AAEnC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;;;;;;;;;;;;;AC5DY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;ACzZY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACjDY;;AAEZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;AC9EY;;AAEZ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC3YY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,mBAAmB;AACnB;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,KAAK;AACL;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;ACjUY;;AAEZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;;;;;;;;;;;;ACjBA,+CAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;AChVY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AClIY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC3QY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACxJY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,UAAU,iBAAiB;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACpTY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;AC1IY;;AAEZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C,SAAS;;AAEnD;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+CAA+C,cAAc;AAC7D;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;ACjdY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;;ACrIY;;AAEZ;AACA;AACA;AACA,0CAA0C,WAAW;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,kBAAkB;AAClB;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;ACzHY;;AAEZ;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,uBAAuB;AACvB;AACA,2BAA2B;AAC3B,sBAAsB,GAAG,KAAK;AAC9B;AACA,8BAA8B;AAC9B;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,kBAAkB;AAClB,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,0BAA0B;AAC1B,eAAe;AACf,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,eAAe;AACf,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,WAAW;AACX,sBAAsB;AACtB,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrOY;;AAEZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;;AC9BY;;AAEZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;AClGY;;AAEZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK,qBAAqB;AAC1B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvIY;;AAEZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;;ACnIY;;AAEZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;;AC9CY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;AC1LY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA,OAAO,6BAA6B;AACpC,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,OAAO;AACd,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpHY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;AC1IY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uFAAuF;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS,OAAO;AAChB;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3NY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;AChFY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzEY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;AC5GY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;AC5PY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;ACzGY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;ACxGY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,kBAAkB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,kBAAkB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,kBAAkB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;AChKY;;AAEZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;ACZY;;AAEZ;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;ACdY;;AAEZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;AC7BY;;AAEZ,kBAAkB,mBAAO,CAAC,0CAAoB;;AAE9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnCY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK,iBAAiB;AACtB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;AC1CY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,uBAAuB;AACvB;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,sCAAsC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,yCAAyC;AAChD;AACA,OAAO,OAAO;AACd;AACA;AACA,KAAK,sCAAsC;AAC3C;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;AAC7B;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,UAAU,iBAAiB;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnIY;;AAEZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC;AACzC,+BAA+B;AAC/B;AACA,OAAO;AACP,KAAK,OAAO;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;AC5CY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,SAAS;AACT;AACA,uCAAuC;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,SAAS;AACT;AACA,uCAAuC;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA6C,WAAW;AACxD;AACA,KAAK;AACL;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,mCAAmC;AACnC,sCAAsC;AACtC,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtTY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;AC3DY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtFY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;ACtDY;;AAEZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxBY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACTY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;;;;;;;;;;;;ACpQY;;AAEZ;AACA,EAAE,mBAAO,CAAC,4CAAgB;AAC1B,EAAE,mBAAO,CAAC,oDAAoB;;AAE9B,EAAE,mBAAO,CAAC,4CAAgB;AAC1B,EAAE,mBAAO,CAAC,4CAAgB;;AAE1B,EAAE,mBAAO,CAAC,4CAAgB;AAC1B,EAAE,mBAAO,CAAC,gDAAkB;AAC5B,EAAE,mBAAO,CAAC,gDAAkB;AAC5B,EAAE,mBAAO,CAAC,4CAAgB;AAC1B,EAAE,mBAAO,CAAC,8CAAiB;;AAE3B,EAAE,mBAAO,CAAC,gDAAkB;AAC5B,EAAE,mBAAO,CAAC,8CAAiB;;AAE3B,EAAE,mBAAO,CAAC,oDAAoB;AAC9B,EAAE,mBAAO,CAAC,gDAAkB;AAC5B,EAAE,mBAAO,CAAC,oDAAoB;;AAE9B,EAAE,mBAAO,CAAC,oDAAoB;AAC9B,EAAE,mBAAO,CAAC,kDAAmB;;AAE7B,EAAE,mBAAO,CAAC,8CAAiB;AAC3B,EAAE,mBAAO,CAAC,gDAAkB;AAC5B,EAAE,mBAAO,CAAC,8CAAiB;;AAE3B,EAAE,mBAAO,CAAC,gDAAkB;AAC5B;;AAEA;AACA,EAAE,mBAAO,CAAC,wCAAc;AACxB,EAAE,mBAAO,CAAC,wCAAc;AACxB,EAAE,mBAAO,CAAC,oCAAY;AACtB,EAAE,mBAAO,CAAC,kCAAW;AACrB,EAAE,mBAAO,CAAC,oCAAY;AACtB,EAAE,mBAAO,CAAC,0CAAe;AACzB,EAAE,mBAAO,CAAC,sCAAa;AACvB,EAAE,mBAAO,CAAC,0CAAe;AACzB;;AAEA;AACA,EAAE,mBAAO,CAAC,0CAAe;AACzB,EAAE,mBAAO,CAAC,gDAAkB;AAC5B,EAAE,mBAAO,CAAC,8CAAiB;AAC3B,EAAE,mBAAO,CAAC,oDAAoB;AAC9B,EAAE,mBAAO,CAAC,sDAAqB;AAC/B,EAAE,mBAAO,CAAC,oDAAoB;AAC9B,EAAE,mBAAO,CAAC,oDAAoB;;AAE9B,EAAE,mBAAO,CAAC,kDAAmB;AAC7B,EAAE,mBAAO,CAAC,4CAAgB;;AAE1B,EAAE,mBAAO,CAAC,0CAAe;AACzB,EAAE,mBAAO,CAAC,0DAAuB;AACjC;;AAEA;AACA,EAAE,mBAAO,CAAC,sDAAqB;AAC/B,EAAE,mBAAO,CAAC,kDAAmB;;AAE7B,EAAE,mBAAO,CAAC,4DAAwB;AAClC,EAAE,mBAAO,CAAC,sDAAqB;;AAE/B,EAAE,mBAAO,CAAC,sDAAqB;AAC/B,EAAE,mBAAO,CAAC,sDAAqB;AAC/B,EAAE,mBAAO,CAAC,sDAAqB;AAC/B,EAAE,mBAAO,CAAC,4DAAwB;;AAElC,EAAE,mBAAO,CAAC,sDAAqB;AAC/B,EAAE,mBAAO,CAAC,wDAAsB;AAChC,EAAE,mBAAO,CAAC,wDAAsB;;AAEhC,EAAE,mBAAO,CAAC,oDAAoB;AAC9B,EAAE,mBAAO,CAAC,gDAAkB;AAC5B,EAAE,mBAAO,CAAC,kDAAmB;AAC7B;;AAEA;AACA;AACA,cAAc,mBAAO,CAAC,kDAAmB;;AAEzC;AACA;;AAEA;AACA;;AAEA;AACA,EAAE,mBAAO,CAAC,sCAAa;AACvB,EAAE,mBAAO,CAAC,oCAAY;;AAEtB;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACrGY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB,yBAAyB;AACzB;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,sCAAsC;AACtC,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0DAA0D;AAC1D;AACA,OAAO,2CAA2C;AAClD;AACA;AACA,OAAO,wCAAwC;AAC/C;AACA,OAAO,OAAO;AACd;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;ACxSY;;AAEZ;AACA;;AAEA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAO,CAAC,2IAAmB;AAClD;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjKY;;AAEZ,YAAY,mBAAO,CAAC,4CAAO;AAC3B,YAAY,mBAAO,CAAC,6CAAgB;;AAEpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;ACzIY;;AAEZ,iBAAiB,mBAAO,CAAC,2CAAe;;AAExC;AACA,mBAAmB,mBAAO,CAAC,qIAAa;AACxC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AClCA,8CAAY;;AAEZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB;AACA;AACA;;;;;;;;;;;;;;AC3NY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA,qCAAqC;AACrC;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;ACtHA,+CAAY;;AAEZ;AACA;AACA,WAAW,mBAAO,CAAC,qIAAa;AAChC;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClIY;;AAEZ;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,6BAAM;AAC7B;AACA,eAAe,mBAAO,CAAC,uCAAW;AAClC;AACA,eAAe,mBAAO,CAAC,mCAAS;AAChC;AACA,eAAe,mBAAO,CAAC,uCAAW;AAClC;AACA,eAAe,mBAAO,CAAC,qCAAU;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC/EY;;AAEZ;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNY;;AAEZ,YAAY,mBAAO,CAAC,4CAAO;;AAE3B;AACA;AACA;;AAEA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;;AAEA;AACA;;;;;;;;;;;;;AChCY;;AAEZ;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA,8CAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG,OAAO;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5BY;;AAEZ;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;ACTA,iBAAiB,mBAAO,CAAC,sDAAa,E;;;;;;;;;;;;ACAzB;;AAEb,YAAY,mBAAO,CAAC,qDAAY;AAChC,aAAa,mBAAO,CAAC,iEAAkB;AACvC,eAAe,mBAAO,CAAC,2EAAuB;AAC9C,mBAAmB,mBAAO,CAAC,mFAA2B;AACtD,sBAAsB,mBAAO,CAAC,yFAA8B;AAC5D,kBAAkB,mBAAO,CAAC,yEAAqB;;AAE/C;AACA;AACA;AACA;;AAEA;AACA,4CAA4C;AAC5C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,mBAAO,CAAC,yEAAsB;;AAElD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;AC7Ka;;AAEb,YAAY,mBAAO,CAAC,kDAAS;AAC7B,WAAW,mBAAO,CAAC,gEAAgB;AACnC,YAAY,mBAAO,CAAC,4DAAc;AAClC,kBAAkB,mBAAO,CAAC,wEAAoB;AAC9C,eAAe,mBAAO,CAAC,wDAAY;;AAEnC;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,mBAAO,CAAC,kEAAiB;AACxC,oBAAoB,mBAAO,CAAC,4EAAsB;AAClD,iBAAiB,mBAAO,CAAC,sEAAmB;;AAE5C;AACA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,oEAAkB;;AAEzC;;AAEA;AACA;;;;;;;;;;;;;ACpDa;;AAEb;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;AClBa;;AAEb,aAAa,mBAAO,CAAC,2DAAU;;AAE/B;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACxDa;;AAEb;AACA;AACA;;;;;;;;;;;;;ACJa;;AAEb,YAAY,mBAAO,CAAC,qDAAY;AAChC,eAAe,mBAAO,CAAC,yEAAqB;AAC5C,yBAAyB,mBAAO,CAAC,iFAAsB;AACvD,sBAAsB,mBAAO,CAAC,2EAAmB;AACjD,kBAAkB,mBAAO,CAAC,mEAAe;;AAEzC;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED;;;;;;;;;;;;;ACrFa;;AAEb,YAAY,mBAAO,CAAC,qDAAY;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;;ACnDa;;AAEb,mBAAmB,mBAAO,CAAC,qEAAgB;;AAE3C;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjBa;;AAEb,YAAY,mBAAO,CAAC,qDAAY;AAChC,oBAAoB,mBAAO,CAAC,uEAAiB;AAC7C,eAAe,mBAAO,CAAC,uEAAoB;AAC3C,eAAe,mBAAO,CAAC,yDAAa;AACpC,oBAAoB,mBAAO,CAAC,qFAA4B;AACxD,kBAAkB,mBAAO,CAAC,iFAA0B;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B,uCAAuC;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;;;;;;;;;;;;ACrFa;;AAEb;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzCa;;AAEb,YAAY,mBAAO,CAAC,mDAAU;;AAE9B;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;;AClDa;;AAEb,kBAAkB,mBAAO,CAAC,mEAAe;;AAEzC;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxBa;;AAEb,YAAY,mBAAO,CAAC,qDAAY;;AAEhC;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,MAAM;AACjB,WAAW,eAAe;AAC1B,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;;ACnBA,+CAAa;;AAEb,YAAY,mBAAO,CAAC,kDAAS;AAC7B,0BAA0B,mBAAO,CAAC,8FAA+B;;AAEjE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,mBAAO,CAAC,iEAAiB;AACvC,GAAG;AACH;AACA,cAAc,mBAAO,CAAC,gEAAgB;AACtC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,OAAO,YAAY;AACnB;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;;;ACjGa;;AAEb;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVa;;AAEb,YAAY,mBAAO,CAAC,qDAAY;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACtEa;;AAEb;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACba;;AAEb,YAAY,mBAAO,CAAC,qDAAY;;AAEhC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C;AAC1C,SAAS;;AAET;AACA,4DAA4D,wBAAwB;AACpF;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,kCAAkC;AAClC,+BAA+B,aAAa,EAAE;AAC9C;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;ACpDa;;AAEb;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACba;;AAEb,YAAY,mBAAO,CAAC,qDAAY;;AAEhC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;ACnEa;;AAEb,YAAY,mBAAO,CAAC,mDAAU;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;ACXa;;AAEb,YAAY,mBAAO,CAAC,qDAAY;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,eAAe;;AAEhC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;;ACpDa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1Ba;;AAEb,WAAW,mBAAO,CAAC,gEAAgB;AACnC,eAAe,mBAAO,CAAC,uEAAW;;AAElC;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS,GAAG,SAAS;AAC5C,2BAA2B;AAC3B;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,gCAAgC;AAChC,KAAK;AACL;AACA;AACA;;AAEA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7UA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACVA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;;;;;;ACvLtC;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;;;;;;;;;;;;;ACnBA,8CAAY;;AAEZ;AACA,mBAAO,CAAC,gDAAoB;;AAE5B;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,mBAAO,CAAC,0CAAiB;AAC5C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qDAAqD;;AAErD;AACA;;AAEA;AACA;;AAEA;AACA,uCAAuC;;AAEvC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uDAAuD;;AAEvD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzeY;;AAEZ,eAAe,mBAAO,CAAC,sBAAO;AAC9B,qBAAqB,mBAAO,CAAC,iCAAU;AACvC,kBAAkB,mBAAO,CAAC,2CAAe;AACzC,oBAAoB,mBAAO,CAAC,uCAAa;AACzC,qBAAqB,mBAAO,CAAC,yCAAc;AAC3C,oBAAoB,mBAAO,CAAC,sCAAe;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB;AACrD,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,mBAAO,CAAC,oCAAc;AACxC,QAAQ,mBAAO,CAAC,2CAAe;AAC/B;AACA;AACA,uCAAuC,mBAAO,CAAC,oCAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrGY;;AAEZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpEY;;AAEZ;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7EY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;;;;;;;;;;;;AChEY;;AAEZ,YAAY,mBAAO,CAAC,gCAAU;AAC9B,WAAW,mBAAO,CAAC,iCAAQ;;AAE3B;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;;;;;;;;;;;;ACjBY;;AAEZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3BY;;AAEZ,aAAa,mBAAO,CAAC,yCAAkB;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5BY;;AAEZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,WAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"eslang.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./web/lib/shell.js\");\n","'use strict'\n\nrequire('./lib/polyfill')\n\nmodule.exports = function espresso (stdout, loader) {\n  // create the void.\n  var start = require('./es/start')\n  var $void = start(stdout)\n  // mount native module loader\n  $void.require = require('./modules')($void)\n  // create the source loader\n  $void.loader = loader($void)\n  // set the location of the runtime\n  $void.runtime('home',\n    typeof window === 'undefined' ? __dirname\n      : window.ES_HOME || (window.location.origin + '/es')\n  )\n  // now we got a complete runtime.\n  return $void\n}\n","'use strict'\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var Tuple$ = $void.Tuple\n  var warn = $void.$warn\n  var $export = $void.export\n  var tokenizer = $.tokenizer\n  var isApplicable = $void.isApplicable\n  var formatPattern = $void.formatPattern\n  var sharedSymbolOf = $void.sharedSymbolOf\n\n  var symbolPairing = $.symbol.pairing\n  var symbolSubject = $.symbol.subject\n  var symbolString = sharedSymbolOf('string')\n  var symbolFormat = sharedSymbolOf('format')\n  var symbolToString = sharedSymbolOf('to-string')\n\n  var makeSourceUri = function (uri, version) {\n    return !uri || typeof uri !== 'string' ? ''\n      : !version || typeof version !== 'string' ? uri\n        : uri + '@' + version\n  }\n\n  var compiler = $export($, 'compiler', function (evaluate, srcUri) {\n    if (!isApplicable(evaluate)) {\n      return $.compile\n    }\n\n    var srcText = ''\n    if (!srcUri || typeof srcUri !== 'string') {\n      srcUri = ''\n    }\n\n    var stack, sourceStack, waiter, lastToken, openingLine, openingOffset\n    resetContext()\n\n    function resetContext () {\n      stack = [[]]\n      sourceStack = [[[[0, 0, 0]]]]\n      waiter = null\n      lastToken = ['space', '', [0, 0, 0]]\n      openingLine = -1\n      openingOffset = 0\n    }\n\n    var tokenizing = tokenizer(compileToken, srcUri)\n    return function compiling (text) {\n      srcText = text && typeof text === 'string' ? text : ''\n      if (tokenizing(text)) {\n        return stack.length\n      }\n      // reset compiling context.\n      waiter && waiter()\n      if (stack.length > 1) {\n        warn('compiler', 'open statements are not properly closed.',\n          [lastToken, srcUri || srcText])\n        endAll(null, lastToken[2])\n      }\n      tryToRaise()\n      resetContext()\n      return 0\n    }\n\n    function compileToken (type, value, source) {\n      var endingLine = source[source.length - 2]\n      if (endingLine !== openingLine) {\n        openingLine = endingLine\n        openingOffset = stack[stack.length - 1].length\n      }\n      if (!waiter || !waiter(type, value, source)) {\n        parseToken(type, value, source)\n      }\n      lastToken = [type, value, source]\n    }\n\n    function parseToken (type, value, source) {\n      switch (type) {\n        case 'value':\n          pushValue(value, source)\n          break\n        case 'symbol':\n          pushSymbol(value, source)\n          break\n        case 'punctuation':\n          pushPunctuation(value, source)\n          break\n        case 'format':\n          pushFormat(value, source)\n          break\n        case 'space':\n          if (value === '\\n') {\n            tryToRaise()\n          }\n          break\n        case 'comment':\n          // comment document should be put in specs.\n          break\n        default:\n          // do nothing for a free space.\n          break\n      }\n    }\n\n    function tryToRaise () {\n      while (stack[0].length > 0) {\n        evaluate([stack[0].shift(), sourceStack[0].splice(0, 1)])\n      }\n    }\n\n    function pushValue (value, source) {\n      stack[stack.length - 1].push(value)\n      sourceStack[sourceStack.length - 1].push(source)\n    }\n\n    function pushSymbol (value, source) {\n      switch (value.key) {\n        case ',':\n          // a free comma functions only as a stronger visual indicator like\n          // a whitespace, so it will be just skipped in building AST.\n          if (lastToken[0] === 'symbol' && lastToken[1].key === ',') {\n            pushValue(null, source)\n          }\n          break\n        case ';':\n          endLine(value, source)\n          if (!crossingLines()) {\n            closeLine(value, source)\n          }\n          break\n        default:\n          pushValue(value, source)\n      }\n    }\n\n    function pushPunctuation (value, source) {\n      switch (value) {\n        case '(': // begin a new clause\n          stack.push([])\n          sourceStack.push([[source]])\n          break\n        case ')':\n          // wait for next token to decide\n          waiter = endingWaiter\n          break\n        default: // just skip unknown punctuation as some placeholders.\n          break\n      }\n    }\n\n    function pushFormat (pattern, source) {\n      var args = formatPattern(pattern)\n      if (!(args.length > 1)) {\n        if (pattern.indexOf('\"') < 0) {\n          warn('compiler', 'unnecessary format string.',\n            pattern, ['format', pattern, source, srcUri || srcText])\n        }\n        return pushValue(args[0], source)\n      }\n\n      var beginning = source.slice(0, 3).concat(source.slice(1, 2))\n      var ending = source.slice(0, 1).concat(source.slice(-2))\n      stack.push([symbolString, symbolFormat])\n      sourceStack.push([[beginning], beginning, beginning])\n\n      pushValue(args[0], source)\n      for (var i = 1; i < args.length; i++) {\n        var code = $.compile(args[i])\n        pushValue(code.$.length > 0 ? code.$[0] : null, ending)\n      }\n      endTopWith(ending)\n    }\n\n    function endingWaiter (type, value, source) {\n      waiter = null // wait only once.\n      if (type !== 'symbol') {\n        endClause()\n        return false // stop waiting\n      }\n      switch (value.key) {\n        case '.':\n          if (stack.length > 1) {\n            endMatched(value, source)\n          } else {\n            warn('compiler', 'extra enclosing \").\" is found and ignored.',\n              [lastToken, ['symbol', value, source], srcUri || srcText])\n          }\n          return true\n        default:\n          endClause()\n          return false\n      }\n    }\n\n    function endTopWith (source) {\n      // create a tuple for the top clause, and\n      var statement = stack.pop()\n      // append ending token(s)' source info.\n      var sourceMap = sourceStack.pop()\n      sourceMap[0].push(source || lastToken[2])\n      while (statement.length > 2 &&\n        tryToFoldStatement(statement, sourceMap)\n      );\n      // push it to the end of container clause.\n      sourceMap[0].unshift(srcUri || srcText)\n      stack[stack.length - 1].push(new Tuple$(statement, false, sourceMap))\n      // since the source has been saved into the tuple, only keeps its overall range.\n      sourceStack[sourceStack.length - 1].push(sourceMap[0].slice(1))\n    }\n\n    function tryToFoldStatement (statement, sourceMap) { // sweeter time.\n      var max = statement.length - 1\n      for (var i = 1; i < max; i++) {\n        if (statement[i] === symbolPairing && statement[i + 1] === symbolPairing) {\n          statement.splice(i, 2)\n          sourceMap.splice(i + 1, 2)\n          foldStatement(statement, sourceMap, i)\n          return true\n        }\n      }\n      return false\n    }\n\n    function foldStatement (statement, sourceMap, length) {\n      // (x :: y) => ($(x) y)\n      var expr = statement.splice(0, length)\n      // re-arrange source map\n      var exprSrcMap = sourceMap.splice(1, length + 1)\n      var beginning = exprSrcMap[0].slice(0, 3)\n      var ending = exprSrcMap[exprSrcMap.length - 1]\n      exprSrcMap.unshift(beginning.concat(ending.slice(-2)))\n\n      // (x ::) => ($(x) to-string)\n      if (statement.length < 1) {\n        statement.push(symbolToString)\n        sourceMap.push(ending.slice(0, 1).concat(ending.slice(-2)))\n      }\n\n      exprSrcMap[0].unshift(srcUri || srcText)\n      statement.unshift(symbolSubject, new Tuple$(expr, false, exprSrcMap))\n      sourceMap.splice(1, 0,\n        beginning.concat(beginning.slice(1)), exprSrcMap[0].slice(1)\n      )\n    }\n\n    function endClause () {\n      if (stack.length < 2) {\n        warn('compiler', 'extra enclosing parentheses is found and ignored.',\n          [lastToken, srcUri || srcText])\n        return // allow & ignore extra enclosing parentheses\n      }\n      endTopWith()\n    }\n\n    function endMatched (value, source) {\n      if (stack.length < 2) {\n        warn('compiler', 'extra \"),\" is found and ignored.',\n          [lastToken, ['symbol', value, source], srcUri || srcText])\n        return // allow & ignore extra enclosing parentheses\n      }\n      lastToken[2][0] >= 0 // the indent value of ')'\n        ? endIndent(value, source) : endLine(value, source)\n    }\n\n    function endLine (value, source) { // sugar time\n      var depth = stack.length - 1\n      while (depth > 0) {\n        var startSource = sourceStack[depth][0][0] // start source.\n        if (startSource[1] < source[1]) { // comparing line numbers.\n          break\n        }\n        endTopWith(source)\n        depth = stack.length - 1\n      }\n    }\n\n    function crossingLines () {\n      var depth = sourceStack.length - 1\n      var srcOffset = openingOffset + 1\n      var topSource = sourceStack[depth]\n      return topSource.length > srcOffset &&\n        openingLine > topSource[srcOffset][1]\n    }\n\n    function closeLine (value, source) { // sweeter time.\n      var depth = stack.length - 1\n      stack.push(stack[depth].splice(openingOffset))\n      var src = sourceStack[depth].splice(openingOffset + 1)\n      src.length > 0 ? src.unshift(src[0]) : src.push(source)\n      sourceStack.push(src)\n      endTopWith(source)\n      openingOffset = stack[depth].length\n    }\n\n    function endIndent (value, source) { // sugar time\n      var endingIndent = lastToken[2][0]\n      var depth = stack.length - 1\n      while (depth > 0) {\n        var indent = sourceStack[depth][0][0][0]\n        // try to looking for and stop with the first matched indent.\n        if (indent >= 0 && indent <= endingIndent) {\n          if (indent === endingIndent) {\n            endTopWith(source)\n          }\n          break\n        }\n        endTopWith(source)\n        depth = stack.length - 1\n      }\n    }\n\n    function endAll (value, source) { // sugar time\n      while (stack.length > 1) {\n        endTopWith(source)\n      }\n    }\n  })\n\n  // a simple memory cache\n  var cache = {\n    code: Object.create(null),\n    versions: Object.create(null),\n\n    get: function (uri, version) {\n      return !uri || typeof uri !== 'string' ? null\n        : !version || typeof version !== 'string' ? this.code[uri]\n          : this.versions[uri] === version ? this.code[uri] : null\n    },\n    set: function (code, uri, version) {\n      if (uri && typeof uri === 'string') {\n        this.code[uri] = code\n        if (version && typeof version === 'string') {\n          this.versions[uri] = version\n        }\n      }\n      return code\n    }\n  }\n\n  // a helper function to compile a piece of source code.\n  $export($, 'compile', function (text, uri, version) {\n    var code = cache.get(uri, version)\n    if (code) {\n      return code\n    }\n\n    var srcUri = makeSourceUri(uri || text, version)\n    var list = []\n    var src = [[[srcUri, 0, 0, 0]]]\n    var compiling = compiler(function collector (expr) {\n      list.push(expr[0])\n      src.push(expr[1])\n    }, srcUri)\n    if (compiling(text) > 1) {\n      compiling('\\n') // end any pending waiter.\n    }\n    compiling() // notify the end of stream.\n    code = new Tuple$(list, true, src)\n    return cache.set(code, uri, version)\n  })\n}\n","'use strict'\n\nfunction offsetOf (length, index) {\n  index >>= 0\n  return index >= 0 ? index : index + length\n}\n\nfunction beginOf (length, from) {\n  from = offsetOf(length, from)\n  return from < 0 ? 0 : from\n}\n\nfunction endOf (length, to) {\n  return typeof to === 'undefined' ? length : beginOf(length, to)\n}\n\nfunction isSimple (arr) {\n  return arr.length <= 16 || !arr.isSparse\n}\n\nfunction checkSpacing (s, i, last) {\n  switch (i - last) {\n    case 1: return\n    case 2: s.push('*'); return\n    case 3: s.push('*', '*'); return\n    case 4: s.push('*', '*', '*'); return\n    default: s.push('...')\n  }\n}\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var Type = $.array\n  var $Symbol = $.symbol\n  var Tuple$ = $void.Tuple\n  var Symbol$ = $void.Symbol\n  var link = $void.link\n  var thisCall = $void.thisCall\n  var iterateOf = $void.iterateOf\n  var boolValueOf = $void.boolValueOf\n  var isApplicable = $void.isApplicable\n  var protoValueOf = $void.protoValueOf\n  var EncodingContext$ = $void.EncodingContext\n  var defineProperty = $void.defineProperty\n\n  // create an empty array.\n  link(Type, 'empty', function () {\n    return []\n  }, true)\n\n  // create an array of the arguments\n  link(Type, 'of', function (x, y, z) {\n    switch (arguments.length) {\n      case 0: return []\n      case 1: return [x]\n      case 2: return [x, y]\n      case 3: return [x, y, z]\n      default: return Array.prototype.slice.call(arguments)\n    }\n  }, true)\n\n  // create an array with items from iterable arguments, or the argument itself\n  // if its value is not iterable.\n  var ShortArray = 16\n  var arrayFrom = link(Type, 'from', function () {\n    var list = []\n    var isSparse\n    for (var i = 0; i < arguments.length; i++) {\n      var source = arguments[i]\n      if (Array.isArray(source)) {\n        source <= ShortArray ? list.push.apply(list, source)\n          : (list = list.concat(source))\n        isSparse = isSparse || source.isSparse\n      } else {\n        var next = iterateOf(source)\n        if (!next) {\n          list.push(source)\n        } else {\n          var item = next()\n          while (typeof item !== 'undefined' && item !== null) {\n            list.push(Array.isArray(item) ? item.length > 0 ? item[0] : null : item)\n            item = next()\n          }\n        }\n      }\n    }\n    isSparse && asSparse.call(list)\n    return list\n  }, true)\n\n  var proto = Type.proto\n  // return the length of this array.\n  link(proto, 'length', function () {\n    return this.length\n  })\n  // check whether this array is a sparse one.\n  link(proto, 'is-sparse', function () {\n    return this.isSparse || false\n  })\n  link(proto, 'not-sparse', function () {\n    return !this.isSparse\n  })\n  // mark this array as a sparse or common array.\n  var asSparse = link(proto, 'as-sparse', function (flag) {\n    defineProperty(this, 'isSparse',\n      typeof flag === 'undefined' || boolValueOf(flag)\n    )\n    return this\n  })\n  // return the amount of elements.\n  var count = function (filter) {\n    var i = 0\n    var counter = 0\n    if (isApplicable(filter)) {\n      for (; i < this.length; i++) {\n        typeof this[i] !== 'undefined' &&\n          boolValueOf(filter.call(this, this[i], i)) && counter++\n      }\n    } else {\n      for (; i < this.length; i++) {\n        typeof this[i] !== 'undefined' && counter++\n      }\n    }\n    return counter\n  }\n  link(proto, ['count', 'for-each'], Array.prototype.forEach ? function (filter) {\n    if (isSimple(this)) {\n      return count.call(this, filter)\n    }\n    var counter = 0\n    if (isApplicable(filter)) {\n      this.forEach(function (v, i) {\n        typeof v !== 'undefined' &&\n          boolValueOf(filter.call(this, v, i)) && counter++\n      })\n    } else {\n      this.forEach(function (v) {\n        typeof v !== 'undefined' && counter++\n      })\n    }\n    return counter\n  } : count)\n\n  // Mutability\n  link(proto, 'seal', function () {\n    return Object.freeze(this)\n  })\n  link(proto, 'is-sealed', function () {\n    return Object.isFrozen(this)\n  })\n\n  var stopSignal = new Error('tracing.stopped')\n  // call a handler for each element until it returns a truthy value.\n  var each = function (tracer) {\n    var value\n    if (isApplicable(tracer)) {\n      for (var i = 0; i < this.length; i++) {\n        value = this[i]\n        if (typeof value !== 'undefined' &&\n          boolValueOf(tracer.call(this, value, i))) break\n      }\n    }\n    return this\n  }\n  var trace = link(proto, 'trace', Array.prototype.forEach ? function (tracer) {\n    if (isSimple(this)) {\n      return each.call(this, tracer)\n    }\n    if (isApplicable(tracer)) {\n      try {\n        this.forEach(function (v, i, s) {\n          if (typeof v !== 'undefined' && boolValueOf(tracer.call(s, v, i))) {\n            throw stopSignal\n          }\n        }, this)\n      } catch (err) {\n        if (err !== stopSignal) throw err\n      }\n    }\n    return this\n  } : each)\n\n  // like trace, but to traverse all element from the end.\n  var eachRight = function (tracer) {\n    var value\n    if (isApplicable(tracer)) {\n      for (var i = this.length - 1; i >= 0; i--) {\n        value = this[i]\n        if (typeof value !== 'undefined' &&\n          boolValueOf(tracer.call(this, value, i))) break\n      }\n    }\n    return this\n  }\n  var retrace = link(proto, 'retrace', Array.prototype.reduceRight ? function (tracer) {\n    if (isSimple(this)) {\n      return eachRight.call(this, tracer)\n    }\n    if (isApplicable(tracer)) {\n      try {\n        this.reduceRight(function (_, v, i, s) {\n          if (typeof v !== 'undefined' && boolValueOf(tracer.call(s, v, i))) {\n            throw stopSignal\n          }\n        }, this)\n      } catch (err) {\n        if (err !== stopSignal) throw err\n      }\n    }\n    return this\n  } : eachRight)\n\n  // generate an iterator function to traverse all array items.\n  var iterate = function (list, begin, end) {\n    var current\n    return function (inSitu) {\n      if (typeof current !== 'undefined' &&\n        typeof inSitu !== 'undefined' && boolValueOf(inSitu)) {\n        return current\n      }\n      while (begin < end && typeof list[begin] === 'undefined') {\n        begin++\n      }\n      return begin >= end ? null : (current = [list[begin], begin++])\n    }\n  }\n  link(proto, 'iterate', function (begin, end) {\n    begin = beginOf(this.length, begin)\n    end = endOf(this.length, end)\n    if (isSimple(this)) {\n      return iterate(this, begin, end)\n    }\n    var list = this\n    var indices = []\n    trace.call(this, function (_, i) {\n      return i >= end || (\n        (i >= begin && indices.push(i)) && false\n      )\n    })\n    var current\n    begin = 0; end = indices.length\n    return function (inSitu) {\n      if (typeof current !== 'undefined' &&\n        typeof inSitu !== 'undefined' && boolValueOf(inSitu)) {\n        return current\n      }\n      if (begin >= end) {\n        return null\n      }\n      var index = indices[begin++]\n      return (current = [list[index], index])\n    }\n  })\n\n  // to create a shallow copy of this instance with all items,\n  // or selected items in a range.\n  link(proto, 'copy', function (begin, count) {\n    begin = beginOf(this.length, begin)\n    count = typeof count === 'undefined' ? this.length : count >> 0\n    if (count < 0) {\n      count = 0\n    }\n    var list = this.slice(begin, begin + count)\n    return this.isSparse ? asSparse.call(list) : list\n  })\n  link(proto, 'slice', function (begin, end) {\n    var list = this.slice(beginOf(this.length, begin), endOf(this.length, end))\n    return this.isSparse ? asSparse.call(list) : list\n  })\n\n  // create a new array with items in this array and argument values.\n  link(proto, 'concat', function () {\n    var list = this.concat(Array.prototype.slice.call(arguments))\n    return this.isSparse ? asSparse.call(list) : list\n  })\n\n  // append more items to the end of this array\n  var appendFrom = link(proto, ['append', '+='], function () {\n    var isSparse\n    for (var i = 0; i < arguments.length; i++) {\n      var src = arguments[i]\n      src = Array.isArray(src) ? src : arrayFrom(src)\n      this.push.apply(this, src)\n      isSparse = isSparse || src.isSparse\n    }\n    return isSparse && !this.isSparse ? asSparse.call(this) : this\n  })\n\n  // create a new array with items in this array and argument arrays.\n  link(proto, ['merge', '+'], function () {\n    var copy = this.slice()\n    this.isSparse && asSparse.call(copy)\n    return appendFrom.apply(copy, arguments)\n  })\n\n  // getter by index\n  var getter = link(proto, 'get', function (index) {\n    index = offsetOf(this.length, index)\n    return index >= 0 ? this[index] : null\n  })\n  // setter by index\n  var setter = link(proto, 'set', function (index, value) {\n    index = offsetOf(this.length, index);\n    ((index > 16) && (index + 1) >= (this.length / 2 * 3)) &&\n      !this.isSparse && asSparse.call(this, true)\n    return index < 0 ? null\n      : (this[index] = typeof value === 'undefined' ? null : value)\n  })\n  // reset one or more entries by indices\n  link(proto, 'reset', function (index) {\n    var length = this.length\n    for (var i = 0; i < arguments.length; i++) {\n      index = offsetOf(length, arguments[i]);\n      (index >= 0) && (delete this[index])\n    }\n    return this\n  })\n\n  // remove all entries or some values from this array.\n  var clear = function (value) {\n    var argc = arguments.length\n    if (argc < 1) {\n      this.splice(0)\n    } else {\n      for (var i = this.length - 1; i >= 0; i--) {\n        for (var j = 0; j < argc; j++) {\n          value = this[i]\n          if (typeof value !== 'undefined' &&\n            thisCall(this[i], 'equals', arguments[j])) {\n            this.splice(i, 1); break\n          }\n        }\n      }\n    }\n    return this\n  }\n  link(proto, 'clear', function (value) {\n    var argc = arguments.length\n    if (argc < 1) {\n      this.splice(0)\n      return this\n    }\n    if (isSimple(this)) {\n      return clear.apply(this, arguments)\n    }\n    var args = Array.prototype.slice.call(arguments)\n    retrace.call(this, function (v, i) {\n      for (var j = 0; j < argc; j++) {\n        if (thisCall(v, 'equals', args[j])) {\n          this.splice(i, 1); return\n        }\n      }\n    })\n    return this\n  })\n  // remove one or more values to create a new array.\n  var remove = function (value) {\n    var argc = arguments.length\n    var result = this.isSparse ? asSparse.call([]) : []\n    for (var i = 0, offset = 0; i < this.length; i++) {\n      value = this[i]\n      if (typeof value === 'undefined') {\n        offset++; continue\n      }\n      var keep = true\n      for (var j = 0; j < argc; j++) {\n        if (thisCall(value, 'equals', arguments[j])) {\n          keep = false; break\n        }\n      }\n      keep && (result[offset++] = value)\n    }\n    return result\n  }\n  link(proto, 'remove', function (value) {\n    var argc = arguments.length\n    if (argc < 1) {\n      return this.isSparse ? asSparse.call(this.slice()) : this.slice()\n    }\n    if (isSimple(this)) {\n      return remove.apply(this, arguments)\n    }\n    var args = Array.prototype.slice.call(arguments)\n    var result = this.isSparse ? asSparse.call([]) : []\n    var removed = 0\n    trace.call(this, function (v, i) {\n      var keep = true\n      for (var j = 0; j < argc; j++) {\n        if (thisCall(v, 'equals', args[j])) {\n          keep = false; break\n        }\n      }\n      keep ? (result[i - removed] = v) : removed++\n    })\n    return result\n  })\n\n  // replace all occurrences of a value to another value or reset them.\n  var replace = function (value, newValue) {\n    var i, current\n    if (typeof newValue === 'undefined') {\n      for (i = this.length - 1; i >= 0; i--) {\n        current = this[i]\n        if (typeof current !== 'undefined' &&\n          thisCall(current, 'equals', value)) {\n          delete this[i]\n        }\n      }\n    } else {\n      for (i = 0; i < this.length; i++) {\n        current = this[i]\n        if (typeof current !== 'undefined' &&\n          thisCall(current, 'equals', value)) {\n          this[i] = newValue\n        }\n      }\n    }\n    return this\n  }\n  link(proto, 'replace', function (value, newValue) {\n    if (typeof value === 'undefined') {\n      return this\n    }\n    if (isSimple(this)) {\n      return replace.call(this, value, newValue)\n    }\n    typeof newValue === 'undefined' ? retrace.call(this, function (v, i) {\n      thisCall(v, 'equals', value) && delete this[i]\n    }) : trace.call(this, function (v, i) {\n      thisCall(v, 'equals', value) && (this[i] = newValue)\n    })\n    return this\n  })\n\n  // check the existence of an element by a filter function\n  link(proto, 'has', function (filter) {\n    if (!isApplicable(filter)) { // as an index number\n      return typeof this[offsetOf(this.length, filter)] !== 'undefined'\n    }\n    var found = false\n    trace.call(this, function (v, i) {\n      return (found = boolValueOf(filter.call(this, v, i)))\n    })\n    return found\n  })\n  // check the existence of a value\n  var contains = function (value) {\n    var current\n    for (var i = 0; i < this.length; i++) {\n      current = this[i]\n      if (typeof current !== 'undefined' &&\n        thisCall(current, 'equals', value)) {\n        return true\n      }\n    }\n    return false\n  }\n  link(proto, 'contains', function (value) {\n    if (typeof value === 'undefined') {\n      return false\n    }\n    if (isSimple(this)) {\n      return contains.call(this, value)\n    }\n    var found = false\n    trace.call(this, function (v, i) {\n      return (found = thisCall(v, 'equals', value))\n    })\n    return found\n  })\n\n  // swap two value by offsets.\n  link(proto, 'swap', function (i, j) {\n    var length = this.length\n    i = offsetOf(length, i)\n    j = offsetOf(length, j)\n    if (i === j || i < 0 || i >= length || j < 0 || j >= length) {\n      return false\n    }\n    var tmp = this[i]\n    typeof this[j] === 'undefined' ? delete this[i] : this[i] = this[j]\n    typeof tmp === 'undefined' ? delete this[j] : this[j] = tmp\n    return true\n  })\n\n  // retrieve the first n element(s).\n  link(proto, 'first', function (count, filter) {\n    if (typeof count === 'undefined') {\n      return this[0]\n    }\n    if (isApplicable(count)) {\n      var found\n      trace.call(this, function (v, i) {\n        return boolValueOf(count.call(this, v, i)) ? (found = v) || true : false\n      })\n      return found\n    }\n    count >>= 0\n    if (count <= 0) {\n      return []\n    }\n    var result = []\n    if (isApplicable(filter)) {\n      trace.call(this, function (v, i) {\n        if (boolValueOf(filter.call(this, v, i))) {\n          result.push(v)\n          return (--count) <= 0\n        } // else return false\n      })\n    } else {\n      trace.call(this, function (v) {\n        result.push(v)\n        return (--count) <= 0\n      })\n    }\n    return result\n  })\n  // find the index of first occurrence of a value.\n  var firstOf = function (value) {\n    for (var i = 0; i < this.length; i++) {\n      var v = this[i]\n      if (typeof v !== 'undefined' && (\n        v === value || thisCall(v, 'equals', value)\n      )) {\n        return i\n      }\n    }\n    return null\n  }\n  var indexOf = link(proto, 'first-of', function (value) {\n    if (typeof value === 'undefined') {\n      return null\n    }\n    if (isSimple(this)) {\n      return firstOf.call(this, value)\n    }\n    var found = null\n    trace.call(this, function (v, i) {\n      return v === value || thisCall(v, 'equals', value)\n        ? (found = i) || true : false\n    })\n    return found\n  })\n  // retrieve the last n element(s).\n  link(proto, 'last', function (count, filter) {\n    if (typeof count === 'undefined') {\n      return this[this.length - 1]\n    }\n    if (isApplicable(count)) {\n      var found\n      retrace.call(this, function (v, i) {\n        return boolValueOf(count.call(this, v, i)) ? (found = v) || true : false\n      })\n      return found\n    }\n    count >>= 0\n    if (count <= 0) {\n      return []\n    }\n    var result = []\n    if (isApplicable(filter)) {\n      retrace.call(this, function (v, i) {\n        if (!boolValueOf(filter.call(this, v, i))) return\n        result.unshift(v); count--\n        return count <= 0\n      })\n    } else {\n      retrace.call(this, function (v) {\n        result.unshift(v); count--\n        return count <= 0\n      })\n    }\n    return result\n  })\n  // find the index of the last occurrence of a value.\n  var lastOf = function (value) {\n    for (var i = this.length - 1; i >= 0; i--) {\n      var v = this[i]\n      if (typeof v !== 'undefined' && (\n        v === value || thisCall(v, 'equals', value)\n      )) {\n        return i\n      }\n    }\n    return null\n  }\n  link(proto, 'last-of', function (value) {\n    if (typeof value === 'undefined') {\n      return null\n    }\n    if (isSimple(this)) {\n      return lastOf.call(this, value)\n    }\n    var found = null\n    retrace.call(this, function (v, i) {\n      return v === value || thisCall(v, 'equals', value)\n        ? (found = i) || true : false\n    })\n    return found\n  })\n\n  // edit current array\n  link(proto, 'insert', function (index, item) {\n    index = beginOf(this.length, index)\n    if (arguments.length > 2) {\n      var args = Array.prototype.slice.call(arguments, 2)\n      args.unshift(index, 0, item)\n      this.splice.apply(this, args)\n    } else {\n      this.splice(index, 0, item)\n    }\n    return this\n  })\n  link(proto, 'delete', function (index, count) {\n    index = offsetOf(this.length, index)\n    count = typeof count === 'undefined' ? 1 : count >> 0\n    index >= 0 && this.splice(index, count)\n    return this\n  })\n  link(proto, 'splice', function (index, count) {\n    if ((index >>= 0) < -this.length) {\n      if (arguments.length < 3) {\n        return []\n      }\n      var args = Array.prototype.slice.call(arguments)\n      args[0] = 0; args[1] = 0\n      return this.splice.apply(this, args)\n    }\n    switch (arguments.length) {\n      case 0:\n        return this.splice()\n      case 1:\n        return this.splice(index)\n      case 2:\n        return this.splice(index, count)\n      default:\n        return this.splice.apply(this, arguments)\n    }\n  })\n\n  // stack operations.\n  link(proto, 'push', function () {\n    Array.prototype.push.apply(this, arguments)\n    return this\n  })\n  link(proto, 'pop', function (count) {\n    return typeof count === 'undefined' ? this.pop()\n      : (count >>= 0) >= this.length ? this.splice(0)\n        : count > 0 ? this.splice(this.length - count)\n          : this.splice(-1)\n  })\n\n  // queue operations.\n  link(proto, 'enqueue', function () {\n    this.unshift.apply(this, arguments)\n    return this\n  })\n  proto.dequeue = proto.pop // dequeue is only an alias of pop.\n\n  // reverse the order of all elements\n  link(proto, 'reverse', function () {\n    return this.reverse()\n  })\n\n  // re-arrange elements in an array.\n  var comparerOf = function (reversing, comparer) {\n    return reversing ? function (a, b) {\n      var order = comparer(a, b)\n      return order > 0 ? -1 : order < 0 ? 1 : 0\n    } : function (a, b) {\n      var order = comparer(a, b)\n      return order > 0 ? 1 : order < 0 ? -1 : 0\n    }\n  }\n  var ascComparer = function (a, b) {\n    var order = thisCall(a, 'compare', b)\n    return order > 0 ? 1 : order < 0 ? -1 : 0\n  }\n  var descComparer = function (a, b) {\n    var order = thisCall(a, 'compare', b)\n    return order > 0 ? -1 : order < 0 ? 1 : 0\n  }\n  link(proto, 'sort', function (order, comparer) {\n    var reversing = false\n    if (typeof order === 'function') {\n      comparer = order\n    } else if ((order >> 0) > 0) {\n      reversing = true\n    }\n    var comparing = typeof comparer === 'function'\n      ? comparerOf(reversing, comparer)\n      : reversing ? descComparer : ascComparer\n    return this.sort(comparing)\n  })\n\n  // collection operations\n  link(proto, 'find', function (filter) {\n    var result = []\n    if (isApplicable(filter)) {\n      trace.call(this, function (v, i) {\n        boolValueOf(filter.call(this, v, i)) && result.push(i)\n      })\n    } else { // pick all valid indices.\n      trace.call(this, function (v, i) { result.push(i) })\n    }\n    return result\n  })\n  link(proto, 'select', Array.prototype.filter ? function (filter) {\n    return isApplicable(filter) ? this.filter(function (v, i) {\n      return typeof v !== 'undefined' && boolValueOf(filter.call(this, v, i))\n    }, this) : this.filter(function (v) {\n      return typeof v !== 'undefined' // pick all valid indices.\n    }, this)\n  } : function (filter) {\n    var result = []\n    if (isApplicable(filter)) {\n      trace.call(this, function (v, i) {\n        boolValueOf(filter.call(this, v, i)) && result.push(v)\n      })\n    } else { // pick all valid indices.\n      trace.call(this, function (v) { result.push(v) })\n    }\n    return result\n  })\n  link(proto, 'map', Array.prototype.map ? function (converter) {\n    var result = isApplicable(converter)\n      ? this.map(function (v, i) {\n        if (typeof v !== 'undefined') {\n          return converter.call(this, v, i)\n        }\n      }, this) : this.slice()\n    this.isSparse && asSparse.call(result)\n    return result\n  } : function (converter) {\n    var result = this.slice()\n    this.isSparse && asSparse.call(result)\n    if (isApplicable(converter)) {\n      trace.call(this, function (v, i) {\n        var value = converter.call(this, v, i)\n        result[i] = typeof value === 'undefined' ? null : value\n      })\n    }\n    return result\n  })\n  link(proto, 'reduce', Array.prototype.reduce ? function (value, reducer) {\n    if (!isApplicable(reducer)) {\n      if (!isApplicable(value)) {\n        return value\n      }\n      reducer = value\n      value = null\n    }\n    return this.reduce(function (s, v, i, t) {\n      return typeof v !== 'undefined' ? reducer.call(t, s, v, i) : s\n    }, value)\n  } : function (value, reducer) {\n    if (!isApplicable(reducer)) {\n      if (!isApplicable(value)) {\n        return value\n      }\n      reducer = value\n      value = null\n    }\n    trace.call(this, function (v, i) {\n      value = reducer.call(this, value, v, i)\n    })\n    return value\n  })\n\n  link(proto, 'join', Array.prototype.reduce ? function (separator) {\n    var last = -1\n    var strings = this.reduce(function (s, v, i, t) {\n      if (typeof v !== 'undefined') {\n        checkSpacing(s, i, last)\n        s.push(typeof v === 'string' ? v : thisCall(v, 'to-string'))\n        last = i\n      }\n      return s\n    }, [])\n    checkSpacing(strings, this.length, last)\n    return strings.join(typeof separator === 'string' ? separator : ' ')\n  } : function (separator) {\n    var last = -1\n    var s = []\n    trace.call(this, function (v, i) {\n      checkSpacing(s, i, last)\n      s.push(typeof v === 'string' ? v : thisCall(v, 'to-string'))\n      last = i\n    })\n    checkSpacing(s, this.length, last)\n    return s.join(typeof separator === 'string' ? separator : ' ')\n  })\n\n  // determine emptiness by array's length\n  link(proto, 'is-empty', function () {\n    return !(this.length > 0)\n  })\n  link(proto, 'not-empty', function () {\n    return this.length > 0\n  })\n\n  // default object persistency & describing logic\n  var toCode = link(proto, 'to-code', function (ctx) {\n    if (ctx instanceof EncodingContext$) {\n      var sym = ctx.begin(this)\n      if (sym) { return sym }\n    } else {\n      ctx = new EncodingContext$(this)\n    }\n    var code = [$Symbol.literal]\n    var last = -1\n    trace.call(this, function (v, i) {\n      v = ctx.encode(v);\n      (i - last) > 1 ? code.push(i, $Symbol.pairing, v) : code.push(v)\n      last = i\n    })\n    return ctx.end(this, Type, new Tuple$(code))\n  })\n\n  // Description\n  link(proto, 'to-string', function () {\n    return thisCall(toCode.call(this), 'to-string')\n  })\n\n  // Indexer\n  var indexer = link(proto, ':', function (index, value) {\n    return typeof index === 'number'\n      ? typeof value === 'undefined' ? getter.call(this, index)\n        : setter.call(this, index, value)\n      : typeof index === 'string' ? protoValueOf(this, proto, index)\n        : index instanceof Symbol$ ? protoValueOf(this, proto, index.key)\n          : indexOf.call(this, index)\n  })\n  indexer.get = function (key) {\n    return proto[key]\n  }\n\n  // export type indexer.\n  link(Type, 'indexer', indexer)\n}\n","'use strict'\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var Type = $.bool\n  var link = $void.link\n  var Symbol$ = $void.Symbol\n  var protoValueOf = $void.protoValueOf\n\n  // the empty value of bool is the false.\n  link(Type, 'empty', false)\n\n  // booleanize\n  $void.boolValueOf = link(Type, 'of', function (value) {\n    return value !== null && value !== 0 && value !== false && typeof value !== 'undefined'\n  }, true)\n\n  var proto = Type.proto\n  // Emptiness\n  link(proto, 'is-empty', function () {\n    return this === false\n  })\n  link(proto, 'not-empty', function () {\n    return this !== false\n  })\n\n  // Representation\n  link(proto, 'to-string', function () {\n    return this === true ? 'true' : 'false'\n  })\n\n  // Indexer\n  var indexer = link(proto, ':', function (index) {\n    return typeof index === 'string' ? protoValueOf(this, proto, index)\n      : index instanceof Symbol$ ? protoValueOf(this, proto, index.key) : null\n  })\n  indexer.get = function (key) {\n    return proto[key]\n  }\n\n  // export type indexer.\n  link(Type, 'indexer', indexer)\n}\n","'use strict'\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var Type = $.class\n  var $Type = $.type\n  var $Tuple = $.tuple\n  var $Symbol = $.symbol\n  var $Object = $.object\n  var Tuple$ = $void.Tuple\n  var Symbol$ = $void.Symbol\n  var ClassType$ = $void.ClassType\n  var ClassInst$ = $void.ClassInst\n  var link = $void.link\n  var typeOf = $void.typeOf\n  var bindThis = $void.bindThis\n  var isObject = $void.isObject\n  var thisCall = $void.thisCall\n  var boolValueOf = $void.boolValueOf\n  var createClass = $void.createClass\n  var isApplicable = $void.isApplicable\n  var ownsProperty = $void.ownsProperty\n  var protoValueOf = $void.protoValueOf\n  var sharedSymbolOf = $void.sharedSymbolOf\n  var EncodingContext$ = $void.EncodingContext\n\n  // initialize the meta class.\n  link(Type, 'empty', createClass, true)\n\n  // define a class by classes and/or class descriptors.\n  link(Type, 'of', function () {\n    return as.apply(createClass(), arguments)\n  }, true)\n\n  // copy fields from source objects to the target class instance or an object.\n  var objectAssign = $Object.assign\n  link(Type, 'attach', function (target) {\n    if (target instanceof ClassInst$) {\n      for (var i = 1; i < arguments.length; i++) {\n        var src = arguments[i]\n        if (isObject(src)) {\n          Object.assign(target, src)\n          activate.call(target, src)\n        }\n      }\n      return target\n    }\n    // fallback to object assign for the class may not exist on target context.\n    return objectAssign.apply($Object, arguments)\n  }, true)\n\n  // the prototype of classes\n  var proto = Type.proto\n\n  // generate an empty instance.\n  link(proto, 'empty', function () {\n    return Object.create(this.proto)\n  })\n\n  // generate an instance without arguments.\n  link(proto, 'default', function () {\n    return construct.call(Object.create(this.proto))\n  })\n\n  // static construction: create an instance by arguments.\n  link(proto, 'of', function () {\n    return construct.apply(Object.create(this.proto), arguments)\n  })\n\n  // static activation: restore an instance by one or more property set.\n  link(proto, 'from', function () {\n    var inst = Object.create(this.proto)\n    for (var i = 0; i < arguments.length; i++) {\n      var src = arguments[i]\n      if (isObject(src)) {\n        Object.assign(inst, src)\n        activate.call(inst, src)\n      }\n    }\n    return inst\n  })\n\n  // make this class to act as other classes and/or class descriptors.\n  var isAtom = $Tuple.accepts\n  var as = link(proto, 'as', function () {\n    if (Object.isFrozen(this)) {\n      return this\n    }\n    var type_ = Object.create(null)\n    var proto_ = Object.create(null)\n    var args = Array.prototype.slice.call(arguments)\n    for (var i = 0; i < args.length; i++) {\n      var src = args[i]\n      var t, p\n      if (src instanceof ClassType$) {\n        t = src\n        p = src.proto\n      } else if (isObject(src)) {\n        p = src\n        if (isObject(src.type)) {\n          t = src.type\n        } else {\n          if (src.type instanceof ClassType$) {\n            args.splice(i + 1, 0, src.type)\n          }\n          t = {}\n        }\n      } else {\n        t = {}; p = {}\n      }\n      var j, key\n      var names = Object.getOwnPropertyNames(t)\n      for (j = 0; j < names.length; j++) {\n        key = names[j]\n        if (key === 'indexer') {\n          // allow customized indexer for class\n          !ownsProperty(proto_, ':') && isApplicable(t.indexer) && (\n            proto_[':'] = t.indexer\n          )\n        } else if ((typeof this[key] === 'undefined') &&\n          !ownsProperty(type_, key)\n        ) {\n          if (key !== 'name' || !(t instanceof ClassType$)) {\n            // not to copy a type's name, but copy a definition name field\n            type_[key] = t[key]\n          }\n        }\n      }\n      names = Object.getOwnPropertyNames(p)\n      var value\n      for (j = 0; j < names.length; j++) {\n        key = names[j]\n        if (key !== 'type' && !ownsProperty(this.proto, key) && !ownsProperty(proto_, key)) {\n          value = p[key]\n          proto_[key] = isAtom(value) || (typeof value === 'function') ? value : null\n        }\n      }\n    }\n    Object.assign(this, type_)\n    Object.assign(this.proto, proto_)\n    return this\n  })\n\n  // Convert this class's definition to a type descriptor object.\n  var toObject = link(proto, 'to-object', function () {\n    var typeDef = $Object.empty()\n    var names = Object.getOwnPropertyNames(this.proto)\n    var i, name, value, thisEmpty\n    for (i = 0; i < names.length; i++) {\n      name = names[i]\n      if (name !== 'type') {\n        value = this.proto[name]\n        typeDef[name] = !isApplicable(value) ? value\n          : thisCall(value, 'bind', typeof thisEmpty !== 'undefined'\n            ? thisEmpty : (thisEmpty = this.empty())\n          )\n      }\n    }\n    var typeStatic = $Object.empty()\n    var hasStatic = false\n    names = Object.getOwnPropertyNames(this)\n    for (i = 0; i < names.length; i++) {\n      name = names[i]\n      if (name !== 'proto') {\n        value = this[name]\n        typeStatic[name] = !isApplicable(value) ? value\n          : thisCall(value, 'bind', this)\n        hasStatic = true\n      }\n    }\n    hasStatic && (typeDef.type = typeStatic)\n    return typeDef\n  })\n\n  // Mutability\n  link(proto, 'seal', function () {\n    return Object.freeze(this)\n  })\n  link(proto, 'is-sealed', function () {\n    return Object.isFrozen(this)\n  })\n\n  // Type Verification: a class is a class and a type.\n  link(proto, ['is-a', 'is-an'], function (type) {\n    return type === Type || type === $Type\n  })\n  link(proto, ['is-not-a', 'is-not-an'], function (type) {\n    return type !== Type && type !== $Type\n  })\n\n  // Emptiness: shared by all classes.\n  link(proto, 'is-empty', function () {\n    return !(Object.getOwnPropertyNames(this.proto).length > 1) && !(\n      Object.getOwnPropertyNames(this).length > (\n        ownsProperty(this, 'name') ? 2 : 1\n      )\n    )\n  })\n  link(proto, 'not-empty', function () {\n    return Object.getOwnPropertyNames(this.proto).length > 1 || (\n      Object.getOwnPropertyNames(this).length > (\n        ownsProperty(this, 'name') ? 2 : 1\n      )\n    )\n  })\n\n  // Encoding\n  var protoToCode = link(proto, 'to-code', function () {\n    return typeof this.name === 'string' && this.name\n      ? sharedSymbolOf(this.name.trim()) : $Symbol.empty\n  })\n\n  // Description\n  var symbolClass = sharedSymbolOf('class')\n  var symbolOf = sharedSymbolOf('of')\n  var objectToCode = $Object.proto['to-code']\n  var tupleToString = $Tuple.proto['to-string']\n  link(proto, 'to-string', function () {\n    var code = protoToCode.call(this)\n    if (code !== $Symbol.empty) {\n      return thisCall(code, 'to-string')\n    }\n    code = objectToCode.call(toObject.call(this))\n    if (code.$[0] === $Symbol.literal) {\n      code.$[1] === $Symbol.pairing ? code.$.splice(2, 0, symbolClass)\n        : code.$.splice(1, 0, $Symbol.pairing, symbolClass)\n    } else {\n      code = new Tuple$([symbolClass, symbolOf, code])\n    }\n    return tupleToString.call(code)\n  })\n\n  // the prototype of class instances\n  var instance = proto.proto\n\n  // root instance constructor\n  var construct = link(instance, 'constructor', function () {\n    if (this.constructor !== construct) {\n      this.constructor.apply(this, arguments)\n    } else { // behave like (object assign this ...)\n      var args = [this]\n      args.push.apply(args, arguments)\n      $Object.assign.apply($Object, args)\n    }\n    return this\n  })\n\n  // root instance activator: accept a plain object and apply the activator logic too.\n  var activate = link(instance, 'activator', function (source) {\n    if (this.activator !== activate) {\n      this.activator(source)\n    }\n    return this\n  })\n\n  // Generate a persona to act like another class.\n  link(instance, 'as', function (cls, member) {\n    if (!(cls instanceof ClassType$)) {\n      return null\n    }\n    if (member instanceof Symbol$) {\n      member = member.key\n    } else if (typeof member !== 'string' || !member) {\n      member = null\n    }\n\n    var value\n    if (member) {\n      value = cls.proto[member]\n      return isApplicable(value) ? bindThis(this, value) : value\n    }\n\n    var names = Object.getOwnPropertyNames(cls.proto)\n    var persona = Object.create($Object.proto)\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i]\n      value = cls.proto[name]\n      persona[name] = isApplicable(value) ? bindThis(this, value) : value\n    }\n    return persona\n  })\n\n  // Enable the customization of Identity.\n  var is = link(instance, ['is', '==='], function (another) {\n    return (this === another) || (\n      this.is !== is && isApplicable(this.is) && boolValueOf(this.is(another))\n    )\n  })\n  link(instance, ['is-not', '!=='], function (another) {\n    return !is.call(this, another)\n  })\n\n  // Enable the customization of Equivalence.\n  var equals = link(instance, ['equals', '=='], function (another) {\n    return this === another || is.call(this, another) || (\n      this.equals !== equals && isApplicable(this.equals) &&\n        boolValueOf(this.equals(another))\n    )\n  })\n  link(instance, ['not-equals', '!='], function (another) {\n    return !equals.call(this, another)\n  })\n\n  // Enable the customization of Ordering.\n  var compare = link(instance, 'compare', function (another) {\n    var ordering\n    return this === another || equals.call(this, another) ? 0\n      : this.compare === compare || !isApplicable(this.compare) ? null\n        : (ordering = this.compare(another)) > 0 ? 1\n          : ordering < 0 ? -1\n            : ordering === 0 ? 0 : null\n  })\n\n  // Emptiness: allow customization.\n  var isEmpty = link(instance, 'is-empty', function () {\n    var overriding = this['is-empty']\n    return overriding !== isEmpty && isApplicable(overriding)\n      ? boolValueOf(overriding.call(this))\n      : Object.getOwnPropertyNames(this).length < 1\n  })\n  link(instance, 'not-empty', function () {\n    return !isEmpty.call(this)\n  })\n\n  // Type Verification\n  var isA = link(instance, ['is-a', 'is-an'], function (t) {\n    if (t === $Object || (this.type instanceof ClassType$ && t === this.type)) {\n      return true\n    }\n    var overriding = this['is-a']\n    if (overriding !== isA && isApplicable(overriding)) {\n      return boolValueOf(overriding.call(this, t))\n    }\n    if (!(t instanceof ClassType$) || !t.proto) {\n      return false\n    }\n    var members = Object.getOwnPropertyNames(t.proto)\n    for (var i = 0; i < members.length; i++) {\n      if (typeof this[members[i]] === 'undefined') {\n        return false\n      }\n    }\n    return true\n  })\n  link(instance, ['is-not-a', 'is-not-an'], function (t) {\n    return !isA.call(this, t)\n  })\n\n  // Enable the customization of Encoding.\n  var toCode = link(instance, 'to-code', function (ctx) {\n    var overriding = this['to-code']\n    if (overriding === toCode || typeof overriding !== 'function') {\n      return objectToCode.call(this, ctx) // not overridden\n    }\n    if (ctx instanceof EncodingContext$) {\n      var sym = ctx.begin(this)\n      if (sym) { return sym }\n    } else {\n      ctx = new EncodingContext$(this)\n    }\n    var code = overriding.call(this)\n    return typeOf(code) === $Object\n      ? ctx.end(this, this.type, objectToCode.call(code))\n      : code instanceof Tuple$ && code.plain !== true\n        ? ctx.end(this, $Object, code) // app handle its type information.\n        : ctx.end(this, this.type, objectToCode.call(this))\n  })\n\n  // Enable the customization of Description.\n  var toString = link(instance, 'to-string', function () {\n    var overriding = this['to-string']\n    return overriding === toString || typeof overriding !== 'function'\n      ? thisCall(toCode.call(this), 'to-string')\n      : overriding.apply(this, arguments)\n  })\n\n  var indexer = link(instance, ':', function (index, value) {\n    var overriding\n    if (typeof index === 'string') {\n      overriding = indexer\n    } else if (index instanceof Symbol$) {\n      index = index.key\n      overriding = indexer\n    } else {\n      overriding = this[':']\n    }\n    // setter\n    if (typeof value !== 'undefined') {\n      return typeof index === 'string' ? (this[index] = value)\n        : overriding === indexer ? null\n          : overriding.apply(this, arguments)\n    }\n    // getting\n    if (typeof index !== 'string') {\n      return overriding === indexer ? null : overriding.call(this, index)\n    }\n    value = protoValueOf(this, typeOf(this).proto || instance, index)\n    return typeof value === 'function' ? value : this[index]\n  })\n  indexer.get = function (key) {\n    var value = instance[key]\n    return typeof value === 'function' ? value : this[key]\n  }\n\n  // export type indexer.\n  link(proto, 'indexer', indexer)\n}\n","'use strict'\n\nfunction getTimezoneName () {\n  var format, options\n  return (\n    (format = Intl && Intl.DateTimeFormat && Intl.DateTimeFormat()) &&\n    (options = format && format.resolveOptions && format.resolveOptions()) &&\n    options.timeZone\n  ) || (\n    process && process.env.TZ\n  ) || UtcTimezoneOffset()\n}\n\nfunction UtcTimezoneOffset () {\n  var offset = (new Date()).getTimezoneOffset() / 60\n  return offset >= 0 ? 'UTC+' + offset.toString() : 'UTC' + offset.toString()\n}\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var Type = $.date\n  var $Object = $.object\n  var link = $void.link\n  var Symbol$ = $void.Symbol\n  var protoValueOf = $void.protoValueOf\n  var numberCompare = $.number.proto.compare\n  var numberToString = $.number.proto['to-string']\n\n  // the empty value\n  var empty = link(Type, 'empty', new Date(0))\n\n  // the invalid value.\n  var invalid = link(Type, 'invalid', new Date(NaN))\n\n  // parse a date/time string representation to a date object.\n  link(Type, 'parse', function (str) {\n    return typeof str !== 'string' ? invalid : new Date(str)\n  }, true)\n\n  // get current time or the time as a string, a timestamp or data fields.\n  link(Type, 'of', function (a, b, c, d, e, f, g) {\n    switch (arguments.length) {\n      case 0:\n        return empty\n      case 1: // string or timestamp\n        return a instanceof Date ? a : new Date(a)\n      case 2:\n        return new Date(a, b - 1)\n      case 3:\n        return new Date(a, b - 1, c)\n      case 4:\n        return new Date(a, b - 1, c, d)\n      case 5:\n        return new Date(a, b - 1, c, d, e)\n      case 6:\n        return new Date(a, b - 1, c, d, e, f)\n      default: // field values\n        return new Date(a, b - 1, c, d, e, f, g)\n    }\n  }, true)\n\n  // compose a date object with utc values of its fields\n  link(Type, 'of-utc', function (a, b, c, d, e, f, g) {\n    switch (arguments.length) {\n      case 0:\n        return empty\n      case 1: // string or timestamp\n        return new Date(Date.UTC(a, 0))\n      case 2:\n        return new Date(Date.UTC(a, b - 1))\n      case 3:\n        return new Date(Date.UTC(a, b - 1, c))\n      case 4:\n        return new Date(Date.UTC(a, b - 1, c, d))\n      case 5:\n        return new Date(Date.UTC(a, b - 1, c, d, e))\n      case 6:\n        return new Date(Date.UTC(a, b - 1, c, d, e, f))\n      default: // field values\n        return new Date(Date.UTC(a, b - 1, c, d, e, f, g))\n    }\n  }, true)\n\n  // get current time as a date object.\n  link(Type, 'now', function () {\n    return new Date()\n  }, true)\n\n  // get current time as its timestamp value.\n  link(Type, 'timestamp', function () {\n    return Date.now()\n  }, true)\n\n  link(Type, 'timezone', function () {\n    return $Object.of({\n      name: getTimezoneName(),\n      offset: (new Date()).getTimezoneOffset()\n    })\n  }, true)\n\n  var proto = Type.proto\n\n  // test if this is a valid date.\n  link(proto, 'is-valid', function () {\n    return !isNaN(this.getTime())\n  })\n  link(proto, 'is-invalid', function () {\n    return isNaN(this.getTime())\n  })\n\n  // retrieve the date fields: year, month, day\n  link(proto, 'date-fields', function (utc) {\n    return isNaN(this.getTime()) ? null : utc\n      ? [this.getUTCFullYear(), this.getUTCMonth() + 1, this.getUTCDate()]\n      : [this.getFullYear(), this.getMonth() + 1, this.getDate()]\n  })\n  // retrieve the time fields: hours, minutes, seconds, milliseconds\n  link(proto, 'time-fields', function (utc) {\n    return isNaN(this.getTime()) ? null : utc\n      ? [this.getUTCHours(), this.getUTCMinutes(), this.getUTCSeconds(), this.getUTCMilliseconds()]\n      : [this.getHours(), this.getMinutes(), this.getSeconds(), this.getMilliseconds()]\n  })\n  // retrieve all fields: year, month, day, hours, minutes, seconds, milliseconds\n  link(proto, 'all-fields', function (utc) {\n    return isNaN(this.getTime()) ? null : utc\n      ? [this.getUTCFullYear(), this.getUTCMonth() + 1, this.getUTCDate(),\n        this.getUTCHours(), this.getUTCMinutes(), this.getUTCSeconds(), this.getUTCMilliseconds()]\n      : [this.getFullYear(), this.getMonth() + 1, this.getDate(),\n        this.getHours(), this.getMinutes(), this.getSeconds(), this.getMilliseconds()]\n  })\n  // get the week day value, which starts from 0 for Sunday.\n  link(proto, 'week-day', function (utc) {\n    return isNaN(this.getTime()) ? null\n      : utc ? this.getUTCDay() : this.getDay()\n  })\n\n  link(proto, 'timestamp', function (utc) {\n    return this.getTime()\n  })\n\n  // support & override general operators\n  link(proto, '+', function (milliseconds) {\n    return typeof milliseconds === 'number'\n      ? new Date(this.getTime() + milliseconds)\n      : this\n  })\n  link(proto, '-', function (dateOrTime) {\n    return typeof dateOrTime === 'number'\n      ? new Date(this.getTime() - dateOrTime)\n      : dateOrTime instanceof Date\n        ? this.getTime() - dateOrTime.getTime()\n        : this\n  })\n\n  // Ordering: date comparison\n  var compare = link(proto, 'compare', function (another) {\n    return another instanceof Date\n      ? numberCompare.call(this.getTime(), another.getTime())\n      : null\n  })\n\n  // override Identity and Equivalence logic to test by timestamp value\n  link(proto, ['is', '===', 'equals', '=='], function (another) {\n    return this === another || compare.call(this, another) === 0\n  })\n  link(proto, ['is-not', '!==', 'not-equals', '!='], function (another) {\n    return this !== another && compare.call(this, another) !== 0\n  })\n\n  // ordering operators for instance values\n  link(proto, '>', function (another) {\n    var order = compare.call(this, another)\n    return order !== null ? order > 0 : null\n  })\n  link(proto, '>=', function (another) {\n    var order = compare.call(this, another)\n    return order !== null ? order >= 0 : null\n  })\n  link(proto, '<', function (another) {\n    var order = compare.call(this, another)\n    return order !== null ? order < 0 : null\n  })\n  link(proto, '<=', function (another) {\n    var order = compare.call(this, another)\n    return order !== null ? order <= 0 : null\n  })\n\n  // emptiness is defined to the 0 value of timestamp.\n  link(proto, 'is-empty', function () {\n    var ts = this.getTime()\n    return ts === 0 || isNaN(ts)\n  })\n  link(proto, 'not-empty', function () {\n    var ts = this.getTime()\n    return ts !== 0 && !isNaN(ts)\n  })\n\n  // Representation for instance & description for proto itself.\n  link(proto, 'to-string', function (format) {\n    if (typeof format === 'undefined') {\n      // encoding as source code by default.\n      var ts = this.getTime()\n      return isNaN(ts) ? '(date invalid)'\n        : ts === 0 ? '(date empty)'\n          : '(date of ' + numberToString.call(this.getTime()) + ')'\n    }\n    switch (format) {\n      case 'utc':\n        return this.toUTCString()\n      case 'date':\n        return this.toLocaleDateString()\n      case 'time':\n        return this.toLocaleTimeString()\n      default:\n        return this.toLocaleString()\n    }\n  })\n\n  // Indexer\n  var indexer = link(proto, ':', function (index) {\n    return typeof index === 'string' ? protoValueOf(this, proto, index)\n      : index instanceof Symbol$ ? protoValueOf(this, proto, index.key) : null\n  })\n  indexer.get = function (key) {\n    return proto[key]\n  }\n\n  // export type indexer.\n  link(Type, 'indexer', indexer)\n}\n","'use strict'\n\n// for any object, the object.proto.to-code will always be called firstly,\n// in the default to-code, the object.to-code will be called.\n// the same for the constructor: to ensure the instance will always be returned.\n// for object:\n//  - anything defined in type cannot be overridden in instance\n//  - object.proto.* will allow the overridden and ensure the consistency and type safe.\n\n// ployfill Map & Array.prototype.indexOf\nvar createIndex = typeof Map === 'function' ? function () {\n  var index = new Map()\n  return {\n    get: index.get.bind(index),\n    set: function (key, value) {\n      index.set(key, value)\n      return value\n    },\n    add: function (key, value) {\n      index.set(key, value)\n      return value\n    }\n  }\n} : typeof Array.prototype.indexOf === 'function' ? function () {\n  var keys = []\n  var values = []\n  return {\n    get: function (key) {\n      var offset = keys.indexOf(key)\n      if (offset >= 0) {\n        return values[offset]\n      }\n    },\n    set: function (key, value) {\n      var offset = keys.indexOf(key)\n      return offset >= 0 ? (values[offset] = value) : this.add(key, value)\n    },\n    add: function (key, value) {\n      keys.push(key)\n      values.push(value)\n      return value\n    }\n  }\n} : function () {\n  var keys = []\n  var values = []\n  return {\n    get: function (key) {\n      for (var i = keys.length - 1; i >= 0; i--) {\n        if (keys[i] === key) {\n          return values[i]\n        }\n      }\n    },\n    set: function (key, value) {\n      for (var i = keys.length - 1; i >= 0; i--) {\n        if (keys[i] === key) {\n          return (values[i] = value)\n        }\n      }\n      return this.add(key, value)\n    },\n    add: function (key, value) {\n      keys.push(key)\n      values.push(value)\n      return value\n    }\n  }\n}\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var $Tuple = $.tuple\n  var $Array = $.array\n  var $Object = $.object\n  var $Symbol = $.symbol\n  var Tuple$ = $void.Tuple\n  var Symbol$ = $void.Symbol\n  var isObject = $void.isObject\n  var thisCall = $void.thisCall\n  var sharedSymbolOf = $void.sharedSymbolOf\n\n  var symbolLocals = sharedSymbolOf('_')\n  var symbolObject = sharedSymbolOf('object')\n  var symbolClass = sharedSymbolOf('class')\n\n  var normalize = function (type) {\n    type = type['to-code']()\n    return type === $Symbol.empty ? symbolObject : type\n  }\n  var createInst = function (type) {\n    return type === $Array ? $Tuple.array\n      : type === $Object || (type = normalize(type)) === symbolObject\n        ? $Tuple.object\n        : new Tuple$([$Symbol.literal, $Symbol.pairing, type])\n  }\n  var updateInst = function (ref, type, code) {\n    // remove unnecessary activation for data entity.\n    var items = code.$\n    if (items.length > 2 && items[0] === $Symbol.literal &&\n      items[1] === $Symbol.pairing && (items[2] instanceof Symbol$)\n    ) {\n      var cls = items[2].key\n      if (cls !== 'array' && cls !== 'object' && cls !== 'class') {\n        items.length > 3 ? items.splice(1, 2) : items.splice(2, 1)\n      }\n    }\n    return type === $Array\n      ? new Tuple$([ref, $Symbol.of('append'), code])\n      : type === $Object || (type = normalize(type)) === symbolObject\n        ? new Tuple$([symbolObject, $Symbol.of('assign'), ref, code])\n        : new Tuple$([symbolClass, $Symbol.of('attach'), ref, code])\n  }\n\n  $void.EncodingContext = function (root) {\n    this.objects = createIndex()\n    this.objects.add(this.root = root, null)\n    this.clist = []\n    this.shared = []\n  }\n  $void.EncodingContext.prototype = {\n    _createRef: function (offset) {\n      var ref = new Tuple$([symbolLocals, this.shared.length])\n      this.shared.push(offset)\n      return ref\n    },\n    begin: function (obj) {\n      var offset = this.objects.get(obj)\n      if (typeof offset === 'undefined') { // first touch\n        return this.objects.add(obj, null)\n      }\n      var ref\n      if (offset === null) { // to be recursively reused.\n        offset = this.clist.length\n        ref = this._createRef(offset)\n        this.objects.set(obj, offset)\n        this.clist.push([ref, null, null])\n        return ref\n      }\n      var record = this.clist[offset]\n      ref = record[0]\n      if (!ref) { // to be reused.\n        ref = record[0] = this._createRef(offset)\n        var code = record[2]\n        var newCode = new Tuple$(code.$) // copy code of value.\n        code.$ = ref.$ // update original code from value to ref.\n        record[2] = newCode // save the new code of value.\n      }\n      return ref\n    },\n    encode: function (obj) {\n      return typeof obj === 'undefined' || obj === null ? null\n        : typeof obj === 'number' || typeof obj === 'string' ? obj\n          : (Array.isArray(obj) || isObject(obj))\n            ? thisCall(obj, 'to-code', this)\n            : thisCall(obj, 'to-code')\n    },\n    end: function (obj, type, code) {\n      // try to supplement type to code\n      if (type !== $Array && type !== $Object && type.name) {\n        if (code.$[1] !== $Symbol.pairing) {\n          code.$.splice(1, 0, $Symbol.pairing, sharedSymbolOf(type.name))\n        } else if (code.$.length < 3) {\n          code.$.splice(2, 0, sharedSymbolOf(type.name))\n        }\n      }\n      // assert(code instanceof Tuple$)\n      var offset = this.objects.get(obj)\n      // assert(typeof offset !== 'undefined')\n      if (offset === null) {\n        offset = this.clist.length\n        this.objects.set(obj, offset)\n        this.clist.push([null, type, code])\n        return obj === this.root ? this._finalize(offset) : code\n      }\n      // recursive reference\n      var record = this.clist[offset]\n      record[1] = type\n      record[2] = code\n      return obj === this.root ? this._finalize(offset) : record[0]\n    },\n    _finalize: function (rootOffset) {\n      if (this.shared.length < 1) {\n        // no circular or shared array/object.\n        return this.clist[rootOffset][2]\n      }\n      var args = [$Symbol.literal] // (@ ...)\n      var body = [new Tuple$([ // (local _ args) ...\n        $Symbol.local, symbolLocals, new Tuple$(args)\n      ])]\n      var root\n      for (var i = 0; i < this.shared.length; i++) {\n        var offset = this.shared[i]\n        var record = this.clist[offset]\n        args.push(createInst(record[1]))\n        offset === rootOffset\n          ? (root = updateInst.apply(null, record))\n          : body.push(updateInst.apply(null, record))\n      }\n      body.push(root || this.clist[rootOffset][2])\n      return new Tuple$([ // (=>:() (local _ (@ ...)) ...)\n        $Symbol.function, $Symbol.pairing, $Tuple.empty, new Tuple$(body, true)\n      ])\n    }\n  }\n}\n","\n'use strict'\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var Type = $.function\n  var $Tuple = $.tuple\n  var $Object = $.object\n  var Tuple$ = $void.Tuple\n  var link = $void.link\n  var bindThis = $void.bindThis\n  var safelyAssign = $void.safelyAssign\n  var prepareOperation = $void.prepareOperation\n  var prepareApplicable = $void.prepareApplicable\n\n  // the noop function\n  var noop = link(Type, 'noop', $void.function(function () {\n    return null\n  }, $Tuple.function), true)\n\n  // implement common operation features.\n  prepareOperation(Type, noop, $Tuple.function)\n\n  var proto = Type.proto\n  // bind a function to a fixed subject.\n  link(proto, 'bind', function ($this) {\n    return bindThis(typeof $this !== 'undefined' ? $this : null, this)\n  })\n\n  // JS-InterOp: retrieve generic members of a native function.\n  link(proto, ['generic', '$'], function () {\n    return this['--generic'] || (\n      this.code instanceof Tuple$ ? null // only for generic functions.\n        : (this['--generic'] = safelyAssign($Object.empty(),\n          typeof this.bound === 'function' ? this.bound : this\n        ))\n    )\n  })\n\n  // implement applicable operation features.\n  prepareApplicable(Type, $Tuple.function)\n}\n","'use strict'\n\nmodule.exports = function () {\n  /*\n    The Prologue.\n  */\n  // The Void is out of the scope of the Being and cannot be analyzed in the\n  // scope of Being. Therefore, it cannot be described as either existent or\n  // nonexistent. Boolean logic is part of the Being.\n  var $void = {}\n\n  /*\n    The Beginning.\n  */\n  /* In the beginning God created the heavens and the earth. */\n  var Null = $void.null = Object.create(null)\n  /* Now the earth was formless and empty, */\n  var $ = $void.$ = Object.create(null) /* 0. Generation */\n\n  /* “Let there be light,” and there was light. */\n  // The light is the laws, which are the foundation of all beings.\n  var Prototype = Object.create(Null) /* 1. Derivation */\n  var Type$ = $void.Type$ = function () { /* 2. Separation & Aggregation */\n    // This function should be executed once, and only once.\n    // The primal type is derived from the supreme prototype.\n    this.proto = Prototype\n    // The primal type is the container type of the supreme prototype.\n    defineTypeProperty(Prototype, this)\n  }\n  Type$.prototype = Prototype\n\n  /* Nameless beginning of heaven and earth, the famous mother of all things. */\n  function naming (type, name) {\n    $[name] = type\n    type.name = name\n    return type\n  }\n\n  /* ... he separated the light from the darkness, */\n  var Type = new Type$()\n  /* ... called the light “day,”  */\n  naming(Type, 'type')\n  /* ... and the darkness he called “night.” */\n  $.null = null\n\n  // The logical noumenon of null is not accessible directly, otherwise it will\n  // cause some confusion in evaluation process.\n  // P.S, so is our fate too?\n\n  /* A placeholder constructor to test a type. */\n  $void.Type = function () {}\n  $void.Type.prototype = Type\n\n  /* It's ready to create primitive types, */\n  function create (name) {\n    var type = Object.create(Type)\n    // a new type should have a new nature.\n    type.proto = Object.create(Type.proto)\n    // a proto always intrinsically knows its container type.\n    defineTypeProperty(type.proto, type)\n    // give a name to the new type.\n    naming(type, name)\n    return type\n  }\n\n  /* And there was evening, and there was morning — the first day. */\n  /*   - from Bible and Dao Te Ching */\n\n  /*\n    The Creating.\n  */\n  /* Static Value Types */\n  /* All static values are fixed points of evaluation function. */\n  /* All static values can be fully encoded and recovered by evaluation. */\n\n  // A boolean type is not a prerequisite to implement boolean logic, but it\n  // may help to avoid ambiguity in many cases.\n  create('bool')\n\n  // A string is a piece of free form text.\n  create('string')\n\n  // A number may have a real number value in the proper range.\n  create('number')\n\n  // A date value is a combination of a timestamp and a associated locale string.\n  create('date')\n  $void.Date = Date\n\n  // A range value represents a discrete sequence of numbers in the interval of\n  // [begin, end) and a step value.\n  create('range')\n  var Range$ = $void.Range = function (begin, end, step) {\n    this.begin = begin\n    this.end = end\n    this.step = step\n  }\n  Range$.prototype = $.range.proto\n\n  /* Expression Types */\n  /* An expression entity may produce another entity after evaluation. */\n  /* An expression value can be fully encoded and recovered. */\n  /* A static value can also be a part of an expression. */\n\n  // A symbol is an identifer of a semantic element, so the string value of its\n  // key must comply with some fundamental lexical rules.\n  // A symbol will be resolved to the associated value under current context or\n  // null by the evaluation function.\n  create('symbol')\n  var Symbol$ = $void.Symbol = function (key) {\n    this.key = key\n  }\n  Symbol$.prototype = $.symbol.proto\n\n  // A tuple is a list of other static values, symbols and tuples.\n  // A tuple will be interpreted as a statement under current context to produce\n  // an output value by the evaluation function.\n  // The name 'list' is left to be used for more common scenarios.\n  create('tuple')\n  var Tuple$ = $void.Tuple = function (list, plain, source) {\n    this.$ = list // hidden native data\n    this.plain = plain === true // as code block.\n    if (source) { // reserved for source map and other debug information.\n      this.source = source\n    }\n  }\n  Tuple$.prototype = $.tuple.proto\n\n  /* Operation Types */\n  /* All operations will be evaluated to the output of its invocation. */\n\n  // An operator is an operation which accepts raw argument expressions, which\n  // means no evaluation happens to arguments before the invocation, to allow\n  // more syntax structures can be defined.\n  // An operator is an immutable entity and can be fully encoded.\n  var operator = create('operator')\n  $void.operator = function (impl, code) {\n    impl.type = $.operator\n    impl.code = code\n    return impl\n  }\n\n  // the container for static operators. Static operators are taken as an\n  // essential part of the language itself. They cannot be overridden.\n  $void.staticOperators = Object.create(null)\n\n  // A lambda is another type of operation which wants the values of its arguments\n  // as input, so the runtime helps to evaluate all them before invocation.\n  // A lambda is an immutable entity and can be fully encoded.\n  create('lambda')\n  $void.lambda = function (impl, code) {\n    impl.type = $.lambda\n    impl.code = code\n    return impl\n  }\n  $void.stambda = function (impl, code) {\n    impl.type = $.lambda\n    impl.code = code\n    impl.static = true\n    return impl\n  }\n  $void.constambda = function (impl, code) {\n    impl.type = $.lambda\n    impl.code = code\n    impl.const = true\n    if (typeof impl.this === 'undefined') {\n      impl.this = null\n    }\n    if (typeof impl.bound !== 'function') {\n      impl.bound = impl\n    }\n    return impl\n  }\n\n  // A function is an operation which works like a Closure. Its behavior depends\n  // on both the values of arguments and current values in its outer context.\n  // A function is not explicitly alterable but its implicit context is dynamic\n  // and persistent in running. So its overall state is mutable.\n  // For the existence of the context, a function cannot be fully encoded. But\n  // it may be automatically downgraded to a lambda when the encoding is required.\n  create('function')\n  $void.function = function (impl, code) {\n    impl.type = $.function\n    impl.code = code\n    return impl\n  }\n\n  // an operator is not a first-class value, so it can only be a direct predicate.\n  $void.isApplicable = function (func) {\n    return typeof func === 'function' && func.type !== operator\n  }\n\n  /* Transient Entity Types */\n  /* All transient entities will be encoded to empty instances. */\n\n  // A special type to wrap the transient state of an ongoing iteration.\n  create('iterator')\n  var Iterator$ = $void.Iterator = function (next) {\n    this.next = next\n  }\n  Iterator$.prototype = $.iterator.proto\n\n  // A special type to wrap the transient state of an ongoing action.\n  create('promise')\n  // If it's missing, app layer should provide the polyfill.\n  $void.Promise = Promise\n\n  /* Compound Types */\n  /* By default, compound entities are mutable. */\n  /* All compound entities are also fixed points of evaluation function. */\n\n  // A collection of values indexed by zero-based integers.\n  create('array')\n\n  // The object is the fundamental type of all compound entities.\n  create('object')\n  var Object$ = $void.Object = function (src) {\n    if (src) {\n      Object.assign(this, src)\n    }\n  }\n  Object$.prototype = $.object.proto\n\n  /*\n    The Evolution.\n  */\n  // Class is a meta type to create more types.\n  var $Class = naming(Object.create(Type), 'class')\n\n  // the prototype of classes is also a type.\n  var $ClassProto = $Class.proto = Object.create(Type)\n  $ClassProto.name = undefined\n  $ClassProto.type = $Class\n\n  // A fake constructor for instanceof checking for a class.\n  var ClassType$ = $void.ClassType = function () {}\n  ClassType$.prototype = $ClassProto\n\n  // the prototype of class instances is object.proto.\n  var $Instance = $ClassProto.proto = Object.create($.object.proto)\n  // A fake constructor for instanceof checking for an instance of a class.\n  var ClassInst$ = $void.ClassInst = function () {}\n  ClassInst$.prototype = $Instance\n\n  // export the ability of creation to enable an autonomous process.\n  $void.createClass = function () {\n    var class_ = Object.create($ClassProto)\n    // a new type should have a new nature.\n    class_.proto = Object.create($Instance)\n    // a proto always intrinsically knows its container type.\n    defineTypeProperty(class_.proto, class_)\n    return class_\n  }\n\n  // type is not enumerable.\n  $void.defineProperty = defineProperty\n  function defineProperty (obj, name, value) {\n    Object.defineProperty ? Object.defineProperty(obj, name, {\n      enumerable: false,\n      configurable: false,\n      writable: true,\n      value: value\n    }) : (obj[name] = value)\n    return value\n  }\n\n  function defineTypeProperty (proto, type) {\n    return defineProperty(proto, 'type', type)\n  }\n\n  $void.defineConst = defineConst\n  function defineConst (ctx, key, value) {\n    Object.defineProperty ? Object.defineProperty(ctx, key, {\n      enumerable: false,\n      configurable: false,\n      writable: false,\n      value: value\n    }) : (ctx[key] = value)\n    return value\n  }\n\n  return $void\n}\n","'use strict'\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var $export = $void.export\n  var sharedSymbolOf = $void.sharedSymbolOf\n\n  // an empty symbol to be resolve to null.\n  $export($, '', null)\n\n  // special empty symbols\n  $export($, '*', null)\n  $export($, '...', null)\n\n  // constant values\n  $export($, 'null', null)\n  $export($, 'true', true)\n  $export($, 'false', false)\n\n  // punctuation pure Symbols\n  $export($, '\\\\', sharedSymbolOf('\\\\'))\n  $export($, '(', sharedSymbolOf('('))\n  $export($, ')', sharedSymbolOf(')'))\n  $export($, ',', sharedSymbolOf(','))\n  $export($, ';', sharedSymbolOf(';'))\n  $export($, '.', sharedSymbolOf('.'))\n  $export($, '@', sharedSymbolOf('@'))\n  $export($, ':', sharedSymbolOf(':'))\n  $export($, '$', sharedSymbolOf('$'))\n  $export($, '#', sharedSymbolOf('#'))\n  $export($, '[', sharedSymbolOf('['))\n  $export($, ']', sharedSymbolOf(']'))\n  $export($, '{', sharedSymbolOf('{'))\n  $export($, '}', sharedSymbolOf('}'))\n\n  // logical operators\n  $export($, '&&', sharedSymbolOf('&&'))\n  $export($, 'and', sharedSymbolOf('and'))\n  $export($, '||', sharedSymbolOf('||'))\n  $export($, 'or', sharedSymbolOf('or'))\n\n  // other pure symbols\n  $export($, 'else', sharedSymbolOf('else'))\n\n  // global enum value.\n  $export($, sharedSymbolOf('descending').key, 1)\n  $export($, sharedSymbolOf('equivalent').key, 0)\n  $export($, sharedSymbolOf('ascending').key, -1)\n\n  // ensure type name symbols are shared.\n  var typeNames = [\n    'type',\n    'bool', 'string', 'number', 'date', 'range',\n    'symbol', 'tuple',\n    'operator', 'lambda', 'function',\n    'array', 'iterator', 'promise', 'object', 'class'\n  ]\n  for (var i = 0; i < typeNames.length; i++) {\n    sharedSymbolOf(typeNames[i])\n  }\n}\n","'use strict'\n\nmodule.exports = function iterate ($void) {\n  var $ = $void.$\n  var Type = $.iterator\n  var $Array = $.array\n  var Tuple$ = $void.Tuple\n  var Symbol$ = $void.Symbol\n  var Iterator$ = $void.Iterator\n  var numberOf = $.number.of\n  var link = $void.link\n  var thisCall = $void.thisCall\n  var boolValueOf = $void.boolValueOf\n  var isApplicable = $void.isApplicable\n  var protoValueOf = $void.protoValueOf\n  var sharedSymbolOf = $void.sharedSymbolOf\n\n  // try to get an iterator function for an entity\n  var iterateOf = $void.iterateOf = function (source) {\n    return isApplicable(source) ? source\n      : isApplicable(source = thisCall(source, 'iterate')) ? source : null\n  }\n\n  // create an empty iterator.\n  var empty = link(Type, 'empty', new Iterator$(null))\n\n  // create an iterator object for an iterable entity.\n  link(Type, 'of', function (iterable) {\n    if (iterable instanceof Iterator$) {\n      return iterable\n    }\n    var next = iterateOf(iterable)\n    return next ? new Iterator$(next) : empty\n  }, true)\n\n  // create an iterator object for an unsafe iterable entity.\n  var unsafe = function (next) {\n    var last\n    return function (inSitu) {\n      if (typeof last !== 'undefined' && boolValueOf(inSitu)) {\n        return last\n      }\n      if (next === null) {\n        return null\n      }\n      var current = next()\n      return current === last || Object.is(current, last)\n        ? (next = null) // each iteration must vary.\n        : (last = current)\n    }\n  }\n  link(Type, 'of-unsafe', function (iterable) {\n    var next = iterateOf(iterable)\n    return next ? new Iterator$(unsafe(next)) : empty\n  }, true)\n\n  var proto = Type.proto\n  // an iterator object is also iterable.\n  link(proto, 'iterate', function () {\n    return this.next\n  })\n\n  // an iterator object is also iterable.\n  link(proto, 'skip', function (count) {\n    count >>= 0\n    if (!this.next || count <= 0) {\n      return this\n    }\n\n    var current\n    var next = this.next\n    this.next = function (inSitu) {\n      if (typeof current !== 'undefined' &&\n        typeof inSitu !== 'undefined' && boolValueOf(inSitu)) {\n        return current\n      }\n      var value\n      while (count > 0) {\n        value = next(); count--\n        if (typeof value === 'undefined' || value === null) {\n          next = null; break\n        }\n      }\n      value = next && next()\n      return typeof value === 'undefined' || value === null ? null\n        : (current = value)\n    }\n    return this\n  })\n\n  // an iterator object is also iterable.\n  link(proto, 'keep', function (count) {\n    if (!this.next) {\n      return this\n    }\n    count >>= 0\n    if (count <= 0) {\n      this.next = null\n      return this\n    }\n    var current\n    var next = this.next\n    this.next = function (inSitu) {\n      if (typeof current !== 'undefined' &&\n        typeof inSitu !== 'undefined' && boolValueOf(inSitu)) {\n        return current\n      }\n      if (count <= 0) {\n        return null\n      }\n      var value = next()\n      if (--count <= 0) {\n        next = null\n      }\n      return typeof value === 'undefined' || value === null ? null\n        : (current = value)\n    }\n    return this\n  })\n\n  // select a subset of all items.\n  link(proto, 'select', function (filter) {\n    if (!this.next) {\n      return this\n    }\n    if (!isApplicable(filter)) {\n      if (!boolValueOf(filter)) {\n        this.next = null\n      }\n      return this\n    }\n    var current\n    var next = this.next\n    this.next = function (inSitu) {\n      if (typeof current !== 'undefined' &&\n        typeof inSitu !== 'undefined' && boolValueOf(inSitu)) {\n        return current\n      }\n      var value = next && next()\n      while (typeof value !== 'undefined' && value !== null) {\n        if (boolValueOf(Array.isArray(value)\n          ? filter.apply(this, value) : filter.call(this, value))\n        ) {\n          return (current = value)\n        }\n        value = next()\n      }\n      return (next = null)\n    }\n    return this\n  })\n\n  // map each item to a new value.\n  link(proto, 'map', function (converter) {\n    if (!this.next) {\n      return this\n    }\n    var convert = isApplicable(converter) ? converter : function () {\n      return converter\n    }\n    var current\n    var next = this.next\n    this.next = function (inSitu) {\n      if (typeof current !== 'undefined' &&\n        typeof inSitu !== 'undefined' && boolValueOf(inSitu)) {\n        return current\n      }\n      var value = next && next()\n      if (typeof value === 'undefined' || value === null) {\n        return (next = null)\n      }\n      current = Array.isArray(value)\n        ? convert.apply(this, value) : convert.call(this, value)\n      return Array.isArray(current) ? current : (current = [current])\n    }\n    return this\n  })\n\n  // accumulate all items to produce a value.\n  link(proto, 'reduce', function (value, reducer) {\n    if (!isApplicable(reducer)) {\n      if (!isApplicable(value)) {\n        return typeof value === 'undefined'\n          ? count.call(this)\n          : finish.call(this, value)\n      } else {\n        reducer = value\n        value = null\n      }\n    }\n    var args\n    var item = this.next && this.next()\n    while (typeof item !== 'undefined' && item !== null) {\n      if (Array.isArray(item)) {\n        args = item.slice()\n        args.unshift(value)\n      } else {\n        args = [value, item]\n      }\n      value = reducer.apply(this, args)\n      item = this.next()\n    }\n    this.next = null\n    return value\n  })\n\n  // count the number of iterations.\n  var count = link(proto, ['count', 'for-each'], function (filter) {\n    var counter = 0\n    var value = this.next && this.next()\n    if (isApplicable(filter)) {\n      while (typeof value !== 'undefined' && value != null) {\n        (boolValueOf(Array.isArray(value)\n          ? filter.apply(this, value) : filter.call(this, value))\n        ) && counter++\n        value = this.next()\n      }\n    } else {\n      while (typeof value !== 'undefined' && value != null) {\n        counter++\n        value = this.next()\n      }\n    }\n    this.next = null\n    return counter\n  })\n\n  // sum the values of all iterations.\n  link(proto, 'sum', function (base) {\n    var sum = typeof base === 'number' ? base : numberOf(base)\n    var value = this.next && this.next()\n    while (typeof value !== 'undefined' && value != null) {\n      if (Array.isArray(value)) {\n        value = value.length > 0 ? value[0] : 0\n      }\n      sum += typeof value === 'number' ? value : numberOf(value)\n      value = this.next()\n    }\n    this.next = null\n    return sum\n  })\n\n  // calculate the average value of all iterations.\n  link(proto, 'average', function (defaultValue) {\n    var counter = 0\n    var sum = 0\n    var value = this.next && this.next()\n    while (typeof value !== 'undefined' && value != null) {\n      counter++\n      if (Array.isArray(value)) {\n        value = value.length > 0 ? value[0] : 0\n      }\n      sum += typeof value === 'number' ? value : numberOf(value)\n      value = this.next()\n    }\n    this.next = null\n    return (counter > 0) && !isNaN(sum /= counter) ? sum\n      : typeof defaultValue === 'number' ? defaultValue : 0\n  })\n\n  // find the maximum value of all iterations.\n  link(proto, 'max', function (filter) {\n    var max = null\n    var value = this.next && this.next()\n    if (isApplicable(filter)) {\n      while (typeof value !== 'undefined' && value != null) {\n        if (Array.isArray(value) && value.length > 0) {\n          value = value[0]\n          if (filter.call(this, value) && (max === null ||\n            thisCall(value, 'compare', max) > 0)) {\n            max = value\n          }\n        }\n        value = this.next()\n      }\n    } else {\n      while (typeof value !== 'undefined' && value != null) {\n        if (Array.isArray(value) && value.length > 0) {\n          value = value[0]\n          if (max === null || thisCall(value, 'compare', max) > 0) {\n            max = value\n          }\n        }\n        value = this.next()\n      }\n    }\n    this.next = null\n    return max\n  })\n\n  // find the minimum value of all iterations.\n  link(proto, 'min', function (filter) {\n    var min = null\n    var value = this.next && this.next()\n    if (isApplicable(filter)) {\n      while (typeof value !== 'undefined' && value != null) {\n        if (Array.isArray(value) && value.length > 0) {\n          value = value[0]\n          if (filter.call(this, value) && (min === null ||\n            thisCall(value, 'compare', min) < 0)) {\n            min = value\n          }\n        }\n        value = this.next()\n      }\n    } else {\n      while (typeof value !== 'undefined' && value != null) {\n        if (Array.isArray(value) && value.length > 0) {\n          value = value[0]\n          if (min === null || thisCall(value, 'compare', min) < 0) {\n            min = value\n          }\n        }\n        value = this.next()\n      }\n    }\n    this.next = null\n    return min\n  })\n\n  // determine emptiness by its inner iterator function.\n  link(proto, 'is-empty', function () {\n    return !this.next\n  })\n  link(proto, 'not-empty', function () {\n    return !!this.next\n  })\n\n  // concatenate the values of all iterations.\n  link(proto, 'join', function (separator) {\n    var str = ''\n    if (typeof separator !== 'string') {\n      separator = ' '\n    }\n    var value = this.next && this.next()\n    while (typeof value !== 'undefined' && value != null) {\n      if (Array.isArray(value)) {\n        value = value.length > 0 ? value[0] : ''\n      }\n      if (str.length > 0) { str += separator }\n      str += typeof value === 'string' ? value : thisCall(value, 'to-string')\n      value = this.next()\n    }\n    this.next = null\n    return str\n  })\n\n  // collect the main value of all iterations.\n  link(proto, 'collect', function (list) {\n    if (!Array.isArray(list)) {\n      list = []\n    }\n    var value = this.next && this.next()\n    while (typeof value !== 'undefined' && value != null) {\n      list.push(!Array.isArray(value) ? value\n        : value = value.length > 0 ? value[0] : null)\n      value = this.next()\n    }\n    this.next = null\n    return list\n  })\n\n  // finish all iterations.\n  var finish = link(proto, 'finish', function (nil) {\n    nil = [nil]\n    var value = this.next && this.next()\n    while (typeof value !== 'undefined' && value != null) {\n      nil = value\n      value = this.next()\n    }\n    this.next = null\n    return !Array.isArray(nil) ? nil\n      : nil.length > 0 ? nil[0] : null\n  })\n\n  // all interators will be encoded to an empty iterator.\n  var arrayProto = $Array.proto\n  var symbolOf = sharedSymbolOf('of')\n  var symbolIterator = sharedSymbolOf('iterator')\n  var emptyCode = new Tuple$([symbolIterator, sharedSymbolOf('empty')])\n  var toCode = link(proto, 'to-code', function () {\n    if (!this.next) {\n      return emptyCode\n    }\n    var list = this.collect()\n    this.next = arrayProto.iterate.call(list)\n    return new Tuple$([\n      symbolIterator, symbolOf, arrayProto['to-code'].call(list)\n    ])\n  })\n\n  // Description\n  var tupleToString = $.tuple.proto['to-string']\n  var emptyCodeStr = tupleToString.call(emptyCode)\n  link(proto, 'to-string', function (separator) {\n    return !this.next ? emptyCodeStr\n      : tupleToString.call(toCode.call(this))\n  })\n\n  // Indexer\n  var indexer = link(proto, ':', function (index) {\n    return typeof index === 'string' ? protoValueOf(this, proto, index)\n      : index instanceof Symbol$ ? protoValueOf(this, proto, index.key) : null\n  })\n  indexer.get = function (key) {\n    return proto[key]\n  }\n\n  // export type indexer.\n  link(Type, 'indexer', indexer)\n}\n","\n'use strict'\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var Type = $.lambda\n  var $Tuple = $.tuple\n  var link = $void.link\n  var bindThis = $void.bindThis\n  var constambda = $void.constambda\n  var prepareOperation = $void.prepareOperation\n  var prepareApplicable = $void.prepareApplicable\n\n  // the noop lambda\n  var noop = link(Type, 'noop', $void.lambda(function () {\n    return null\n  }, $Tuple.lambda), true)\n\n  link(Type, 'static', $void.constambda(function () {\n    return null\n  }, $Tuple.stambda), true)\n\n  var proto = Type.proto\n  link(proto, 'is-static', function () {\n    return this.static === true || this.const === true\n  })\n\n  link(proto, 'is-const', function () {\n    return this.const === true\n  })\n\n  // bind a lambda to a fixed subject.\n  link(proto, 'bind', function (arg) {\n    if (typeof this.bound === 'function') {\n      return this\n    }\n    if (typeof arg === 'undefined') {\n      arg = null\n    }\n    return this.static !== true || typeof this.this === 'undefined'\n      ? bindThis(arg, this)\n      : constambda(this.bind(null, arg), this.code)\n  })\n\n  // implement common operation features.\n  prepareOperation(Type, noop, $Tuple.lambda)\n\n  // implement applicable operation features.\n  prepareApplicable(Type, $Tuple.lambda)\n}\n","'use strict'\n\nmodule.exports = function ($void) {\n  var Null = $void.null\n  var link = $void.link\n  var Symbol$ = $void.Symbol\n\n  // Fundamental Entity Relationships: Identity, Equivalence and Ordering\n  // Identity, Equivalence and Ordering logics must be symmetrical.\n  // An identity must be equivalent with itself.\n  // Ordering Equal must comply with Equivalence Equal.\n\n  link(Null, [\n    // Identity: to recognize two different entities.\n    'is', '===',\n    // Equivalence: to test if two entities are equivalent in effect.\n    // Equivalence logic should be implemented symmetrically.\n    // So it's different with the behaviour of NaN in JS, since an identity must be\n    // equivalent in effect with itself, or as an identity's behaviour cannot be\n    // defined by any property that's unrelevant with its effect to its environment.\n    'equals', '=='\n  ], function (another) {\n    return Object.is(typeof this === 'undefined' ? null : this,\n      typeof another === 'undefined' ? null : another)\n  })\n  link(Null, [\n    // the negative method of Identity test.\n    'is-not', '!==',\n    // the negative method of Equivalence test.\n    'not-equals', '!='\n  ], function (another) {\n    return !Object.is(typeof this === 'undefined' ? null : this,\n      typeof another === 'undefined' ? null : another)\n  })\n\n  // Ordering: general comparison\n  //     0 - identical\n  //     1 - from this to another is descending.\n  //    -1 - from this to another is ascending.\n  //  null - not-sortable\n  link(Null, 'compare', function (another) {\n    return Object.is(this, typeof another === 'undefined' ? null : another)\n      ? 0 : null\n  })\n\n  // Emptiness: null, type.proto and all protos are empty.\n  link(Null, 'is-empty', function () {\n    return true\n  })\n  link(Null, 'not-empty', function () {\n    return false\n  })\n\n  // Type Verification: to test if an entity is an instance of a type.\n  link(Null, ['is-a', 'is-an'], function (type) {\n    // null is null and null is a null.\n    // type.proto is not null but is a null.\n    return typeof type === 'undefined' || type === null\n  })\n  link(Null, ['is-not-a', 'is-not-an'], function (type) {\n    return typeof type !== 'undefined' && type !== null\n  })\n\n  // Encoding\n  link(Null, 'to-code', function () {\n    return this\n  })\n\n  // Representation (static values) or Description (non-static values)\n  link(Null, 'to-string', function () {\n    return 'null'\n  })\n\n  // Indexer\n  link(Null, ':', function (index) {\n    return typeof index === 'string' ? Null[index]\n      : index instanceof Symbol$ ? Null[index.key] : null\n  })\n}\n","'use strict'\n\nfunction createValueOf ($void, parse, parseInteger) {\n  return function (input, defaultValue) {\n    var value\n    if (typeof input === 'string') {\n      value = input.startsWith('0x') || input.startsWith('0b') ? parseInteger(input) : parse(input)\n    } else if (typeof input === 'boolean') {\n      value = input ? 1 : 0\n    } else if (input instanceof Date) {\n      value = input.getTime()\n    } else if (typeof input === 'undefined' || input === null) {\n      value = 0\n    } else if (typeof input === 'number') {\n      value = input\n    } else {\n      value = NaN\n    }\n    return isNaN(value) && typeof defaultValue === 'number' ? defaultValue : value\n  }\n}\n\nfunction safeIntValueOf (number) {\n  var intValue = Number.isSafeInteger(number) ? number\n    : isNaN(number) ? 0\n      : number >= Number.MAX_SAFE_INTEGER ? Number.MAX_SAFE_INTEGER\n        : number <= Number.MIN_SAFE_INTEGER ? Number.MIN_SAFE_INTEGER\n          : Math.trunc(number)\n  return intValue === 0 ? 0 : intValue\n}\n\nfunction createIntValueOf ($void, parse) {\n  return function (input, defaultValue) {\n    var result\n    if (typeof input === 'string') {\n      result = parse(input)\n    } else if (typeof input === 'number') {\n      result = input === 0 ? 0 : Math.trunc(input)\n    } else if (typeof input === 'boolean') {\n      return input ? 1 : 0\n    }\n    return Number.isSafeInteger(result) ? result\n      : Number.isSafeInteger(defaultValue) ? defaultValue\n        : safeIntValueOf(result)\n  }\n}\n\nfunction createIntParser ($void) {\n  return function (input) {\n    var value\n    if (typeof input !== 'string') {\n      return typeof input !== 'number' ? NaN\n        : input === 0 ? 0 : isNaN(input) ? NaN\n          : (value = Math.trunc(input)) === 0 ? 0\n            : Number.isSafeInteger(value) ? value : NaN\n    }\n    var radix\n    if (input.startsWith('0x')) {\n      radix = 16\n      input = input.substring(2)\n    } else if (input.startsWith('0b')) {\n      radix = 2\n      input = input.substring(2)\n    } else if (input.length > 1 && input.startsWith('0')) {\n      radix = 8\n      input = input.substring(1)\n    } else {\n      radix = 10\n      var offset = input.indexOf('.')\n      if (offset >= 0) {\n        input = input.substr(0, offset)\n      }\n    }\n    value = parseInt(input, radix)\n    return value === 0 ? 0\n      : input.endsWith('i') ? value >> 0\n        : Number.isSafeInteger(value) ? value : NaN\n  }\n}\n\nfunction numberAnd (valueOf) {\n  return function () {\n    var result = this\n    for (var i = 0; i < arguments.length; i++) {\n      var arg = arguments[i]\n      result += typeof arg === 'number' ? arg : valueOf(arg)\n    }\n    return result\n  }\n}\n\nfunction numberSubtract (valueOf) {\n  return function () {\n    var result = this\n    for (var i = 0; i < arguments.length; i++) {\n      var arg = arguments[i]\n      result -= typeof arg === 'number' ? arg : valueOf(arg)\n    }\n    return result\n  }\n}\n\nfunction numberTimes (valueOf) {\n  return function () {\n    var result = this\n    for (var i = 0; i < arguments.length; i++) {\n      var arg = arguments[i]\n      result *= typeof arg === 'number' ? arg : valueOf(arg)\n    }\n    return result\n  }\n}\n\nfunction numberDivide (valueOf) {\n  return function () {\n    var result = this\n    for (var i = 0; i < arguments.length; i++) {\n      var arg = arguments[i]\n      result /= typeof arg === 'number' ? arg : valueOf(arg)\n    }\n    return result\n  }\n}\n\nfunction normalize (value) {\n  return value >= 0 ? Math.trunc(value) : (0x100000000 + (value >> 0))\n}\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var Type = $.number\n  var $Range = $.range\n  var link = $void.link\n  var Symbol$ = $void.Symbol\n  var copyType = $void.copyType\n  var protoValueOf = $void.protoValueOf\n\n  // the value range and constant values.\n  copyType(Type, Number, {\n    MAX_VALUE: 'max',\n    MIN_VALUE: 'smallest',\n    MAX_SAFE_INTEGER: 'max-int',\n    MIN_SAFE_INTEGER: 'min-int',\n    POSITIVE_INFINITY: 'infinite',\n    NEGATIVE_INFINITY: '-infinite'\n  })\n  link(Type, 'min', -Number.MAX_VALUE)\n\n  // support bitwise operations for 32-bit integer values.\n  link(Type, 'bits', 32)\n  var maxBits = link(Type, 'max-bits', 0x7FFFFFFF)\n  var minBits = link(Type, 'min-bits', 0x80000000 >> 0)\n\n  // The empty value\n  link(Type, 'empty', 0)\n\n  // An empty value indicating an invalid number.\n  link(Type, 'invalid', NaN)\n\n  // parse a string to its number value.\n  var regexParse = /\\s*\\(number\\s+(invalid|[-]?infinite)\\s*\\)\\s*/\n  var parse = link(Type, 'parse', function (value) {\n    if (typeof value !== 'string') {\n      return typeof value === 'number' ? value : NaN\n    }\n    var keys = value.match(regexParse)\n    switch (keys && keys.length > 1 ? keys[1] : '') {\n      case 'invalid':\n        return NaN\n      case 'infinite':\n        return Number.POSITIVE_INFINITY\n      case '-infinite':\n        return Number.NEGATIVE_INFINITY\n      default:\n        return parseFloat(value)\n    }\n  }, true)\n\n  // parse a string as an integer value.\n  var parseInteger = link(Type, 'parse-int', createIntParser($void), true)\n\n  // get a number value from the input\n  var valueOf = link(Type, 'of',\n    createValueOf($void, parse, parseInteger), true\n  )\n\n  // get an integer value from the input\n  var intOf = link(Type, 'of-int', createIntValueOf($void, parseInteger), true)\n\n  // get an signed integer value which is stable with bitwise operation.\n  link(Type, 'of-bits', function (input) {\n    return intOf(input) >> 0\n  }, true)\n\n  var proto = Type.proto\n  // test for special values\n  link(proto, 'is-valid', function () {\n    return !isNaN(this)\n  })\n  link(proto, 'is-invalid', function () {\n    return isNaN(this)\n  })\n  // test for special value ranges\n  link(proto, 'is-finite', function () {\n    return isFinite(this)\n  })\n  link(proto, 'is-infinite', function () {\n    return !isFinite(this)\n  })\n  link(proto, 'is-int', function () {\n    return Number.isSafeInteger(this) && (this !== 0 || 1 / this === Infinity)\n  })\n  link(proto, 'is-not-int', function () {\n    return !Number.isSafeInteger(this) || (this === 0 && 1 / this !== Infinity)\n  })\n  link(proto, 'is-bits', function () {\n    return Number.isSafeInteger(this) &&\n      this >= minBits && this <= maxBits &&\n      (this !== 0 || 1 / this === Infinity)\n  })\n  link(proto, 'is-not-bits', function () {\n    return !Number.isSafeInteger(this) ||\n      this < minBits || this > maxBits ||\n      (this === 0 && 1 / this !== Infinity)\n  })\n\n  // convert to special sub-types\n  link(proto, 'as-int', function () {\n    return safeIntValueOf(this)\n  })\n  link(proto, 'as-bits', function () {\n    return this >> 0\n  })\n\n  // helpers of zero-based indexing.\n  link(proto, ['th', 'st', 'nd', 'rd'], function () {\n    var index = safeIntValueOf(this)\n    return index >= 0 ? (index - 1) : index\n  })\n\n  // support basic arithmetic operations\n  link(proto, ['+', 'plus'], numberAnd(valueOf))\n  link(proto, ['-', 'minus'], numberSubtract(valueOf))\n  link(proto, ['*', 'times'], numberTimes(valueOf))\n  link(proto, ['/', 'divided-by'], numberDivide(valueOf))\n\n  // remainder / modulus\n  link(proto, '%', function (base) {\n    return typeof base === 'undefined' ? this\n      : isNaN(base) || typeof base !== 'number' ? NaN\n        : isFinite(base) ? this % valueOf(base) : this\n  })\n\n  // bitwise operations\n  link(proto, '&', function (value) {\n    return this & value\n  })\n  link(proto, '|', function (value) {\n    return this | value\n  })\n  link(proto, '^', function (value) {\n    return this ^ value\n  })\n  link(proto, '<<', function (offset) {\n    offset >>= 0\n    return offset <= 0 ? this << 0\n      : offset >= 32 ? 0 : this << offset\n  })\n  // signed right-shift.\n  link(proto, '>>', function (offset) {\n    offset >>= 0\n    return offset <= 0 ? this >> 0\n      : offset >= 32 ? (this >> 0) >= 0 ? 0 : -1\n        : this >> offset\n  })\n  // zero-based right shift.\n  link(proto, '>>>', function (offset) {\n    offset >>= 0\n    return offset <= 0 ? this >> 0\n      : offset >= 32 ? 0 : this >>> offset\n  })\n\n  // support ordering logic - comparable\n  // For incomparable entities, comparison result is consistent with the Equivalence.\n  // incomparable state is indicated by a null and is taken as nonequivalent.\n  var compare = link(proto, 'compare', function (another) {\n    return typeof another !== 'number' ? null\n      : this === another ? 0 // two same valid values.\n        : !isNaN(this) && !isNaN(another)\n          ? this > another ? 1 : -1\n          : isNaN(this) && isNaN(another)\n            ? 0 // NaN is equivalent with itself.\n            : null // NaN is not comparable with a real number.\n  })\n\n  // comparing operators for instance values\n  link(proto, '>', function (another) {\n    var order = compare.call(this, another)\n    return order !== null ? order > 0 : null\n  })\n  link(proto, '>=', function (another) {\n    var order = compare.call(this, another)\n    return order !== null ? order >= 0 : null\n  })\n  link(proto, '<', function (another) {\n    var order = compare.call(this, another)\n    return order !== null ? order < 0 : null\n  })\n  link(proto, '<=', function (another) {\n    var order = compare.call(this, another)\n    return order !== null ? order <= 0 : null\n  })\n\n  // override equivalence logic since 0 != -0 by identity-base test.\n  link(proto, ['equals', '=='], function (another) {\n    return typeof another === 'number' && (\n      this === another || (isNaN(this) && isNaN(another))\n    )\n  })\n  link(proto, ['not-equals', '!='], function (another) {\n    return typeof another !== 'number' || (\n      this !== another && !(isNaN(this) && isNaN(another))\n    )\n  })\n\n  // support common math operations\n  link(proto, 'ceil', function () {\n    return Math.ceil(this)\n  })\n  link(proto, 'floor', function () {\n    return Math.floor(this)\n  })\n  link(proto, 'round', function () {\n    return Math.round(this)\n  })\n  link(proto, 'trunc', function () {\n    return Math.trunc(this)\n  })\n\n  // O and NaN are defined as empty.\n  link(proto, 'is-empty', function () {\n    return this === 0 || isNaN(this)\n  })\n  link(proto, 'not-empty', function () {\n    return this !== 0 && !isNaN(this)\n  })\n\n  // Representation & Description\n  link(proto, 'to-string', function (format) {\n    if (isNaN(this)) {\n      return '(number invalid)'\n    } else if (this === Number.POSITIVE_INFINITY) {\n      return '(number infinite)'\n    } else if (this === Number.NEGATIVE_INFINITY) {\n      return '(number -infinite)'\n    } else if (!format) {\n      return Object.is(this, -0) ? '-0' : this.toString()\n    }\n\n    switch (format) {\n      case 'H':\n      case 'HEX':\n        return normalize(this).toString(16)\n      case 'h':\n      case 'hex':\n        return '0x' + normalize(this).toString(16)\n      case 'O':\n      case 'OCT':\n        return normalize(this).toString(8)\n      case 'o':\n      case 'oct':\n        return '0' + normalize(this).toString(8)\n      case 'B':\n      case 'BIN':\n        return normalize(this).toString(2)\n      case 'b':\n      case 'bin':\n        return '0b' + normalize(this).toString(2)\n      default:\n        return this.toString()\n    }\n  })\n\n  // Indexer\n  var indexer = link(proto, ':', function (index, value) {\n    return typeof index === 'string' ? protoValueOf(this, proto, index)\n      : typeof index === 'number' ? $Range.of(this, index, value)\n        : index instanceof Symbol$ ? protoValueOf(this, proto, index.key) : null\n  })\n  indexer.get = function (key) {\n    return proto[key]\n  }\n\n  // export type indexer.\n  link(Type, 'indexer', indexer)\n}\n","'use strict'\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var Type = $.object\n  var $Symbol = $.symbol\n  var Tuple$ = $void.Tuple\n  var link = $void.link\n  var Symbol$ = $void.Symbol\n  var Object$ = $void.Object\n  var isObject = $void.isObject\n  var thisCall = $void.thisCall\n  var ClassType$ = $void.ClassType\n  var ownsProperty = $void.ownsProperty\n  var protoValueOf = $void.protoValueOf\n  var encodeFieldName = $void.encodeFieldName\n  var EncodingContext$ = $void.EncodingContext\n\n  // create an empty object.\n  var createObject = link(Type, 'empty', Object.create.bind(Object, Type.proto))\n\n  // create a new object and copy fields from source objects.\n  link(Type, 'of', function () {\n    var len = arguments.length\n    if (len < 1) {\n      return createObject()\n    }\n    var args = [createObject()]\n    for (var i = 0; i < len; i++) {\n      isObject(arguments[i]) && args.push(arguments[i])\n    }\n    return Object.assign.apply(Object, args)\n  }, true)\n\n  // JS-InterOp: create a generic object and copy fields from source objects.\n  link(Type, 'of-generic', function () {\n    if (arguments.length < 1) {\n      return {}\n    }\n    // using native Object.assign; not filtering source types.\n    var args = Array.prototype.slice.call(arguments)\n    args.unshift({})\n    return Object.assign.apply(Object, args)\n  }, true)\n\n  // JS-InterOp: test if an object is a generic object.\n  link(Type, 'is-generic', function (obj) {\n    return isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype\n  }, true)\n  link(Type, 'not-generic', function (obj) {\n    return !isObject(obj) || Object.getPrototypeOf(obj) !== Object.prototype\n  }, true)\n\n  // JS-InterOp:  create a generic object and copy fields from source objects.\n  link(Type, 'of-plain', function () {\n    if (arguments.length < 1) {\n      return Object.create(null)\n    }\n    // using native Object.assign, not filtering source types.\n    var args = Array.prototype.slice.call(arguments)\n    args.unshift(Object.create(null))\n    return Object.assign.apply(Object, args)\n  }, true)\n\n  // JS-InterOp: test if an object is a generic plain object.\n  link(Type, 'is-plain', function (obj) {\n    return isObject(obj) && Object.getPrototypeOf(obj) === null\n  }, true)\n  link(Type, 'not-plain', function (obj) {\n    return !isObject(obj) || Object.getPrototypeOf(obj) !== null\n  }, true)\n\n  // copy fields from source objects to the target object\n  link(Type, 'assign', function (target) {\n    if (isObject(target)) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i]\n        if (source instanceof Object$) {\n          Object.assign(target, source)\n        }\n      }\n      return target\n    }\n    return null\n  }, true)\n\n  // get the value of a field.\n  link(Type, 'get', function (obj, name, value) {\n    if (name instanceof Symbol$) {\n      name = name.key\n    } else if (typeof name !== 'string') {\n      return value\n    }\n    var pValue\n    return !isObject(obj) ? value\n      : ownsProperty(obj, name)\n        ? typeof obj[name] === 'undefined' ? value : obj[name]\n        : typeof (pValue = protoValueOf(obj, obj, name)) === 'undefined'\n          ? value : pValue\n  }, true)\n  // set the value of a field.\n  link(Type, 'set', function (obj, name, value) {\n    if (name instanceof Symbol$) {\n      name = name.key\n    } else if (typeof name !== 'string') {\n      return null\n    }\n    return !isObject(obj) ? null\n      : (obj[name] = (typeof value !== 'undefined' ? value : null))\n  }, true)\n  // remove a field.\n  link(Type, 'reset', function (obj, name, more) {\n    if (!isObject(obj)) {\n      return 0\n    }\n    if (typeof more === 'undefined') {\n      if (name instanceof Symbol$) {\n        name = name.key\n      }\n      return typeof name !== 'string' ? 0\n        : delete obj[name] ? 1 : 0\n    }\n    var i = 1\n    var counter = 0\n    do {\n      if (typeof name === 'string') {\n        (delete obj[name]) && counter++\n      } else if (name instanceof Symbol$) {\n        (delete obj[name.key]) && counter++\n      }\n      name = arguments[++i]\n    } while (i < arguments.length)\n    return counter\n  }, true)\n\n  // make a copy with selected or all fields.\n  link(Type, 'copy', function (src, fields) {\n    if (!isObject(src)) {\n      return null\n    }\n    var obj = Object.create(src.type.proto)\n    var names = arguments.length > 1\n      ? Array.prototype.slice.call(arguments, 1)\n      : Object.getOwnPropertyNames(src)\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i]\n      if (name instanceof Symbol$) {\n        name = name.key\n      }\n      if (typeof name === 'string') {\n        obj[name] = src[name]\n      }\n    }\n    var activator = src.type.proto.activator\n    if (typeof activator === 'function') {\n      activator.call(obj, obj)\n    }\n    return obj\n  }, true)\n  // remove given or all fields.\n  link(Type, 'clear', function (obj, fields) {\n    if (!isObject(obj)) {\n      return null\n    }\n    var names = arguments.length > 1\n      ? Array.prototype.slice.call(arguments, 1)\n      : Object.getOwnPropertyNames(obj)\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i]\n      if (typeof name === 'string') {\n        delete obj[name]\n      } else if (name instanceof Symbol$) {\n        delete obj[name.key]\n      }\n    }\n    return obj\n  }, true)\n  // remove one or more values to create a new object.\n  link(Type, 'remove', function (src, fields) {\n    if (!isObject(src)) {\n      return null\n    }\n    var obj = Object.assign(Object.create(src.type.proto), src)\n    var names = arguments.length <= 1 ? []\n      : Array.prototype.slice.call(arguments, 1)\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i]\n      if (typeof name === 'string') {\n        delete obj[name]\n      } else if (name instanceof Symbol$) {\n        delete obj[name.key]\n      } else if (name instanceof Object$) {\n        fields = Object.getOwnPropertyNames(name)\n        for (var j = 0; j < fields.length; j++) {\n          delete obj[fields[j]]\n        }\n      }\n    }\n    var activator = src.type.proto.activator\n    if (typeof activator === 'function') {\n      activator.call(obj, obj)\n    }\n    return obj\n  }, true)\n\n  // check the existence of a property\n  link(Type, 'has', function (obj, name) {\n    if (typeof name !== 'string') {\n      if (name instanceof Symbol$) {\n        name = name.key\n      } else {\n        return false\n      }\n    }\n    return isObject(obj) && typeof obj[name] !== 'undefined'\n  }, true)\n  // check the existence of a field\n  link(Type, 'owns', function (obj, name) {\n    if (typeof name !== 'string') {\n      if (name instanceof Symbol$) {\n        name = name.key\n      } else {\n        return false\n      }\n    }\n    return isObject(obj) && ownsProperty(obj, name)\n  }, true)\n  // retrieve field names.\n  link(Type, 'fields-of', function (obj) {\n    return isObject(obj) ? Object.getOwnPropertyNames(obj) : []\n  }, true)\n\n  // Mutability\n  link(Type, 'seal', function (obj) {\n    return typeof obj === 'undefined' ? Type // operating on the type\n      : isObject(obj) || Array.isArray(obj) ? Object.freeze(obj) : null\n  })\n  link(Type, 'is-sealed', function (obj) {\n    return typeof obj === 'undefined' ? true // asking the type\n      : isObject(obj) || Array.isArray(obj) ? Object.isFrozen(obj) : false\n  })\n\n  var proto = Type.proto\n  // generate an iterator function to traverse all fields as [name, value].\n  link(proto, 'iterate', function () {\n    var fields = Object.getOwnPropertyNames(this)\n    var obj = this\n    var current = null\n    var next = 0\n    var field\n    return function (inSitu) {\n      return current !== null && inSitu === true ? current // cached current value\n        : next >= fields.length ? null // no more\n          : (current = [(field = fields[next++]), obj[field]])\n    }\n  })\n\n  // Type Verification\n  link(proto, ['is-a', 'is-an'], function (t) {\n    return t === Type\n  })\n  link(proto, ['is-not-a', 'is-not-an'], function (t) {\n    return t !== Type\n  })\n\n  // default object emptiness logic\n  link(proto, 'is-empty', function () {\n    return !(Object.getOwnPropertyNames(this).length > 0)\n  })\n  link(proto, 'not-empty', function () {\n    return Object.getOwnPropertyNames(this).length > 0\n  })\n\n  // Encoding\n  // encoding logic for all object instances.\n  var typeOf = $.type.of\n  var toCode = link(proto, 'to-code', function (ctx) {\n    if (ctx instanceof EncodingContext$) {\n      var sym = ctx.begin(this)\n      if (sym) { return sym }\n    } else {\n      ctx = new EncodingContext$(this)\n    }\n    var props = Object.getOwnPropertyNames(this)\n    var code = [$Symbol.literal]\n    for (var i = 0; i < props.length; i++) {\n      var name = props[i]\n      code.push(encodeFieldName(name), $Symbol.pairing, ctx.encode(this[name]))\n    }\n    if (code.length < 2) {\n      code.push($Symbol.pairing) // (@:) for empty object\n    }\n    var type = this.type instanceof ClassType$ ? this.type : typeOf(this)\n    return ctx.end(this, type, new Tuple$(code))\n  })\n\n  // Description\n  link(proto, 'to-string', function () {\n    return thisCall(toCode.call(this), 'to-string')\n  })\n\n  // Indexer:\n  var indexer = link(proto, ':', function (index, value) {\n    if (typeof index !== 'string') {\n      if (index instanceof Symbol$) {\n        index = index.key // use the key of a symbol\n      } else {\n        return null // unsupported property key.\n      }\n    }\n    return typeof value === 'undefined'\n      ? typeof proto[index] === 'undefined' || index === 'type'\n        ? this[index] : protoValueOf(this, proto, index) // getting\n      : (this[index] = value) // setting\n  })\n  indexer.get = function (key) {\n    return typeof proto[key] === 'undefined' || key === 'type'\n      ? this[key] : proto[key] // getting\n  }\n\n  // export type indexer.\n  link(Type, 'indexer', indexer)\n}\n","\n'use strict'\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var Type = $.operator\n  var $Tuple = $.tuple\n  var link = $void.link\n  var prepareOperation = $void.prepareOperation\n\n  // the noop operator\n  var noop = link(Type, 'noop', $void.operator(function () {\n    return null\n  }, $Tuple.operator), true)\n\n  // implement common operation features.\n  prepareOperation(Type, noop, $Tuple.operator)\n}\n","'use strict'\n\nfunction ignoreUnhandledRejectionsBy (filter) {\n  if (typeof window !== 'undefined') {\n    window.addEventListener('unhandledrejection', function (event) {\n      var detail = event.promise ? event\n        : event.detail // for bluebird polyfill.\n      if (detail.promise && filter(detail.promise, detail.reason)) {\n        event.preventDefault()\n      }\n    })\n  } else if (typeof process !== 'undefined') {\n    process.on('unhandledRejection', function (reason, promise) {\n      filter(promise, reason)\n    })\n  }\n}\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var Type = $.promise\n  var $Tuple = $.tuple\n  var $Object = $.object\n  var $Symbol = $.symbol\n  var Symbol$ = $void.Symbol\n  var Promise$ = $void.Promise\n  var link = $void.link\n  var $export = $void.export\n  var isApplicable = $void.isApplicable\n  var protoValueOf = $void.protoValueOf\n  var sharedSymbolOf = $void.sharedSymbolOf\n\n  function hasExcuse (excuse) {\n    return typeof excuse !== 'undefined' && excuse !== null\n  }\n\n  // use true to make sure it's not a boolean false by default.\n  var NoExcuse = true\n  function safeExcuse (excuse, waiting) {\n    return hasExcuse(excuse) ? excuse\n      : waiting && hasExcuse(waiting.excuse) ? waiting.excuse : NoExcuse\n  }\n\n  function assemble (promise, cancel) {\n    if (promise.excusable !== true) {\n      promise.excusable = true\n    }\n    if (isApplicable(cancel)) {\n      promise.$cancel = cancel\n    }\n    return promise\n  }\n\n  function promiseOfAsync (async) {\n    var cancel\n    var promise = new Promise$(function (resolve, reject) {\n      cancel = async(Object.freeze($Object.of({\n        resolve: resolve,\n        reject: reject\n      })))\n    })\n    return assemble(promise, cancel)\n  }\n\n  function promiseOfExecutor (executor) {\n    var cancel\n    var promise = new Promise$(function (resolve, reject) {\n      cancel = executor(resolve, reject)\n    })\n    return assemble(promise, cancel)\n  }\n\n  function resolvedTo (next, result) {\n    return next(Object.freeze($Object.of({\n      result: result\n    })))\n  }\n\n  function rejectedTo (next, excuse) {\n    return next(Object.freeze($Object.of({\n      excuse: safeExcuse(excuse)\n    })))\n  }\n\n  function staticPromiseOf (result) {\n    var value\n    return assemble(!Array.isArray(result)\n      // intercept a non-array value as an excuse. Otherwise,\n      ? (value = safeExcuse(result)) === NoExcuse ? nothing\n        : Promise$.reject(value)\n      // reject if any excuse exists. Otherwise,\n      : hasExcuse((value = result[1])) ? Promise$.reject(value)\n        // resolve even the final result value is null.\n        : ((value = result[0]) === undefined || value === null) ? empty\n          : Promise$.resolve(value)\n    )\n  }\n\n  function makePromise (promising, isExecutor) {\n    return promising instanceof Promise$ ? assemble(promising)\n      : !isApplicable(promising) ? staticPromiseOf(promising)\n        : isExecutor ? promiseOfExecutor(promising)\n          : promiseOfAsync(promising)\n  }\n\n  function wrapStepResult (result, waiting) {\n    return function (resolve, reject) {\n      // any non-array result will be intercepted as an excuse\n      !Array.isArray(result) ? reject(safeExcuse(result, waiting))\n        // finally reject if any excuse exists. Otherwise,\n        : hasExcuse(result[1]) ? reject(result[1])\n          // resolve even the final result value is null.\n          : resolve(result[0] === undefined ? null : result[0])\n    }\n  }\n\n  function rejectWith (safeExcuse) {\n    return function (resolve, reject) {\n      reject(safeExcuse)\n    }\n  }\n\n  function wrap (step) {\n    return isApplicable(step) ? function (waiting) {\n      // let a step function to decide if it forgives an existing excuse.\n      var result = step.apply(null, arguments)\n      return result instanceof Promise$ // continue and\n        ? result.then.bind(result) // forward final promise's result.\n        : isApplicable(result) // continue too, and\n          // generate a final promise and forward its result.\n          ? (result = makePromise(result)).then.bind(result)\n          // other value will be intercepted as a sync step result.\n          : wrapStepResult(result, waiting)\n    } : function (waiting) {\n      // any value other than a promise or an function will be intercepted as\n      // a sync step result.\n      return waiting && hasExcuse(waiting.excuse)\n        ? rejectWith(waiting.excuse)\n        : wrapStepResult(step)\n    }\n  }\n\n  function awaitFor (promise, next) {\n    return function (resolve, reject) {\n      promise.then(function (result) {\n        resolvedTo(next, result)(resolve, reject)\n      }, function (excuse) {\n        rejectedTo(next, excuse)(resolve, reject)\n      })\n    }\n  }\n\n  function compose (promise, next) {\n    return function (waiting) {\n      return waiting && hasExcuse(waiting.excuse)\n        // the overall promise will reject immediately if found an tolerated\n        // rejection, since a parallel promise cannot react to it.\n        ? rejectWith(waiting.excuse)\n        // otherwise, the current promise's result will be taken into account in turn.\n        : awaitFor(promise, next)\n    }\n  }\n\n  function connect (step, next) {\n    return function (waiting) {\n      var result = step.apply(null, arguments)\n      return result instanceof Promise$\n        // a step function may return another promise, or\n        ? awaitFor(result, next)\n        // return a new promisee function to generate a promise.\n        : isApplicable(result) ? awaitFor(makePromise(result), next)\n          // any value other than a sync step result will be intercepted as\n          // the excuse of a final rejection.\n          : !Array.isArray(result) ? rejectWith(safeExcuse(result, waiting))\n            // a sync step result will be relayed literally, so it may have\n            // any number of values in theory.\n            : function (resolve, reject) {\n              next.apply(null, result)(resolve, reject)\n            }\n    }\n  }\n\n  function makePromises (promises) {\n    if (!Array.isArray(promises)) {\n      promises = []\n    }\n    for (var i = 0; i < promises.length; i++) {\n      promises[i] = makePromise(promises[i])\n    }\n    return promises\n  }\n\n  // the empty value which has been resolved to null.\n  var empty = link(Type, 'empty', Promise$.resolve(null))\n\n  // guard espresso promises to ignore unhandled rejections.\n  ignoreUnhandledRejectionsBy(function (promise, excuse) {\n    // create warnings\n    return promise.excusable === true\n  })\n\n  // another special value which has been rejected.\n  var nothing = link(Type, 'nothing', Promise$.reject(NoExcuse))\n  // catch the rejection of nothing.\n  nothing.catch(function () {})\n\n  // To make a promise from one or more promisee functions and/or other promises.\n  // It's is fulfilled when all promise handlers have been invoked sequentially.\n  var noop = function () { return this }\n  $export($, 'commit', link(Type, 'of', function (promising, next) {\n    var last = arguments.length - 1\n    next = last > 0 ? wrap(arguments[last]) : null\n    for (var i = last - 1; i > 0; i--) {\n      var current = arguments[i]\n      if (!isApplicable(current)) {\n        current = noop.bind(current)\n      }\n      next = connect(current, next)\n    }\n    promising = typeof promising === 'undefined' || promising === null\n      ? nothing : makePromise(promising)\n    return next ? makePromise(compose(promising, next)(), true) : promising\n  }, true))\n\n  // to make a resolved promise for a value.\n  link(Type, 'of-resolved', function (result) {\n    return typeof result === 'undefined' || result === null ? empty\n      : assemble(Promise$.resolve(result))\n  }, true)\n\n  // to make a rejected promise with a cause.\n  link(Type, 'of-rejected', function (excuse) {\n    excuse = safeExcuse(excuse)\n    return excuse === NoExcuse ? nothing\n      : assemble(Promise$.reject(excuse))\n  }, true)\n\n  // To make a promise from one or more promisee functions and/or other promises.\n  // It's is fulfilled when all promise handlers have been invoked separately.\n  $export($, 'commit*', link(Type, 'of-all', function (promising) {\n    var promises = makePromises(Array.prototype.slice.call(arguments))\n    return promises.length > 0 ? assemble(Promise$.all(promises)) : empty\n  }, true))\n\n  // the array argument version of (promise of-all promising, ...)\n  link(Type, 'all', function (promisingList) {\n    if (!Array.isArray(promisingList)) {\n      return empty\n    }\n    var promises = makePromises(promisingList)\n    return promises.length > 0 ? assemble(Promise$.all(promises)) : empty\n  }, true)\n\n  // To make a promise from one or more promisee functions and/or other promises.\n  // It's is fulfilled when any one of them is fulfilled.\n  $export($, 'commit?', link(Type, 'of-any', function (promising) {\n    var promises = makePromises(Array.prototype.slice.call(arguments))\n    return promises.length > 1 ? assemble(Promise$.race(promises))\n      : promises.length > 0 ? promises[0] : nothing\n  }, true))\n\n  // the array argument version of (promise of-any promising, ...)\n  link(Type, 'any', function (promisingList) {\n    if (!Array.isArray(promisingList)) {\n      return nothing\n    }\n    var promises = makePromises(promisingList)\n    return promises.length > 1 ? assemble(Promise$.race(promises))\n      : promises.length > 0 ? promises[0] : nothing\n  }, true)\n\n  var proto = Type.proto\n  // the optional cancellation capability of a promise.\n  link(proto, 'is-cancellable', function () {\n    return isApplicable(this.$cancel)\n  })\n  // try to cancel the promised operation.\n  link(proto, 'cancel', function () {\n    // a cancel function should be ready for being called multiple times.\n    return isApplicable(this.$cancel) ? this.$cancel.apply(this, arguments) : null\n  })\n\n  // the next step after this promise has been either resolved or rejected.\n  // this returns a new promise or this (only when step is missing).\n  link(proto, 'then', function (step) {\n    return typeof step === 'undefined' ? this\n      : makePromise(awaitFor(this, wrap(step)), true)\n  })\n\n  // the last step after this promise has been either resolved or rejected.\n  // this returns current promise\n  link(proto, 'finally', function (waiter) {\n    if (isApplicable(waiter)) {\n      this.then(\n        resolvedTo.bind(null, waiter),\n        rejectedTo.bind(null, waiter)\n      )\n    }\n    return this\n  })\n\n  // range is empty if it cannot iterate at least once.\n  link(proto, 'is-empty', function () {\n    return this === empty || this === nothing\n  })\n  link(proto, 'not-empty', function () {\n    return this !== empty && this !== nothing\n  })\n\n  // Encoding\n  var symbolPromise = sharedSymbolOf('promise')\n  var emptyPromise = $Tuple.of(symbolPromise, sharedSymbolOf('empty'))\n  var nothingPromise = $Tuple.of(symbolPromise, sharedSymbolOf('nothing'))\n  var otherPromise = $Tuple.of(symbolPromise, sharedSymbolOf('of'), $Symbol.etc)\n  var toCode = link(proto, 'to-code', function () {\n    return this === empty ? emptyPromise\n      : this === nothing ? nothingPromise\n        : otherPromise\n  })\n\n  // Description\n  link(proto, 'to-string', function () {\n    return toCode.call(this)['to-string']()\n  })\n\n  // Indexer\n  var indexer = link(proto, ':', function (index, value) {\n    return typeof index === 'string' ? protoValueOf(this, proto, index)\n      : index instanceof Symbol$ ? protoValueOf(this, proto, index.key) : null\n  })\n  indexer.get = function (key) {\n    return proto[key]\n  }\n\n  // export type indexer.\n  link(Type, 'indexer', indexer)\n}\n","'use strict'\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var Type = $.range\n  var Range$ = $void.Range\n  var Symbol$ = $void.Symbol\n  var link = $void.link\n  var protoValueOf = $void.protoValueOf\n\n  // the empty value\n  link(Type, 'empty', new Range$(0, 0, 1))\n\n  // create a range\n  link(Type, 'of', function (begin, end, step) {\n    if (begin instanceof Range$) {\n      return begin // null op for the same type.\n    }\n    if (typeof begin !== 'number' || isNaN(begin) || !isFinite(begin)) {\n      begin = 0\n    }\n    if (typeof end === 'undefined') {\n      end = begin\n      begin = 0\n    } else if (typeof end !== 'number' || isNaN(end) || !isFinite(end)) {\n      end = 0\n    }\n    if (typeof step !== 'number' || isNaN(step) || !isFinite(step)) {\n      step = 0\n    }\n    return new Range$(begin, end, step || (begin <= end ? 1 : -1))\n  }, true)\n\n  var proto = Type.proto\n\n  link(proto, 'begin', function () {\n    return this.begin\n  })\n  link(proto, 'end', function () {\n    return this.end\n  })\n  link(proto, 'step', function () {\n    return this.step\n  })\n\n  link(proto, 'count', function () {\n    var diff = this.end - this.begin\n    var count = Math.trunc(diff / this.step)\n    var remainder = diff % this.step\n    return count < 0 ? 0 : remainder ? count + 1 : count\n  })\n\n  // generate an iterator function\n  link(proto, 'iterate', function () {\n    var range = this\n    var current = null\n    var next = this.begin\n    return function (inSitu) {\n      if (current !== null && inSitu === true) {\n        return current\n      }\n      if (range.step > 0 ? next >= range.end : next <= range.end) {\n        return null\n      }\n      current = next; next += range.step\n      return current\n    }\n  })\n\n  // Identity and Equivalence: to be determined by field values.\n  link(proto, ['is', '===', 'equals', '=='], function (another) {\n    return this === another || (\n      another instanceof Range$ &&\n      this.begin === another.begin &&\n      this.end === another.end &&\n      this.step === another.step\n    )\n  })\n  link(proto, ['is-not', '!==', 'not-equals', '!='], function (another) {\n    return this !== another && (\n      !(another instanceof Range$) ||\n      this.begin !== another.begin ||\n      this.end !== another.end ||\n      this.step !== another.step\n    )\n  })\n\n  // override comparison logic to keep consistent with Identity & Equivalence.\n  link(proto, 'compare', function (another) {\n    return this === another ? 0\n      : !(another instanceof Range$) || this.step !== another.step ? null\n        : this.step > 0\n          ? this.begin < another.begin\n            ? this.end >= another.end ? 1 : null\n            : this.begin === another.begin\n              ? this.end < another.end ? -1\n                : this.end === another.end ? 0 : 1\n              : this.end <= another.end ? -1 : null\n          : this.begin > another.begin\n            ? this.end <= another.end ? 1 : null\n            : this.begin === another.begin\n              ? this.end > another.end ? -1\n                : this.end === another.end ? 0 : 1\n              : this.end >= another.end ? -1 : null\n  })\n\n  // range is empty if it cannot iterate at least once.\n  link(proto, 'is-empty', function () {\n    return this.step > 0 ? this.begin >= this.end : this.begin <= this.end\n  })\n  link(proto, 'not-empty', function () {\n    return this.step > 0 ? this.begin < this.end : this.begin > this.end\n  })\n\n  // Representation\n  link(proto, 'to-string', function () {\n    return '(' + [this.begin, this.end, this.step].join(' ') + ')'\n  })\n\n  // Indexer\n  var indexer = link(proto, ':', function (index, value) {\n    return typeof index === 'string' ? protoValueOf(this, proto, index)\n      : index instanceof Symbol$ ? protoValueOf(this, proto, index.key) : null\n  })\n  indexer.get = function (key) {\n    return proto[key]\n  }\n\n  // export type indexer.\n  link(Type, 'indexer', indexer)\n}\n","'use strict'\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var Type = $.string\n  var link = $void.link\n  var Symbol$ = $void.Symbol\n  var thisCall = $void.thisCall\n  var protoValueOf = $void.protoValueOf\n\n  // the empty value\n  link(Type, 'empty', '')\n\n  // generate a string from inputs.\n  link(Type, 'of', function (value) {\n    // return the empty value without an argument.\n    if (typeof value === 'undefined') {\n      return ''\n    }\n    // concat the trimmed values of strings and to-string results of non-strings.\n    var result = []\n    for (var i = 0; i < arguments.length; i++) {\n      var str = arguments[i]\n      if (typeof str !== 'string') {\n        str = thisCall(str, 'to-string')\n        if (typeof str !== 'string') {\n          str = ''\n        }\n      }\n      if (str) {\n        result.push(str)\n      }\n    }\n    return result.join('')\n  }, true)\n\n  // generate a string from a series of unicode values\n  link(Type, 'of-chars', function () {\n    return String.fromCharCode.apply(String, arguments)\n  }, true)\n\n  // generate the source code string for any value.\n  link(Type, 'of-code', function (value) {\n    return typeof value === 'undefined' ? ''\n      : thisCall(thisCall(value, 'to-code'), 'to-string')\n  }, true)\n\n  var proto = Type.proto\n  // return the length of this string.\n  link(proto, 'length', function () {\n    return this.length\n  })\n\n  // Searching\n  // retrieve the first char.\n  link(proto, 'first', function (count) {\n    return typeof count === 'undefined'\n      ? this.length > 0 ? this.charAt(0) : null\n      : this.substr(0, count >> 0)\n  })\n  // try to find the index of the first occurrence of value.\n  link(proto, 'first-of', function (value, from) {\n    from >>= 0\n    return this.indexOf(value, from < 0 ? from + this.length : from)\n  })\n  // retrieve the last char.\n  link(proto, 'last', function (count) {\n    return typeof count === 'undefined'\n      ? this.length > 0 ? this.charAt(this.length - 1) : null\n      : this.substr(Math.max(0, this.length - (count >>= 0)), count)\n  })\n  // retrieve the last char or the index of the last occurrence of value.\n  link(proto, 'last-of', function (value, from) {\n    return typeof value === 'undefined' ? -1\n      : typeof value !== 'string' || !value ? this.length\n        : this.lastIndexOf(value,\n          (from = typeof from === 'undefined' ? this.length : from >> 0) < 0\n            ? from + this.length : from\n        )\n  })\n\n  link(proto, 'contains', function (str) {\n    return typeof str === 'string' && (this.indexOf(str) >= 0)\n  })\n  link(proto, 'starts-with', function (prefix) {\n    return typeof prefix === 'string' && this.startsWith(prefix)\n  })\n  link(proto, 'ends-with', function (suffix) {\n    return typeof suffix === 'string' && this.endsWith(suffix)\n  })\n\n  // Converting\n  // generate sub-string from this string.\n  var copy = link(proto, 'copy', function (begin, count) {\n    begin >>= 0\n    count = typeof count === 'undefined' ? Infinity : count >> 0\n    if (count < 0) {\n      begin += count\n      count = -count\n    }\n    if (begin < 0) {\n      begin += this.length\n      if (begin < 0) {\n        count += begin\n        begin = 0\n      }\n    }\n    return this.substr(begin, count)\n  })\n  var slice = link(proto, 'slice', function (begin, end) {\n    begin >>= 0\n    if (begin < 0) {\n      begin += this.length\n      if (begin < 0) {\n        begin = 0\n      }\n    }\n    end = typeof end === 'undefined' ? this.length : end >> 0\n    if (end < 0) {\n      end += this.length\n      if (end < 0) {\n        end = 0\n      }\n    }\n    return this.substr(begin, end - begin)\n  })\n\n  link(proto, 'trim', String.prototype.trim)\n  link(proto, 'trim-left', String.prototype.trimLeft)\n  link(proto, 'trim-right', String.prototype.trimRight)\n\n  link(proto, 'replace', function (value, newValue) {\n    return typeof value !== 'string' || !value ? this\n      : this.replace(\n        new RegExp(value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'g'),\n        typeof newValue === 'string' ? newValue : ''\n      )\n  })\n  link(proto, 'to-upper', function (localized) {\n    return localized === true ? this.toLocaleUpperCase() : this.toUpperCase()\n  })\n  link(proto, 'to-lower', function (localized) {\n    return localized === true ? this.toLocaleLowerCase() : this.toLowerCase()\n  })\n\n  // combination and splitting of strings\n  link(proto, ['concat', '+'], function () {\n    var result = this ? [this] : []\n    for (var i = 0; i < arguments.length; i++) {\n      var str = arguments[i]\n      if (typeof str !== 'string') {\n        str = $void.thisCall(str, 'to-string')\n        if (typeof str !== 'string') {\n          str = ''\n        }\n      }\n      if (str) {\n        result.push(str)\n      }\n    }\n    return result.join('')\n  })\n  // the reversed operation of '-':\n  // if the argument value is a string, to removes a substring if it's the suffix.\n  // if the argument value is a number, to removes a suffix with the length of this number.\n  // other argument values will be converted to a string and to be removed as suffix.\n  link(proto, '-', function () {\n    if (this.length < 1 || arguments.length < 1) {\n      return this\n    }\n    var result = this\n    for (var i = arguments.length - 1; i >= 0; i--) {\n      var value = arguments[i]\n      if (typeof value === 'string') {\n        if (result.endsWith(value)) {\n          result = result.substring(0, result.length - value.length)\n        }\n      } else if (typeof value === 'number') {\n        result = result.substring(0, result.length - value)\n      } else {\n        value = thisCall(value, 'to-string')\n        if (typeof value !== 'string') {\n          value = ''\n        }\n        if (value && result.endsWith(value)) {\n          result = result.substring(0, result.length - value.length)\n        }\n      }\n    }\n    return result\n  })\n  link(proto, 'split', function (separator) {\n    // to be symmetrical with join, replace a missing separator to a whitespace.\n    return typeof separator === 'undefined' ? this.split(' ')\n      // a non-string separator is interpreted as does-not-exist.\n      : typeof separator !== 'string' ? [this]\n        // a non-empty separator will be forwarded to native code.\n        : separator ? this.split(separator)\n          // replace default split('') to the safe version of splitting chars.\n          // this is also kind of symmetry with join.\n          : asChars.call(this)\n  })\n\n  // explicitly and safely convert a string to an array of chars\n  var asChars = link(proto, 'as-chars', typeof Array.from === 'function' ? function () {\n    return Array.from(this)\n  } : function () {\n    return this.length < 1 ? []\n      // polyfill from Babel.\n      : this.split(/(?=(?:[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]))/)\n  })\n\n  // get a character's unicode value by its offset in this string.\n  link(proto, 'char-at', function (offset) {\n    offset >>= 0\n    var code = this.charCodeAt(offset < 0 ? offset + this.length : offset)\n    return isNaN(code) ? null : code\n  })\n\n  // Ordering: override general comparison logic.\n  link(proto, 'compare', function (another) {\n    return typeof another !== 'string' ? null\n      : this === another ? 0 : this > another ? 1 : -1\n  })\n\n  // comparing operators\n  link(proto, '>', function (another) {\n    return typeof another === 'string' ? this > another : null\n  })\n  link(proto, '>=', function (another) {\n    return typeof another === 'string' ? this >= another : null\n  })\n  link(proto, '<', function (another) {\n    return typeof another === 'string' ? this < another : null\n  })\n  link(proto, '<=', function (another) {\n    return typeof another === 'string' ? this <= another : null\n  })\n\n  // the emptiness of string is determined by its length.\n  link(proto, 'is-empty', function () {\n    return this === ''\n  })\n  link(proto, 'not-empty', function () {\n    return this !== ''\n  })\n\n  // Representation\n  link(proto, 'to-string', function () {\n    return JSON.stringify(this)\n  })\n\n  // Indexer\n  var indexer = link(proto, ':', function (index) {\n    return typeof index === 'string' ? protoValueOf(this, proto, index)\n      : index instanceof Symbol$ ? protoValueOf(this, proto, index.key)\n        : typeof index !== 'number' ? null\n          : arguments.length > 1\n            ? slice.apply(this, arguments) // chars in a range.\n            : copy.apply(this, [index, 1])\n  })\n  indexer.get = function (key) {\n    return proto[key]\n  }\n\n  // export type indexer.\n  link(Type, 'indexer', indexer)\n}\n","'use strict'\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var Type = $.symbol\n  var $Tuple = $.tuple\n  var $String = $.string\n  var Symbol$ = $void.Symbol\n  var link = $void.link\n  var isSafeName = $void.isSafeName\n  var isSafeSymbol = $void.isSafeSymbol\n  var escapeSymbol = $void.escapeSymbol\n  var protoValueOf = $void.protoValueOf\n\n  var strCompare = $String.proto.compare\n  var strToString = $String.proto['to-string']\n\n  // common symbol repository\n  var sharedSymbols = $void.sharedSymbols\n  var sharedSymbolOf = $void.sharedSymbolOf\n\n  // the empty value.\n  var empty = link(Type, 'empty', sharedSymbolOf(''))\n\n  // a special symbol to indicate \"etc.\" or \"more\" for parser and operator\n  link(Type, 'etc', sharedSymbolOf('...'))\n\n  // a special symbol to indicate \"all\" or \"any\" for parser and operator\n  link(Type, 'all', sharedSymbolOf('*'))\n  link(Type, 'any', sharedSymbolOf('?'))\n\n  // symbols for common operators\n  link(Type, 'quote', sharedSymbolOf('`'))\n\n  link(Type, 'lambda', sharedSymbolOf('='))\n  link(Type, 'stambda', sharedSymbolOf('->'))\n  link(Type, 'function', sharedSymbolOf('=>'))\n  link(Type, 'operator', sharedSymbolOf('=?'))\n\n  link(Type, 'let', sharedSymbolOf('let'))\n  link(Type, 'var', sharedSymbolOf('var'))\n  link(Type, 'const', sharedSymbolOf('const'))\n  link(Type, 'local', sharedSymbolOf('local'))\n  link(Type, 'locon', sharedSymbolOf('locon'))\n\n  // symbols for common punctuation\n  link(Type, 'escape', sharedSymbolOf('\\\\'))\n  link(Type, 'begin', sharedSymbolOf('('))\n  link(Type, 'end', sharedSymbolOf(')'))\n  link(Type, 'comma', sharedSymbolOf(','))\n  // period is only special when it's immediately after a ')'.\n  link(Type, 'period', sharedSymbolOf('.'))\n  link(Type, 'semicolon', sharedSymbolOf(';'))\n  link(Type, 'literal', sharedSymbolOf('@'))\n  link(Type, 'pairing', sharedSymbolOf(':'))\n  link(Type, 'subject', sharedSymbolOf('$'))\n  link(Type, 'comment', sharedSymbolOf('#'))\n\n  // create a symbol from a key.\n  link(Type, 'of', function (key) {\n    return typeof key === 'string'\n      ? sharedSymbols[key] || new Symbol$(key)\n      : key instanceof Symbol$ ? key : empty\n  }, true)\n\n  // create a shared symbol from a key.\n  link(Type, 'of-shared', function (key) {\n    return typeof key === 'string' ? sharedSymbolOf(key)\n      : key instanceof Symbol$ ? sharedSymbolOf(key.key)\n        : empty\n  }, true)\n\n  // to test if a string is a safe key or a symbol has a safe key.\n  link(Type, 'is-safe', function (key, type) {\n    return typeof key === 'string'\n      ? type === Type ? isSafeSymbol(key) : isSafeName(key)\n      : key instanceof Symbol$\n        ? type === Type ? isSafeSymbol(key.key) : isSafeName(this.key)\n        : false\n  }, true)\n\n  var proto = Type.proto\n  link(proto, 'key', function () {\n    return this.key\n  })\n\n  // test if this symbol has a safe key.\n  link(proto, 'is-safe', function (type) {\n    return type === Type ? isSafeSymbol(this.key) : isSafeName(this.key)\n  })\n  link(proto, 'is-unsafe', function (type) {\n    return type === Type ? !isSafeSymbol(this.key) : !isSafeName(this.key)\n  })\n\n  // Identity and Equivalence is determined by the key\n  link(proto, ['is', '===', 'equals', '=='], function (another) {\n    return this === another || (\n      another instanceof Symbol$ && this.key === another.key\n    )\n  })\n  link(proto, ['is-not', '!==', 'not-equals', '!='], function (another) {\n    return this !== another && (\n      !(another instanceof Symbol$) || this.key !== another.key\n    )\n  })\n\n  // Ordering: to determine by the string value of key.\n  link(proto, 'compare', function (another) {\n    return this === another ? 0\n      : another instanceof Symbol$\n        ? strCompare.call(this.key, another.key)\n        : null\n  })\n\n  // Emptiness: The empty symbol's key is an empty string.\n  link(proto, 'is-empty', function () {\n    return this.key === '' || this.key === '\\t'\n  })\n  link(proto, 'not-empty', function () {\n    return this.key !== '' && this.key !== '\\t'\n  })\n\n  // Representation\n  link(proto, 'to-string', function (format) {\n    switch (format) {\n      case $String:\n        // result can be either a literal symbol or string, like field name.\n        return isSafeSymbol(this.key) ? this.key : strToString.call(this.key)\n      case $Tuple:\n        // make sure the result can be recover to a symbol.\n        return !this.key ? '(`)'\n          : isSafeSymbol(this.key) ? '(`' + this.key + ')'\n            : '(symbol of ' + strToString.call(this.key) + ')'\n      case Type:\n        // result can be either a literal symbol or other literal value.\n        return isSafeSymbol(this.key) ? this.key : escapeSymbol(this.key)\n      default:\n        return this.key\n    }\n  })\n\n  // Indexer\n  var indexer = link(proto, ':', function (index) {\n    return typeof index === 'string' ? protoValueOf(this, proto, index)\n      : index instanceof Symbol$ ? protoValueOf(this, proto, index.key) : null\n  })\n  indexer.get = function (key) {\n    return proto[key]\n  }\n\n  // export type indexer.\n  link(Type, 'indexer', indexer)\n}\n","'use strict'\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var Type = $.tuple\n  var $Array = $.array\n  var $Symbol = $.symbol\n  var Tuple$ = $void.Tuple\n  var Range$ = $void.Range\n  var Symbol$ = $void.Symbol\n  var link = $void.link\n  var thisCall = $void.thisCall\n  var protoValueOf = $void.protoValueOf\n  var sharedSymbolOf = $void.sharedSymbolOf\n\n  // the empty value\n  var empty = link(Type, 'empty', new Tuple$([]))\n  // the empty value for a plain tuple.\n  var blank = link(Type, 'blank', new Tuple$([], true))\n  // an unknown structure.\n  var unknown = link(Type, 'unknown', new Tuple$([$Symbol.etc]))\n\n  // empty operations\n  link(Type, 'lambda', new Tuple$([$Symbol.lambda, empty, blank]))\n  link(Type, 'stambda', new Tuple$([$Symbol.stambda, empty, blank]))\n  link(Type, 'function', new Tuple$([$Symbol.function, empty, blank]))\n  link(Type, 'operator', new Tuple$([$Symbol.operator, empty, blank]))\n\n  // empty objects\n  link(Type, 'array', new Tuple$([$Symbol.literal]))\n  link(Type, 'object', new Tuple$([$Symbol.literal, $Symbol.pairing]))\n  link(Type, 'class', new Tuple$([\n    $Symbol.literal, $Symbol.pairing, sharedSymbolOf('class')\n  ]))\n\n  // check if the value can be accepted as an element of a tuple.\n  link(Type, 'accepts', function (value) {\n    return value instanceof Symbol$ ||\n      value instanceof Tuple$ ||\n      typeof value === 'string' ||\n      typeof value === 'number' ||\n      typeof value === 'boolean' ||\n      value instanceof Range$ ||\n      value instanceof Date ||\n      value === null ||\n      typeof value === 'undefined'\n  }, true)\n\n  var atomOf = link(Type, 'atom-of', function (value) {\n    return value instanceof Symbol$ ||\n      value instanceof Tuple$ ||\n      typeof value === 'string' ||\n      typeof value === 'number' ||\n      typeof value === 'boolean' ||\n      value instanceof Range$ ||\n      value instanceof Date ||\n      value === null ? value : typeof value === 'undefined' ? null : unknown\n  }, true)\n\n  var append = function () {\n    var i = this.length\n    this.push.apply(this, arguments)\n    for (; i < this.length; i++) {\n      this[i] = atomOf(this[i])\n    }\n    return this\n  }\n\n  // create a common tuple (statement) of the argument values.\n  link(Type, 'of', function () {\n    return arguments.length ? new Tuple$(append.apply([], arguments)) : empty\n  }, true)\n\n  // create a plain tuple (code block or list of statements) of the argument values\n  link(Type, 'of-plain', function () {\n    return arguments.length\n      ? new Tuple$(append.apply([], arguments), true) : blank\n  }, true)\n\n  // create a tuple by elements from the iterable arguments or the argument\n  // values itself if it's not iterable.\n  link(Type, 'from', function () {\n    return merge.apply(empty, arguments)\n  }, true)\n  link(Type, 'from-plain', function () {\n    return merge.apply(blank, arguments)\n  }, true)\n\n  var proto = Type.proto\n  // the length of this tuple.\n  link(proto, 'length', function () {\n    return this.$.length\n  })\n\n  // the flag of a plain tuple.\n  link(proto, 'is-plain', function () {\n    return this.plain === true\n  })\n  link(proto, 'not-plain', function () {\n    return this.plain !== true\n  })\n\n  // generate a plain tuple.\n  link(proto, 'as-plain', function () {\n    return this.plain === true ? this\n      : this.$.length < 1 ? blank : new Tuple$(this.$, true)\n  })\n\n  // the source map of this tuple.\n  link(proto, 'source-map', function () {\n    return this.source\n  })\n\n  var array = $Array.proto\n  // generate an iterator function to traverse all items.\n  link(proto, 'iterate', function () {\n    return array.iterate.apply(this.$, arguments)\n  })\n\n  // make a new copy with all items or some in a range of (begin, begin + count).\n  link(proto, 'copy', function (begin, count) {\n    var s = array.copy.apply(this.$, arguments)\n    return s && s.length > 0\n      ? s.length === this.$.length ? this : new Tuple$(s, this.plain)\n      : this.plain ? blank : empty\n  })\n  // make a new copy with all items or some in a range of (begin, end).\n  link(proto, 'slice', function (begin, end) {\n    var s = array.slice.apply(this.$, arguments)\n    return s && s.length > 0\n      ? s.length === this.$.length ? this : new Tuple$(s, this.plain)\n      : this.plain ? blank : empty\n  })\n\n  // retrieve the first n element(s).\n  link(proto, 'first', function (count) {\n    if (typeof count === 'undefined') {\n      return array.first.call(this.$)\n    }\n    var s = array.first.call(this.$, count >> 0)\n    return s && s.length > 0\n      ? s.length >= this.$.length ? this : new Tuple$(s, this.plain)\n      : this.plain ? blank : empty\n  })\n  // find the first occurance of a value.\n  link(proto, 'first-of', function (value) {\n    return array['first-of'].call(this.$, value)\n  })\n  // retrieve the last n element(s).\n  link(proto, 'last', function (count) {\n    if (typeof count === 'undefined') {\n      return array.last.call(this.$)\n    }\n    var s = array.last.call(this.$, count >> 0)\n    return s && s.length > 0\n      ? s.length >= this.$.length ? this : new Tuple$(s, this.plain)\n      : this.plain ? blank : empty\n  })\n  // find the last occurance of a value.\n  link(proto, 'last-of', function (value) {\n    return array['last-of'].call(this.$, value)\n  })\n\n  // merge this tuple's items and argument values to create a new one.\n  link(proto, 'concat', function () {\n    var list = append.apply(this.$.slice(0), arguments)\n    return list.length > this.$.length ? new Tuple$(list, this.plain) : this\n  })\n\n  // merge this tuple and items from the argument tuples or arrays.\n  var merge = link(proto, ['merge', '+'], function () {\n    var list = this.$.slice(0)\n    for (var i = 0; i < arguments.length; i++) {\n      var source = arguments[i]\n      if (Array.isArray(source)) {\n        append.apply(list, array.select.call(source)) // compress discrete array.\n      } else if (source instanceof Tuple$) {\n        list.push.apply(list, source.$)\n      } else {\n        list.push(atomOf(source))\n      }\n    }\n    return list.length > this.$.length ? new Tuple$(list, this.plain) : this\n  })\n\n  // convert to an array, the items will be left as they're.\n  link(proto, 'to-array', function () {\n    return this.$.slice(0)\n  })\n\n  // Equivalence: to be determined by field values.\n  var equals = link(proto, ['equals', '=='], function (another) {\n    if (this === another) {\n      return true\n    }\n    if (!(another instanceof Tuple$) ||\n      this.plain !== another.plain ||\n      this.$.length !== another.$.length) {\n      return false\n    }\n    var t$ = this.$\n    var a$ = another.$\n    for (var i = t$.length - 1; i >= 0; i--) {\n      if (!thisCall(t$[i], 'equals', a$[i])) {\n        return false\n      }\n    }\n    return true\n  })\n  link(proto, ['not-equals', '!='], function (another) {\n    return !equals.call(this, another)\n  })\n\n  // override comparison logic to keep consistent with Equivalence.\n  link(proto, 'compare', function (another) {\n    return equals.call(this, another) ? 0 : null\n  })\n\n  // Emptiness: an empty tuple has no items.\n  link(proto, 'is-empty', function () {\n    return !(this.$.length > 0)\n  })\n  link(proto, 'not-empty', function () {\n    return this.$.length > 0\n  })\n\n  // expand to a string list as an enclosed expression or a series of expressions.\n  var encode = function (list, indent, padding) {\n    if (!Array.isArray(list)) {\n      list = []\n    }\n    if (typeof indent !== 'string') {\n      indent = '  '\n    }\n    if (typeof padding !== 'string') {\n      padding = ''\n    }\n    if (this.plain && this.$.length === 1) { // unwrap a container block\n      if (list.length > 0) {\n        list.push(' ')\n      }\n      if (this.$[0] instanceof Tuple$) {\n        encode.call(this.$[0], list, indent, padding)\n      } else {\n        list.push(thisCall(this.$[0], 'to-string'))\n      }\n      return list\n    }\n\n    var i, item\n    var lineBreak = '\\n' + padding\n    if (this.plain) {\n      for (i = 0; i < this.$.length; i++) {\n        list.push(lineBreak)\n        item = this.$[i]\n        if (item instanceof Tuple$) {\n          encode.call(item, list, indent, padding)\n        } else {\n          list.push(thisCall(item, 'to-string'))\n        }\n      }\n      return list\n    }\n\n    list.push('(')\n    var first = true\n    for (i = 0; i < this.$.length; i++) {\n      item = this.$[i]\n      if (item instanceof Tuple$) {\n        if (item.plain) {\n          if (item.$.length > 0) {\n            encode.call(item, list, indent, padding + indent)\n            item.$.length > 1 && list.push(lineBreak)\n          }\n        } else {\n          first ? (first = false) : list.push(' ')\n          encode.call(item, list, indent, padding)\n        }\n      } else {\n        first || item === $Symbol.pairing || (\n          i === 2 && list[1] === '@' && list[2] === ':'\n        ) ? (first = false) : list.push(' ')\n        list.push($void.thisCall(item, 'to-string'))\n      }\n    }\n    list.push(')')\n    return list\n  }\n\n  // Representation: as an enclosed expression or a plain series of expression.\n  link(proto, 'to-string', function (indent, padding) {\n    return encode.call(this, [], indent, padding).join('')\n  })\n\n  // Indexer\n  var indexer = link(proto, ':', function (index, end) {\n    return typeof index === 'string' ? protoValueOf(this, proto, index)\n      : index instanceof Symbol$ ? protoValueOf(this, proto, index.key)\n        : typeof index !== 'number' ? null\n          : typeof end === 'undefined' ? this.$[index]\n            : new Tuple$(array.slice.apply(this.$, arguments), this.plain)\n  })\n  indexer.get = function (key) {\n    return proto[key]\n  }\n\n  // export type indexer.\n  link(Type, 'indexer', indexer)\n}\n","'use strict'\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var Type = $.type\n  var $Symbol = $.symbol\n  var $Object = $.object\n  var Null = $void.null\n  var Symbol$ = $void.Symbol\n  var link = $void.link\n  var typeOf = $void.typeOf\n  var bindThis = $void.bindThis\n  var isApplicable = $void.isApplicable\n  var protoValueOf = $void.protoValueOf\n  var sharedSymbolOf = $void.sharedSymbolOf\n\n  /* The Supreme Prototype */\n  var proto = Type.proto\n\n  // Identity inherits null.\n  // Equivalence inherits null.\n  // Ordering inherits null.\n\n  // Type Verification: Any non-empty value is an instance of its type.\n  link(proto, ['is-a', 'is-an'], function (type) {\n    return typeOf(this) === type\n  })\n  link(proto, ['is-not-a', 'is-not-an'], function (type) {\n    return typeOf(this) !== type\n  })\n\n  // Emptiness needs to be customized by each type.\n\n  // Encoding inherits null.\n\n  // Representation and Description need be customized by each type.\n\n  // Indexer: default readonly accessor for all types.\n  // all value types' proto must provide a customized indexer.\n  var indexer = link(proto, ':', function (index) {\n    var name = typeof index === 'string' ? index\n      : index instanceof Symbol$ ? index.key : ''\n    return name === 'proto' ? this.reflect()\n      : name !== 'indexer' ? protoValueOf(this, this, name)\n        : bindThis(isApplicable(this.empty) ? this.empty() : this.empty,\n          this.indexer\n        )\n  })\n  indexer.get = function (key) {\n    return key === 'proto' ? this.reflect()\n      : key === 'indexer' ? null : this[key]\n  }\n\n  // the type is its own empty value.\n  link(Type, 'empty', Type)\n\n  // Retrieve the real type of an entity.\n  link(Type, 'of', typeOf, true)\n\n  // Retrieve the indexer for this type's instances.\n  link(Type, 'indexer', indexer)\n\n  // Type Reflection: Convert this type to a type descriptor object.\n  link(Type, 'reflect', function (entity) {\n    var typeDef = $Object.empty()\n    var name\n    if (this === Type && entity === null) {\n      for (name in Null) {\n        typeDef[name] = bindThis(null, Null[name])\n      }\n      typeDef.type = null\n      return typeDef\n    }\n\n    var proto_ = this.proto\n    var value, thisEmpty\n    if (typeOf(entity) === this) {\n      thisEmpty = entity\n    }\n    for (name in proto_) {\n      if (name !== 'type' && typeof proto[name] === 'undefined') {\n        value = proto_[name]\n        typeDef[name] = !isApplicable(value) ? value\n          : bindThis(typeof thisEmpty !== 'undefined' ? thisEmpty\n            : (thisEmpty = isApplicable(this.empty) ? this.empty() : this.empty)\n          , value)\n      }\n    }\n    var typeStatic = typeDef.type = $Object.empty()\n    for (name in this) {\n      if (name !== 'proto' && name !== 'type' && typeof proto[name] === 'undefined') {\n        value = this[name]\n        typeStatic[name] = !isApplicable(value) ? value\n          : bindThis(name !== 'indexer' ? this\n            : typeof thisEmpty !== 'undefined' ? thisEmpty\n              : (thisEmpty = isApplicable(this.empty) ? this.empty() : this.empty)\n          , value)\n      }\n    }\n    return typeDef\n  })\n\n  // Mutability\n  link(Type, 'seal', function () {\n    return this\n  })\n  link(Type, 'is-sealed', function () {\n    return true // all primary types are sealed.\n  })\n\n  // Type Verification: Any type is a type.\n  link(Type, ['is-a', 'is-an'], function (type) {\n    return Type === type\n  }, true)\n  link(Type, ['is-not-a', 'is-not-an'], function (type) {\n    return Type !== type\n  }, true)\n\n  // Emptiness for types:\n  //  The primal type is taken as an empty entity.\n  //  Any other type is not empty.\n  link(Type, 'is-empty', function () {\n    return this === Type\n  })\n  link(Type, 'not-empty', function () {\n    return this !== Type\n  })\n\n  // Encoding a type by its name\n  link(Type, 'to-code', function () {\n    return typeof this.name === 'string'\n      ? sharedSymbolOf(this.name) : $Symbol.empty\n  })\n\n  // Description for all types\n  link(Type, 'to-string', function () {\n    return typeof this.name === 'string' ? this.name : ''\n  })\n}\n","'use strict'\n\nfunction createEmptyOperation () {\n  return function () {\n    return null\n  }\n}\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var $Tuple = $.tuple\n  var $Bool = $.bool\n  var $Date = $.date\n  var $Number = $.number\n  var $String = $.string\n  var $Object = $.object\n  var $Array = $.array\n  var $Lambda = $.lambda\n  var $Function = $.function\n  var $Operator = $.operator\n  var $Promise = $.promise\n  var Null = $void.null\n  var Type$$ = $void.Type$\n  var Tuple$ = $void.Tuple\n  var Object$ = $void.Object\n  var Symbol$ = $void.Symbol\n  var Promise$ = $void.Promise\n  var operator = $void.operator\n  var ClassType$ = $void.ClassType\n  var isApplicable = $void.isApplicable\n\n  // flag indicates if it's running in native host.\n  $void.isNativeHost = typeof window === 'undefined'\n\n  // generate an empty function.\n  $void.createEmptyOperation = createEmptyOperation\n\n  // a static version of isPrototypeOf.\n  var isPrototypeOf = Function.prototype.call.bind(Object.prototype.isPrototypeOf)\n  $void.isPrototypeOf = isPrototypeOf\n\n  // a static version of hasOwnProperty.\n  var ownsProperty = Function.prototype.call.bind(\n    Object.prototype.hasOwnProperty\n  )\n  $void.ownsProperty = ownsProperty\n\n  // ensure the runtime bind can be safely called\n  var safelyBind = Function.prototype.call.bind(\n    Function.prototype.bind\n  )\n  $void.safelyBind = safelyBind\n\n  // support native new operator on a constructor function\n  var newInstance = function (A, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) {\n    switch (arguments.length) {\n      case 0: return null\n      case 1: return new A()\n      case 2: return new A(b)\n      case 3: return new A(b, c)\n      case 4: return new A(b, c, d)\n      case 5: return new A(b, c, d, e)\n      case 6: return new A(b, c, d, e, f)\n      case 7: return new A(b, c, d, e, f, g)\n      case 8: return new A(b, c, d, e, f, g, h)\n      case 9: return new A(b, c, d, e, f, g, h, i)\n      case 10: return new A(b, c, d, e, f, g, h, i, j)\n      case 11: return new A(b, c, d, e, f, g, h, i, j, k)\n      case 12: return new A(b, c, d, e, f, g, h, i, j, k, l)\n      case 13: return new A(b, c, d, e, f, g, h, i, j, k, l, m)\n      case 14: return new A(b, c, d, e, f, g, h, i, j, k, l, m, n)\n      case 15: return new A(b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n      case 16: return new A(b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)\n      default: return new A(b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)\n    }\n  }\n  $void.newInstance = newInstance\n\n  // safe copy all members from a generic object or function source to a target\n  // object. To generate \"call\" and \"new\" operations for a function source.\n  var safelyAssign = function (target, source, ownedOnly) {\n    for (var key in source) {\n      if (!ownedOnly || ownsProperty(source, key)) {\n        var value = source[key]\n        target[key] = typeof value !== 'function' ? value\n          : safelyBind(value, source)\n      }\n    }\n    if (typeof source === 'function') {\n      // If the source have a 'new' function or overriding 'call', it will be\n      // just overridden by the generated function.\n      // This behavior can be changed if it's really worthy in future.\n      target.call = safelyBind(source, null)\n      target.new = newInstance.bind(null, source)\n    }\n    return target\n  }\n  $void.safelyAssign = safelyAssign\n\n  // make sure a file uri has correct espresso extension\n  $void.completeFile = function (path) {\n    if (!path || typeof path !== 'string') {\n      path = ''\n    } else if (path.endsWith('/')) {\n      while (path.endsWith('/')) {\n        path = path.substring(0, path.length - 1)\n      }\n      if (path) {\n        var offset = path.length - 2\n        while (offset >= 0 && path[offset] !== '/') {\n          offset--\n        }\n        path += '/' + (offset >= 0 ? path.substring(offset + 1) : path)\n      }\n    }\n    return path.endsWith('.es') ? path : path + '.es'\n  }\n\n  // to retrieve or create a shared symbol.\n  var sharedSymbols = $void.sharedSymbols = Object.create(null)\n  function sharedSymbolOf (key) {\n    return sharedSymbols[key] || (sharedSymbols[key] = new Symbol$(key))\n  }\n  $void.sharedSymbolOf = sharedSymbolOf\n\n  // generic operators cannot be overridden in program. They are interpreted\n  // directly in core evaluation function.\n  function staticOperator (name, impl) {\n    // make the symbol a pure symbol.\n    $[name] = sharedSymbolOf(name)\n    // export the implementation.\n    $void.staticOperators[name] = operator(impl, $Tuple.operator)\n    return impl\n  }\n  $void.staticOperator = staticOperator\n\n  $void.regexNumber = /(^)([-+]?\\d*\\.\\d+|[-+]?\\d+\\.\\d*|[+-]\\d+|\\d+)/\n  $void.regexDecimal = /(^)([-+]?\\d*\\.\\d+|[-+]?\\d+\\.\\d*|[+-]\\d+|\\d\\b|[1-9]\\d*)/\n  $void.regexPunctuation = /[\\\\(,)\\s]/\n  $void.regexSpecialSymbol = /[(`@:$\"#)',;\\\\\\s[\\]{}]/\n\n  $void.regexConstants = /^(null|true|false)$/\n  $void.constantValues = Object.assign(Object.create(null), {\n    'null': null,\n    'true': true,\n    'false': false\n  })\n\n  var regexNumber = $void.regexNumber\n  var regexConstants = $void.regexConstants\n  var regexPunctuation = $void.regexPunctuation\n  var regexSpecialSymbol = $void.regexSpecialSymbol\n\n  var isSafeName = $void.isSafeName = function (key) {\n    return !!key && !regexSpecialSymbol.test(key) &&\n      !regexConstants.test(key) &&\n        !regexNumber.test(key)\n  }\n  $void.isSafeSymbol = function (key) {\n    return !!key && !regexPunctuation.test(key) &&\n      (!regexSpecialSymbol.test(key) || key.length < 2) &&\n        !regexConstants.test(key) &&\n          !regexNumber.test(key)\n  }\n  $void.escapeSymbol = function (key) {\n    var chars = []\n    for (var i = 0; i < key.length; i++) {\n      regexSpecialSymbol.test(key[i]) && chars.push('\\\\')\n      chars.push(key[i])\n    }\n    return chars.join('')\n  }\n  $void.encodeFieldName = function (name) {\n    return isSafeName(name)\n      ? (sharedSymbols[name] || new Symbol$(name)) // print as a symbol.\n      : name // print as a literal string.\n  }\n\n  // to check if an value is a compatible object.\n  $void.isObject = function (obj) {\n    return obj instanceof Object$ || typeOf(obj) === $Object\n  }\n\n  // retrieve the real type of an entity.\n  function typeOf (entity) {\n    if (entity === null || typeof entity === 'undefined') {\n      return null\n    }\n    switch (typeof entity) {\n      case 'boolean':\n        return $Bool\n      case 'number':\n        return $Number\n      case 'string':\n        return $String\n      case 'function':\n        return entity.type === $Lambda ? $Lambda\n          : entity.type === $Operator ? $Operator\n            : $Function\n      case 'object':\n        return entity instanceof Type$$\n          ? Object.getPrototypeOf(entity).type || $Object\n          : Array.isArray(entity) ? $Array\n            : entity instanceof Date ? $Date\n              : entity instanceof Promise$ ? $Promise\n                : $Object\n      default:\n        return null\n    }\n  }\n  $void.typeOf = typeOf\n\n  // retrieve the system indexer of an entity.\n  var indexerOf = $void.indexerOf = function (entity) {\n    var type = typeOf(entity)\n    return (type && type.indexer) || Null[':']\n  }\n\n  // retrieve a field value from prototype; it will be bound to its subject\n  // if it's a function.\n  var protoValueOf = $void.protoValueOf = function (subject, proto, key) {\n    var value = proto[key]\n    return typeof value === 'function' && (\n      value.type === $Lambda || value.type === $Function\n    ) ? bindThis(subject, value) : value\n  }\n\n  function thisCall (subject, methodName) {\n    var method = indexerOf(subject).call(subject, methodName)\n    return typeof method !== 'function' ? method\n      : arguments.length < 3 ? method.call(subject)\n        : method.apply(subject, Array.prototype.slice.call(arguments, 2))\n  }\n  $void.thisCall = thisCall\n\n  // try to update the name of a function or a class.\n  var tryToUpdateName = $void.tryToUpdateName = function (entity, name) {\n    if (typeof entity === 'function') {\n      if (!entity.name || typeof entity.name !== 'string') {\n        Object.defineProperty(entity, 'name', { value: name })\n      }\n    } else if (entity instanceof ClassType$) {\n      if (!entity.name || typeof entity.name !== 'string') {\n        entity.name = name\n      }\n    }\n    return entity\n  }\n\n  // to export an entity to a space.\n  $void.export = function (space, name, entity) {\n    // ensure exported names are shared.\n    sharedSymbolOf(name)\n    // automatically bind null for static methods\n    if (isApplicable(entity)) {\n      entity = bindThis(null, entity)\n    }\n    tryToUpdateName(entity, name)\n    if (entity && typeof entity === 'object') {\n      entity.seal ? entity.seal() : Object.freeze(entity)\n    }\n    return (space[name] = entity)\n  }\n\n  // create a bound function from the original function or lambda.\n  function bindThis ($this, func) {\n    if (typeof func.this !== 'undefined') {\n      // a this-bound static lambda may not be bound.\n      return func\n    }\n    var binding = safelyBind(func, $this)\n    binding.this = $this\n    binding.bound = func\n    typeof func.code !== 'undefined' && (\n      binding.code = func.code\n    )\n    if (typeof func.name === 'string') {\n      Object.defineProperty(binding, 'name', {\n        value: func.name\n      })\n    }\n    if (binding.type !== func.type) {\n      binding.type = func.type\n    }\n    if (func.type === $Lambda && func.static === true) {\n      binding.const = true // upgrade static to const lambda\n    }\n    return binding\n  }\n  $void.bindThis = bindThis\n\n  // to link an entity to its owner.\n  function link (owner, names, entity, autoBind) {\n    if (typeof entity === 'function') {\n      if (!ownsProperty(entity, 'type')) {\n        entity.type = $Lambda\n      }\n      if (!entity.name) {\n        Object.defineProperty(entity, 'name', {\n          value: typeof names === 'string' ? names : names[0]\n        })\n      }\n      if (autoBind && isApplicable(entity)) {\n        entity = bindThis(owner, entity)\n      }\n    }\n    if (typeof names === 'string') {\n      sharedSymbolOf(names)\n      owner[names] = entity\n    } else {\n      for (var i = 0; i < names.length; i++) {\n        sharedSymbolOf(names[i])\n        owner[names[i]] = entity\n      }\n    }\n    return entity\n  }\n  $void.link = link\n\n  // to export native type (static) methods.\n  $void.copyType = function (target, src, mapping) {\n    var names = Object.getOwnPropertyNames(mapping)\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i]\n      var entity = src[name]\n      if (typeof entity === 'function') {\n        entity = safelyBind(entity, src)\n        entity.type = $Lambda\n        Object.defineProperty(entity, 'name', {\n          value: mapping[name]\n        })\n      }\n      target[mapping[name]] = entity\n    }\n    return target\n  }\n\n  $void.prepareOperation = function (type, noop, emptyCode) {\n    // the empty function\n    Object.defineProperty(noop, 'name', {\n      value: 'noop'\n    })\n    var empty = link(type, 'empty', function () {\n      return noop\n    }, true)\n\n    // a placeholder of function\n    link(type, 'of', empty, true)\n\n    var proto = type.proto\n    // return operation's name\n    link(proto, 'name', function () {\n      return typeof this.name === 'string' ? this.name : ''\n    })\n\n    // return operation's parameters\n    link(proto, 'parameters', function () {\n      return (this.code || emptyCode).$[1]\n    })\n\n    // return operation's body\n    link(proto, 'body', function () {\n      return (this.code || emptyCode).$[2]\n    })\n\n    // test if the operation is a generic one.\n    link(proto, 'is-generic', function () {\n      return !(this.code instanceof Tuple$)\n    })\n    link(proto, 'not-generic', function () {\n      return this.code instanceof Tuple$\n    })\n\n    // Emptiness: a managed operation without a body.\n    link(proto, 'is-empty', function () {\n      return this.code instanceof Tuple$ &&\n          (this.code.$.length < 3 || this.code.$[2].$.length < 1)\n    })\n    link(proto, 'not-empty', function () {\n      return !(this.code instanceof Tuple$) ||\n          (this.code.$.length > 2 && this.code.$[2].$.length > 0)\n    })\n\n    // Encoding\n    link(proto, 'to-code', function (ctx) {\n      return this.code || emptyCode\n    })\n\n    // Description\n    link(proto, 'to-string', function () {\n      return (this.code || emptyCode)['to-string']()\n    })\n\n    // Indexer\n    var indexer = link(proto, ':', function (index) {\n      return typeof index === 'string' ? protoValueOf(this, proto, index)\n        : index instanceof Symbol$ ? protoValueOf(this, proto, index.key) : null\n    })\n    indexer.get = function (key) {\n      return proto[key]\n    }\n\n    // export type indexer.\n    link(type, 'indexer', indexer)\n  }\n\n  $void.prepareApplicable = function (type, emptyCode) {\n    var proto = type.proto\n\n    // test if the lambda/function has been bound to a subject.\n    link(proto, 'is-bound', function () {\n      return typeof this.bound === 'function'\n    })\n    link(proto, 'not-bound', function () {\n      return typeof this.bound !== 'function'\n    })\n\n    // return operation's parameters\n    link(proto, 'this', function () {\n      return typeof this.bound === 'function' ? this.this : null\n    })\n\n    // apply a function and expand arguments from an array.\n    link(proto, 'apply', function (subject, args) {\n      return typeof subject === 'undefined' ? this.apply(null)\n        : Array.isArray(args) ? this.apply(subject, args)\n          : typeof args === 'undefined'\n            ? this.call(subject)\n            : this.call(subject, args)\n    })\n\n    link(proto, ['is', '==='], function (another) {\n      return typeof another === 'function' && (this === another || (\n        typeof this.this !== 'undefined' && (\n          this.this === another.this || Object.is(this.this, another.this)\n        ) && typeof this.bound !== 'undefined' && this.bound === another.bound\n      ))\n    })\n    link(proto, ['is-not', '!=='], function (another) {\n      return typeof another !== 'function' || (this !== another && (\n        typeof this.this === 'undefined' || (\n          this.this !== another.this && !Object.is(this.this, another.this)\n        ) || typeof this.bound === 'undefined' || this.bound !== another.bound\n      ))\n    })\n\n    link(proto, ['equals', '=='], function (another) {\n      return typeof another === 'function' && (\n        this === another || this === another.bound || (\n          typeof this.bound !== 'undefined' && (\n            this.bound === another || this.bound === another.bound\n          )\n        )\n      )\n    })\n    link(proto, ['not-equals', '!='], function (another) {\n      return typeof another !== 'function' || (\n        this !== another && this !== another.bound && (\n          typeof this.bound === 'undefined' || (\n            this.bound !== another && this.bound !== another.bound\n          )\n        )\n      )\n    })\n  }\n}\n","'use strict'\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var $Object = $.object\n  var link = $void.link\n  var $export = $void.export\n  var isObject = $void.isObject\n  var thisCall = $void.thisCall\n  var createClass = $void.createClass\n  var isApplicable = $void.isApplicable\n\n  var emitter = createClass()\n  var proto = emitter.proto\n  link(proto, 'listeners', null)\n\n  // define allowed events for this emitter\n  link(proto, 'constructor', function () {\n    var listeners = this.listeners = $Object.empty()\n    for (var i = 0; i < arguments.length; i++) {\n      var event = arguments[i]\n      if (typeof event === 'string') {\n        listeners[event] = []\n      }\n    }\n  })\n\n  // clear legacy event handler on activation.\n  link(proto, 'activator', function () {\n    if (!isObject(this.listeners)) {\n      this.listeners = $Object.empty()\n      return\n    }\n    var events = Object.getOwnPropertyNames(this.listeners)\n    for (var i = 0; i < events.length; i++) {\n      var listeners = this.listeners[events[i]]\n      if (Array.isArray(listeners)) {\n        for (var j = listeners.length - 1; j >= 0; j--) {\n          if (thisCall(listeners[j], 'is-empty')) {\n            listeners.splice(j, 1) // remove empty listeners\n          }\n        }\n      }\n    }\n  })\n\n  // (an-emitter on) queries allowed events.\n  // (an-emitter on event) queries all listeners for an event\n  // (an-emitter on event listener) registers a listener for the event.\n  link(proto, 'on', function (event, listener) {\n    if (!isObject(this.listeners)) {\n      return null // invalid emitter instance.\n    }\n    // query events\n    if (typeof event !== 'string') {\n      return Object.getOwnPropertyNames(this.listeners)\n    }\n    // query listeners for an event.\n    if (!isApplicable(listener)) {\n      return this.listeners[event] || null\n    }\n    // register an event listener\n    var listeners = this.listeners[event]\n    if (!Array.isArray(listeners)) {\n      return null // invalid emitter instance\n    }\n    listeners.push(listener)\n    return listeners\n  })\n\n  // (an-emitter off) clears all listeners for all events.\n  // (an-emitter off event) clears all listeners for the event.\n  // (an-emitter on event listener) clears a listener for the event.\n  link(proto, 'off', function (event, listener) {\n    if (!isObject(this.listeners)) {\n      return null\n    }\n    var i, listeners\n    // clear all event listeners.\n    if (typeof event !== 'string') {\n      var events = Object.getOwnPropertyNames(this.listeners)\n      for (i = 0; i < events.length; i++) {\n        listeners = this.listeners[events[i]]\n        if (Array.isArray(listeners)) {\n          listeners.splice(0)\n        }\n      }\n      return events\n    }\n    // clear listeners for an event.\n    listeners = this.listeners[event]\n    if (!Array.isArray(listeners)) {\n      return null\n    }\n    if (!isApplicable(listener)) {\n      listeners.splice(0)\n      return listeners\n    }\n    // clear a particular listener\n    for (i = 0; i < listeners.length; i++) {\n      if (listeners[i] === listener) {\n        listeners.splice(i, 1)\n        break\n      }\n    }\n    return listeners\n  })\n\n  link(proto, 'emit', function (event, args) {\n    if (!isObject(this.listeners) || typeof event !== 'string') {\n      return null // invalid emitter instance.\n    }\n    var listeners = this.listeners[event]\n    if (!Array.isArray(listeners)) {\n      return null // partially invalid emitter instance at least.\n    }\n    if (typeof args === 'undefined') {\n      args = event\n    }\n    var handled = false\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i]\n      if (isApplicable(listener)) {\n        if (listener(args, this, event) === true) {\n          return true // event has been handled at least once.\n        }\n        handled = true\n      }\n    }\n    return handled // no listener to handle this event.\n  })\n\n  $export($, 'emitter', emitter)\n}\n","'use strict'\n\nfunction hyphenize (name) {\n  var segments = name.split(/[_-\\s]+/g)\n  var converted = false\n  for (var i = 0, count = segments.length; i < count; i++) {\n    var segment = escapeCamel(segments[i])\n    if (segment !== segments[i]) {\n      segments[i] = segment\n      converted = true\n    }\n  }\n  return segments.length > 1 || converted ? segments.join('-') : name\n}\n\nfunction escapeCamel (segment) {\n  var words = []\n  var word = ''\n  var lastIsCapital = false\n  for (var i = 0, len = segment.length; i < len; i++) {\n    var c = segment.charAt(i)\n    if (c === c.toLocaleLowerCase()) {\n      word += c\n      lastIsCapital = false\n    } else {\n      if (word && !lastIsCapital) {\n        words.push(word.toLocaleLowerCase())\n        word = ''\n      }\n      var next = ++i < len ? segment[i] : ''\n      if (!next) { // ending\n        if (lastIsCapital) {\n          words.push((word + c).toLocaleLowerCase())\n        } else {\n          words.push(c.toLocaleLowerCase())\n        }\n        word = ''\n      } else if (next !== next.toLocaleLowerCase()) {\n        // several continuous upper-cased chars, except the last one,\n        // are counted in a single word.\n        word += c; i--\n        lastIsCapital = true\n      } else {\n        word && words.push(word.toLocaleLowerCase())\n        word = c + next\n        lastIsCapital = false\n      }\n    }\n  }\n  word && words.push(word.toLocaleLowerCase())\n  return words.join('-')\n}\n\nfunction setter (key, value) {\n  if (!key || typeof key !== 'string') {\n    return null\n  }\n  if (typeof value !== 'undefined') {\n    return (this[key] = value)\n  }\n  delete this[key]\n  return null\n}\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var $Class = $.class\n  var $Object = $.object\n  var $Function = $.function\n  var typeOf = $void.typeOf\n  var $export = $void.export\n  var ownsProperty = $void.ownsProperty\n  var safelyAssign = $void.safelyAssign\n\n  var objectOfGenericFunc = $Function.proto.generic\n\n  $export($void, '$espress', function (src) {\n    // espress only returns null, a string or an object.\n    if (typeof src === 'string') {\n      return hyphenize(src)\n    }\n    // accepts a generic function so that an expression like:\n    //   (espress (func generic))\n    // can be simplified to:\n    //   (espress func)\n    var proxy\n    var srcType = typeOf(src)\n    if (srcType === $Function) {\n      proxy = objectOfGenericFunc.call(src)\n      srcType = proxy ? $Object : null\n      if (src.bound) {\n        src = src.bound\n      }\n    }\n    // ignore common proto members.\n    var proto\n    if (srcType === $Object) {\n      proto = $Object.proto\n    } else if (typeOf(srcType) === $Class) {\n      proto = $Class.proto.proto\n    } else {\n      return null\n    }\n    if (!proxy) { // make sure all methods are bound to the original object\n      proxy = safelyAssign($Object.empty(), src, true)\n    }\n    // copy and supplement setters.\n    var target = $Object.empty()\n    target['set-'] = setter.bind(src) // common setter\n    for (var key in proxy) {\n      if (typeof proto[key] === 'undefined' || ownsProperty(src, key)) {\n        var newKey = hyphenize(key)\n        target[newKey] = proxy[key]\n        if (ownsProperty(src, key)) {\n          // a dedicated setter is only supplemented for a real field.\n          target['set-' + newKey] = setter.bind(src, key)\n        }\n      }\n    }\n    return target || src\n  })\n}\n","'use strict'\n\nfunction parseOffset (str, length) {\n  var value\n  try {\n    value = parseInt(str)\n  } catch (e) {\n    return e\n  }\n  if (value < 0) {\n    value += length\n    if (value < 0) {\n      value = length\n    }\n  } else if (value >= length) {\n    value = length\n  }\n  return value\n}\n\nfunction formatValue (cache, offset, rawValue, fmt, thisCall) {\n  if (offset >= cache.length) {\n    return '...'\n  }\n  var value = cache[offset]\n  var map\n  if (value) {\n    if (typeof fmt !== 'string' || typeof rawValue === 'string') {\n      return value[0] !== null ? value[0] : (\n        value[0] = typeof rawValue === 'string' ? rawValue\n          : thisCall(rawValue, 'to-string')\n      )\n    }\n    map = value[1] || (value[1] = Object.create(null))\n    return (map[fmt] || (map[fmt] = thisCall(rawValue, 'to-string', fmt)))\n  }\n  value = cache[offset] = [null, null]\n  if (typeof fmt !== 'string' || typeof rawValue === 'string') {\n    return (value[0] = typeof rawValue === 'string' ? rawValue\n      : thisCall(rawValue, 'to-string'))\n  }\n  map = value[1] = Object.create(null)\n  return (map[fmt] = thisCall(rawValue, 'to-string', fmt))\n}\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var warn = $void.$warn\n  var link = $void.link\n  var thisCall = $void.thisCall\n\n  link($.string, 'unescape', function (source) {\n    if (typeof source !== 'string') {\n      warn('string:unescape', 'a string source should be a string.',\n        '\\n', source)\n      return null\n    }\n    if (!source.startsWith('\"')) {\n      warn('string:unescape', 'a string source should start with a \\'\"\\'.',\n        '\\n', source)\n      return source\n    }\n    if (!source.endsWith('\"')) {\n      warn('string:unescape', 'a string source should end with a \\'\"\\'.',\n        '\\n', source)\n      return source\n    }\n    var value, error\n    try {\n      // TODO: to be replaced a to native unescape processor.\n      value = JSON.parse(source)\n    } catch (err) {\n      error = err\n    }\n    if (typeof value === 'string') {\n      return value\n    }\n    warn('string:unescape', '[JSON] invalid string input: ',\n      (error && error.message) || 'unknown error.', '\\n', source)\n    return source.substring(1, source.length - 1)\n  }, true)\n\n  link($.string, 'format', function (pattern) {\n    if (typeof pattern !== 'string') {\n      warn('string:format', 'the pattern must be a string.', pattern)\n      return null\n    }\n    var args = []\n    if (arguments.length > 1) {\n      args[arguments.length - 2] = undefined\n    }\n    var values = []\n    var i = 0\n    var counter = 0\n    var c, end, placeholder, offset, fmt\n    while (i < pattern.length) {\n      c = pattern[i++]\n      if (c !== '{') {\n        values.push(c); continue\n      }\n      if (pattern[i] === '{') {\n        values.push('{'); i++; continue\n      }\n      end = pattern.indexOf('}', i)\n      if (end < i) {\n        end = pattern.length\n        warn('string:format', 'missing an ending \"}\".', pattern, i)\n      }\n      placeholder = pattern.substring(i, end)\n      i = end + 1\n      end = placeholder.indexOf(':')\n      if (end < 0) {\n        end = placeholder.length\n      }\n      offset = placeholder.substring(0, end)\n      if (offset) {\n        offset = parseOffset(offset, args.length)\n      } else if (counter >= args.length) {\n        // replace missing implicit placeholder to empty.\n        counter++; continue\n      } else {\n        offset = counter\n      }\n      if (typeof offset !== 'number') {\n        warn('string:format', 'invalid offset value gets ignored',\n          pattern, i, placeholder.substring(0, end))\n        offset = counter\n      } else if (offset >= args.length) {\n        warn('string:format', 'offset value is out of range',\n          pattern, offset, args.length - 1)\n      }\n      fmt = end < placeholder.length ? placeholder.substring(end + 1) : null\n      values.push(formatValue(args, offset, arguments[offset + 1], fmt, thisCall))\n      counter++\n    }\n    return values.join('')\n  }, true)\n\n  $void.formatPattern = function (pattern) {\n    if (pattern.indexOf('$') < 0) {\n      return [pattern]\n    }\n    var expr = ''\n    var format = []\n    var escaping = ''\n    var depth = 0\n    var args = []\n    var pushExpr = function (ending) {\n      format.push('{' + args.length + '}')\n      args.push(ending ? expr + ending : expr)\n      expr = ''; escaping = ''; depth = 0\n    }\n    var endExpr = function (ending) {\n      switch (escaping) {\n        case '$':\n          if (expr.length > 0) {\n            pushExpr()\n          } else {\n            format.push('$'); escaping = ''\n          }\n          break\n        case ' ':\n          pushExpr()\n          break\n        case '(':\n          pushExpr(ending)\n          ending !== ')' && warn(\n            'format:pattern', 'missing ending parenthesis.', expr\n          )\n          break\n        default:\n          break\n      }\n    }\n    for (var i = 0; i < pattern.length; i++) {\n      var c = pattern[i]\n      switch (escaping) {\n        case '$':\n          switch (c) {\n            case '$':\n              format.push('$'); escaping = ''\n              break\n            case '(':\n              if (expr.length > 0) {\n                endExpr(); format.push('(')\n              } else {\n                expr += '('; escaping = '('; depth = 1\n              }\n              break\n            default:\n              if (/\\)|\\s/.test(c)) {\n                endExpr(); format.push(c)\n              } else {\n                expr += c; escaping = ' '\n              }\n              break\n          }\n          break\n        case ' ':\n          if (c === '$') {\n            endExpr(); escaping = '$'\n          } else if (/\\(|\\)|\\s/.test(c)) {\n            endExpr(); format.push(c)\n          } else {\n            expr += c\n          }\n          break\n        case '(':\n          if (c === ')') {\n            if (--depth > 0) {\n              expr += c\n            } else {\n              endExpr(')')\n            }\n          } else {\n            if (c === '(') {\n              depth += 1\n            }\n            expr += c\n          }\n          break\n        default:\n          c === '$' ? escaping = '$' : format.push(c)\n          break\n      }\n    }\n    endExpr()\n    return [format.join('')].concat(args)\n  }\n}\n","'use strict'\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var $Object = $.object\n  var link = $void.link\n  var $export = $void.export\n\n  var json = $Object.empty()\n  link(json, 'of', function (value, defaultJson) {\n    try {\n      return typeof value === 'undefined' ? 'null'\n        : JSON.stringify(value, null, '  ')\n    } catch (err) {\n      return typeof defaultJson === 'undefined' ? null : defaultJson\n    }\n  })\n\n  link(json, 'parse', function (json, defaultValue) {\n    if (typeof defaultValue === 'undefined') {\n      defaultValue = null\n    }\n    try {\n      return typeof json === 'string' ? JSON.parse(json) : defaultValue\n    } catch (err) {\n      return defaultValue\n    }\n  })\n\n  $export($, 'json', json)\n}\n","'use strict'\n\nvar isFirefox = (typeof window !== 'undefined') &&\n  (typeof firefox !== 'undefined' || navigator.userAgent.indexOf('Firefox/') > 0)\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var link = $void.link\n  var $export = $void.export\n  var thisCall = $void.thisCall\n  var copyType = $void.copyType\n\n  var math = copyType($.object.empty(), Math, {\n    'E': 'e',\n    'PI': 'pi',\n    'LN2': 'ln2',\n    'LN10': 'ln10',\n    'LOG10E': 'log-e',\n    'LOG2E': 'log2-e',\n    'SQRT2': 'sqrt-2',\n    'SQRT1_2': 'sqrt-1/2',\n\n    'sin': 'sin',\n    'cos': 'cos',\n    'tan': 'tan',\n    'asin': 'asin',\n    'acos': 'acos',\n    'atan': 'atan',\n    'atan2': 'atan2',\n\n    'exp': 'exp',\n    'pow': 'pow',\n    'log': 'ln',\n    'log10': 'log',\n    'log2': 'log2',\n    'sqrt': 'sqrt',\n\n    'abs': 'abs',\n    'max': 'max',\n    'min': 'min',\n\n    'random': 'random'\n  })\n\n  // hotfix for Firefox, in which Math.exp(1) does not returns Math.E.\n  isFirefox && link(math, 'exp', function exp (x) {\n    return x === 1 ? Math.E : Math.exp(x)\n  }, true)\n\n  $export($, 'math', math)\n\n  $export($, 'max', function (x, y) {\n    switch (arguments.length) {\n      case 0:\n        return null\n      case 1:\n        return x\n      case 2:\n        return x === null || typeof x === 'undefined' ? y\n          : thisCall(x, 'compare', y) === -1 ? y : x\n      default:\n        break\n    }\n    for (var i = 1; i < arguments.length; i++) {\n      y = arguments[i]\n      if (y !== null && typeof y !== 'undefined') {\n        if (x === null || typeof x === 'undefined' ||\n          thisCall(y, 'compare', x) === 1) {\n          x = y\n        }\n      }\n    }\n    return x\n  })\n\n  $export($, 'min', function (x, y) {\n    switch (arguments.length) {\n      case 0:\n        return null\n      case 1:\n        return x\n      case 2:\n        return x === null || typeof x === 'undefined' ? y\n          : thisCall(x, 'compare', y) === 1 ? y : x\n      default:\n        break\n    }\n    for (var i = 1; i < arguments.length; i++) {\n      y = arguments[i]\n      if (y !== null && typeof y !== 'undefined') {\n        if (x === null || typeof x === 'undefined' ||\n          thisCall(y, 'compare', x) === -1) {\n          x = y\n        }\n      }\n    }\n    return x\n  })\n}\n","'use strict'\n\nmodule.exports = function ($void, stdout) {\n  var Symbol$ = $void.Symbol\n  var $export = $void.export\n  var thisCall = $void.thisCall\n  var staticOperator = $void.staticOperator\n\n  // standard output.\n  $export($void, '$print', function (value) {\n    return stdout.print.apply(stdout, arguments)\n  })\n\n  // standard output.\n  $export($void, '$printf', function (value, format) {\n    return stdout.printf(\n      typeof value === 'undefined' ? '' : value,\n      typeof format === 'undefined' ? null : format\n    )\n  })\n\n  // standard error, but only warning exists in espresso space.\n  var lastWarning = null // save to make it testable.\n  function generateWarningId () {\n    var ts = Date.now()\n    return !lastWarning || ts !== lastWarning[1][0] ? [ts, 0]\n      : [ts, lastWarning[1][1] + 1]\n  }\n\n  $export($void, '$warn', function (category) {\n    if (typeof category === 'undefined') {\n      return lastWarning\n    }\n\n    if (typeof category !== 'string' && category !== null) {\n      lastWarning = ['stdout:warn', generateWarningId(),\n        'category should be a string:', category\n      ]\n    } else if (category) { // clear warning\n      lastWarning = [category, generateWarningId()]\n        .concat(Array.prototype.slice.call(arguments, 1))\n    } else {\n      return (lastWarning = ['', generateWarningId()])\n    }\n    stdout.warn.apply(stdout, lastWarning)\n    return lastWarning\n  })\n\n  var sourceOf = function (atomValue) {\n    return thisCall(atomValue, 'to-string')\n  }\n  var evaluate = function (clause, space) {\n    evaluate = $void.evaluate\n    return evaluate(clause, space)\n  }\n  var env = function (name) {\n    env = $void.env\n    return env(name)\n  }\n  staticOperator('debug', function (space, clause) {\n    var clist = clause.$\n    if (clist.length < 2 || !space.app) {\n      return null\n    }\n    var args = [sourceOf(clause), '\\n ']\n    for (var i = 1; i < clist.length; i++) {\n      (i > 1) && args.push('\\n ')\n      args.push(sourceOf(clist[i]), '=', evaluate(clist[i], space))\n    }\n    if (env('is-debugging') === true) {\n      stdout.debug.apply(stdout, args)\n    } else if ($void.env('logging-level') >= 2) {\n      lastWarning = ['stdout:debug',\n        '(debug ...) is only for temporary usage in coding.',\n        'Please consider to remove it or replace it with (log d ...) for',\n        clause\n      ]\n      stdout.warn.apply(stdout, lastWarning)\n    }\n    return args[args.length - 1]\n  })\n\n  staticOperator('log', function (space, clause) {\n    var clist = clause.$\n    if (clist.length < 2 || !space.app) {\n      return false\n    }\n    var log = normalizeLevel(clist[1])\n    if (log === null) {\n      return false\n    } else if (!log) {\n      lastWarning = ['stdout:log', 'invalid log level (v/i/w/e/d):',\n        clist[1], 'in clause', clause\n      ]\n      stdout.warn.apply(stdout, lastWarning)\n      return false\n    }\n\n    var args = []\n    for (var i = 2; i < clist.length; i++) {\n      args.push(evaluate(clist[i], space))\n    }\n    log.apply(stdout, args)\n    return true\n  })\n\n  function normalizeLevel (type) {\n    if (type instanceof Symbol$) {\n      type = type.key\n    } else if (typeof type !== 'string') {\n      return false\n    }\n\n    switch (type.toLowerCase()) {\n      case 'd':\n      case 'debug':\n        return $void.env('is-debugging') === true ? stdout.debug : null\n      case 'v':\n      case 'verbose':\n        return $void.env('logging-level') >= 4 ? stdout.verbose : null\n      case 'i':\n      case 'info':\n        return $void.env('logging-level') >= 3 ? stdout.info : null\n      case 'w':\n      case 'warn':\n      case 'warning':\n        return $void.env('logging-level') >= 2 ? stdout.warn : null\n      case 'e':\n      case 'err':\n      case 'error':\n        return $void.env('logging-level') >= 1 ? stdout.error : null\n      default:\n        return false\n    }\n  }\n}\n","'use strict'\n\nvar Started = 'started'\nvar Elapsed = 'elapsed'\nvar Stopped = 'stopped'\nvar DefaultInterval = 1000\n\nfunction safeDelayOf (milliseconds, defaultValue) {\n  return typeof milliseconds !== 'number' ? (defaultValue || 0)\n    : (milliseconds >>= 0) <= 0 ? (defaultValue || 0)\n      : milliseconds\n}\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var $Emitter = $.emitter\n  var promiseOf = $.promise.of\n  var link = $void.link\n  var $export = $void.export\n  var createClass = $void.createClass\n  var isApplicable = $void.isApplicable\n  var ownsProperty = $void.ownsProperty\n\n  // a timer is an emitter.\n  var timer = createClass().as($Emitter)\n\n  link(timer, 'timeout', function (milliseconds, callback) {\n    if (isApplicable(milliseconds)) {\n      callback = milliseconds\n      milliseconds = 0\n    } else {\n      milliseconds = safeDelayOf(milliseconds)\n      if (!isApplicable(callback)) {\n        return milliseconds\n      }\n    }\n    // a simple non-cancellable timeout.\n    setTimeout(callback.bind(null, milliseconds), milliseconds)\n    return milliseconds\n  })\n\n  link(timer, 'countdown', function (milliseconds) {\n    milliseconds = safeDelayOf(milliseconds)\n    // a cancellable promise-based timeout.\n    return promiseOf(function (async) {\n      var id = setTimeout(function () {\n        if (id !== null) {\n          id = null\n          async.resolve(milliseconds)\n        }\n      }, milliseconds)\n      return function cancel () {\n        if (id !== null) {\n          clearTimeout(id)\n          id = null\n          async.reject(milliseconds)\n        }\n        return milliseconds\n      }\n    })\n  })\n\n  var proto = timer.proto\n  link(proto, 'constructor', function (interval, listener) {\n    // call super constructor\n    $Emitter.proto.constructor.call(this, Started, Elapsed, Stopped)\n    // apply local constructor logic\n    this.interval = safeDelayOf(interval, DefaultInterval)\n    if (isApplicable(listener)) {\n      this.on(Elapsed, listener)\n    }\n  })\n\n  link(proto, 'activator', function () {\n    // call super activator\n    $Emitter.proto.activator.apply(this, arguments)\n\n    // apply local activator logic\n    this.interval = safeDelayOf(this.interval, DefaultInterval)\n\n    // trying to fix corrupted fields\n    var listeners = this.listeners\n    var fix = function (event) {\n      if (!Array.isArray(listeners[event])) {\n        listeners[event] = []\n      }\n    }\n    fix(Started); fix(Elapsed); fix(Stopped)\n    if (ownsProperty.call(this, 'stop')) {\n      delete this.stop\n    }\n  })\n\n  link(proto, 'start', function (args) {\n    if (this.stop !== stop) {\n      return this // the timer is active already.\n    }\n    if (typeof args === 'undefined') {\n      args = this.interval\n    }\n    // create inner timer.\n    var id = setInterval(function () {\n      this.emit(Elapsed, args)\n    }.bind(this), this.interval)\n    // construct the stop function to wrap the native timer.\n    this.stop = function () {\n      if (id !== null) {\n        clearInterval(id)\n        id = null\n        this.emit(Stopped, args)\n      }\n    }.bind(this)\n    // raise the started event after stop function is ready.\n    this.emit(Started, args)\n    return this\n  })\n\n  link(proto, 'is-elapsing', function () {\n    return this.stop !== stop\n  })\n\n  var stop = link(proto, 'stop', function () {\n    // make this method overridable by an instance method.\n    if (this.stop !== stop && isApplicable(this.stop)) {\n      this.stop()\n      delete this.stop\n    }\n    return this\n  })\n\n  $export($void, '$timer', timer)\n}\n","'use strict'\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var $Object = $.object\n  var link = $void.link\n  var $export = $void.export\n\n  var uri = $Object.empty()\n  link(uri, 'encode', function (str) {\n    return typeof str !== 'string' ? null : encodeURI(str)\n  })\n\n  link(uri, 'decode', function (str, defaultValue) {\n    if (typeof str !== 'string') {\n      return typeof defaultValue === 'undefined' ? null : defaultValue\n    }\n    if (typeof defaultValue === 'undefined') {\n      return decodeURI(str)\n    }\n    try {\n      return decodeURI(str)\n    } catch (err) {\n      return defaultValue\n    }\n  })\n\n  link(uri, 'escape', function (str) {\n    return typeof str !== 'string' ? null : encodeURIComponent(str)\n  })\n\n  link(uri, 'unescape', function (str, defaultValue) {\n    if (typeof str !== 'string') {\n      return typeof defaultValue === 'undefined' ? null : defaultValue\n    }\n    if (typeof defaultValue === 'undefined') {\n      return decodeURIComponent(str)\n    }\n    try {\n      return decodeURIComponent(str)\n    } catch (err) {\n      return defaultValue\n    }\n  })\n\n  $export($, 'uri', uri)\n}\n","'use strict'\n\nmodule.exports = function arithmetic ($void) {\n  var $ = $void.$\n  var $Number = $.number\n  var mod = $Number.proto['%']\n  var link = $void.link\n  var Space$ = $void.Space\n  var Symbol$ = $void.Symbol\n  var operator = $void.operator\n  var evaluate = $void.evaluate\n  var staticOperator = $void.staticOperator\n\n  staticOperator('-', function (space, clause) {\n    var value = evaluate(clause.$[1], space)\n    return typeof value === 'number' ? (-value) : -0\n  })\n\n  staticOperator('++', function (space, clause) {\n    var clist = clause.$\n    var length = clist.length\n    if (length < 2) {\n      return 1\n    }\n    var sym = clist[1]\n    if (sym instanceof Symbol$) { // (++ symbol)\n      var value = space.resolve(sym.key)\n      return space.let(sym.key, typeof value === 'number' ? value + 1 : 1)\n    }\n    // as a normal plus-one operation\n    sym = evaluate(sym, space)\n    return typeof sym === 'number' ? sym + 1 : 1\n  })\n\n  staticOperator('--', function (space, clause) {\n    var clist = clause.$\n    var length = clist.length\n    if (length < 2) {\n      return -1\n    }\n    var sym = clist[1]\n    if (sym instanceof Symbol$) { // (-- symbol)\n      var value = space.resolve(sym.key)\n      return space.let(sym.key, typeof value === 'number' ? value - 1 : -1)\n    }\n    // as a normal minus-one operation\n    sym = evaluate(sym, space)\n    return typeof sym === 'number' ? sym - 1 : -1\n  })\n\n  // increment a value by one and assign it back to the same variable\n  link($Number.proto, '++', operator(function (space, clause, that) {\n    if (!(space instanceof Space$)) {\n      return 0 // The value of this operator is defined as 0.\n    }\n    if (typeof that !== 'number' || !clause || !clause.$ || !clause.$.length) {\n      that = 0\n    }\n    var sym = clause.$[0]\n    if (sym instanceof Symbol$) {\n      space.let(sym.key, that + 1)\n    }\n    return that\n  }))\n\n  // increment a value by one and assign it back to the same variable\n  link($Number.proto, '--', operator(function (space, clause, that) {\n    if (!(space instanceof Space$)) {\n      return 0 // The value of this operator is defined as 0.\n    }\n    if (typeof that !== 'number' || !clause || !clause.$ || !clause.$.length) {\n      that = 0\n    }\n    var sym = clause.$[0]\n    if (sym instanceof Symbol$) {\n      space.let(sym.key, that - 1)\n    }\n    return that\n  }))\n\n  // (num += num ... )\n  link($Number.proto, '+=', operator(function (space, clause, that) {\n    if (!(space instanceof Space$)) {\n      return 0 // The value of this operator is defined as 0.\n    }\n    if (typeof that !== 'number') {\n      that = 0\n    }\n    var clist = clause.$ && clause.$.length ? clause.$ : []\n    for (var i = 2; i < clist.length; i++) {\n      var value = evaluate(clist[i], space)\n      if (typeof value === 'number') {\n        that += value\n      }\n    }\n    var sym = clist[0]\n    if (sym instanceof Symbol$) {\n      space.let(sym.key, that)\n    }\n    return that\n  }))\n\n  // (num -= num ... )\n  link($Number.proto, '-=', operator(function (space, clause, that) {\n    if (!(space instanceof Space$)) {\n      return 0 // The value of this operator is defined as 0.\n    }\n    if (typeof that !== 'number') {\n      that = 0\n    }\n    var clist = clause.$ && clause.$.length ? clause.$ : []\n    for (var i = 2; i < clist.length; i++) {\n      var value = evaluate(clist[i], space)\n      if (typeof value === 'number') {\n        that -= value\n      }\n    }\n    var sym = clist[0]\n    if (sym instanceof Symbol$) {\n      space.let(sym.key, that)\n    }\n    return that\n  }))\n\n  // (num *= num ... )\n  link($Number.proto, '*=', operator(function (space, clause, that) {\n    if (!(space instanceof Space$)) {\n      return 0 // The value of this operator is defined as 0.\n    }\n    if (typeof that !== 'number') {\n      that = 0\n    }\n    var clist = clause.$ && clause.$.length ? clause.$ : []\n    for (var i = 2; i < clist.length; i++) {\n      var value = evaluate(clist[i], space)\n      if (typeof value === 'number') {\n        that *= value\n      }\n    }\n    var sym = clist[0]\n    if (sym instanceof Symbol$) {\n      space.let(sym.key, that)\n    }\n    return that\n  }))\n\n  // (num /= num ...)\n  link($Number.proto, '/=', operator(function (space, clause, that) {\n    if (!(space instanceof Space$)) {\n      return 0 // The value of this operator is defined as 0.\n    }\n    if (typeof that !== 'number') {\n      that = 0\n    }\n    var clist = clause.$ && clause.$.length ? clause.$ : []\n    for (var i = 2; i < clist.length; i++) {\n      var value = evaluate(clist[i], space)\n      if (typeof value === 'number') {\n        that /= value\n      }\n    }\n    var sym = clist[0]\n    if (sym instanceof Symbol$) {\n      space.let(sym.key, that)\n    }\n    return that\n  }))\n\n  // (num %= num ...)\n  link($Number.proto, '%=', operator(function (space, clause, that) {\n    if (!(space instanceof Space$)) {\n      return 0 // The value of this operator is defined as 0.\n    }\n    if (typeof that !== 'number') {\n      that = 0\n    }\n    var clist = clause.$ && clause.$.length ? clause.$ : []\n    if (clist.length > 2) {\n      that = mod.call(that, evaluate(clist[2], space))\n    }\n    var sym = clist[0]\n    if (sym instanceof Symbol$) {\n      space.let(sym.key, that)\n    }\n    return that\n  }))\n}\n","'use strict'\n\nmodule.exports = function assignment ($void) {\n  var $ = $void.$\n  var $Symbol = $.symbol\n  var symbolAll = $Symbol.all\n  var Tuple$ = $void.Tuple\n  var Symbol$ = $void.Symbol\n  var isObject = $void.isObject\n  var evaluate = $void.evaluate\n  var staticOperator = $void.staticOperator\n  var tryToUpdateName = $void.tryToUpdateName\n\n  // 'export' update the variable in most recent context.\n  // in function: (export var-name value)), or\n  //              (export * object), or\n  //              (export (field-name ...) object), or\n  //              (export (var-name ...) values)\n  // in operator: (export name-expr value-expr)\n  staticOperator('export', createOperatorFor('export'))\n\n  // 'var' explicitly declares a local variable in current function's context.\n  // in function: (var var-name value)), or\n  //              (var * object), or\n  //              (var (field-name ...) object), or\n  //              (var (var-name ...) values)\n  // in operator: (var name-expr value-expr)\n  staticOperator('var', createOperatorFor('var'))\n\n  // the once-assignment variable.\n  staticOperator('const', createOperatorFor('const'))\n\n  // 'let' update the variable in most recent context.\n  // in function: (let var-name value)), or\n  //              (let * object), or\n  //              (let (field-name ...) object), or\n  //              (let (var-name ...) values)\n  // in operator: (let name-expr value-expr)\n  staticOperator('let', createOperatorFor('let'))\n\n  // 'local' explicitly declares a context variable in and only in current function's context.\n  // in function: (local var-name value)), or\n  //              (local * object), or\n  //              (local (field-name ...) object), or\n  //              (local (var-name ...) values)\n  // in operator: (local name-expr value-expr)\n  staticOperator('local', createOperatorFor('lvar'))\n\n  // the local version of once-assignment variable.\n  staticOperator('locon', createOperatorFor('lconst'))\n\n  function createOperatorFor (method) {\n    return function (space, clause) {\n      var clist = clause.$\n      var length = clist.length\n      if (length < 2) {\n        return null\n      }\n      var sym = clist[1]\n      var values = length < 3 ? null : evaluate(clist[2], space)\n      if (space.inop && clause.inop) { // in operator context, let & var works like a function\n        sym = evaluate(sym, space)\n        var key = typeof sym === 'string' ? sym\n          : sym instanceof Symbol$ ? sym.key : null\n        return !key ? null\n          : space[method](key, tryToUpdateName(values, key))\n      }\n      var i, names, name, value\n      // (var symbol value)\n      if (sym instanceof Symbol$) {\n        if (sym !== symbolAll) {\n          return space[method](sym.key, tryToUpdateName(values, sym.key))\n        }\n        // (var * obj)\n        if (isObject(values)) {\n          names = Object.getOwnPropertyNames(values)\n          for (i = 0; i < names.length; i++) {\n            name = names[i]\n            value = values[name]\n            space[method](name, space[method](name,\n              typeof value === 'undefined' ? null : value\n            ))\n          }\n          return values\n        }\n        return null\n      }\n      if (!(sym instanceof Tuple$) || sym.$.length < 1) {\n        return null // unrecognized pattern\n      }\n      // (var (symbol ...) value-or-values).\n      var syms = sym.$\n      if (Array.isArray(values)) { // assign the value one by one.\n        for (i = 0; i < syms.length; i++) {\n          if (syms[i] instanceof Symbol$) {\n            space[method](syms[i].key, i < values.length ? values[i] : null)\n          }\n        }\n      } else if (isObject(values)) { // read fields into an array.\n        for (i = 0; i < syms.length; i++) {\n          if (syms[i] instanceof Symbol$) {\n            name = syms[i].key\n            value = values[name]\n            space[method](name, typeof value === 'undefined' ? null : value)\n          }\n        }\n      } else { // assign all symbols the same value.\n        for (i = 0; i < syms.length; i++) {\n          if (syms[i] instanceof Symbol$) {\n            space[method](syms[i].key, values)\n          }\n        }\n      }\n      return values\n    }\n  }\n}\n","'use strict'\n\nmodule.exports = function bitwise ($void) {\n  var $ = $void.$\n  var $Number = $.number\n  var link = $void.link\n  var Space$ = $void.Space\n  var Symbol$ = $void.Symbol\n  var evaluate = $void.evaluate\n  var operator = $void.operator\n  var staticOperator = $void.staticOperator\n\n  staticOperator('~', function (space, clause) {\n    if (clause.$.length > 1) {\n      var value = evaluate(clause.$[1], space)\n      return typeof value === 'number' ? ~value : ~0\n    }\n    return ~0\n  })\n\n  // bitwise AND and assign it back to the same variable\n  link($Number.proto, '&=', operator(function (space, clause, that) {\n    var clist = clause.$\n    if (typeof that !== 'number' || clist.length < 3) {\n      return 0\n    }\n    if (!(space instanceof Space$)) {\n      return 0 // The value of this operator is defined as 0.\n    }\n    var value = evaluate(clist[2], space)\n    that &= typeof value === 'number' ? value : 0\n    // try to save back\n    var sym = clist[0]\n    if (sym instanceof Symbol$) {\n      space.let(sym.key, that)\n    }\n    return that\n  }))\n\n  // bitwise OR and assign it back to the same variable\n  link($Number.proto, '|=', operator(function (space, clause, that) {\n    if (typeof that !== 'number') {\n      return 0\n    }\n    if (!(space instanceof Space$)) {\n      return 0 // The value of this operator is defined as 0.\n    }\n    var clist = clause && clause.$\n    var value = clist && clist.length && clist.length > 2\n      ? evaluate(clist[2], space) : 0\n    that |= typeof value === 'number' ? value : 0\n    // try to save back\n    var sym = clist[0]\n    if (sym instanceof Symbol$) {\n      space.let(sym.key, that)\n    }\n    return that\n  }))\n\n  // bitwise XOR and assign it back to the same variable\n  link($Number.proto, '^=', operator(function (space, clause, that) {\n    if (typeof that !== 'number') {\n      return 0\n    }\n    if (!(space instanceof Space$)) {\n      return 0 // The value of this operator is defined as 0.\n    }\n    var clist = clause && clause.$\n    var value = clist && clist.length && clist.length > 2\n      ? evaluate(clist[2], space) : 0\n    that ^= typeof value === 'number' ? value : 0\n    // try to save back\n    var sym = clist[0]\n    if (sym instanceof Symbol$) {\n      space.let(sym.key, that)\n    }\n    return that\n  }))\n\n  // bitwise left-shift and assign it back to the same variable\n  link($Number.proto, '<<=', operator(function (space, clause, that) {\n    if (typeof that !== 'number') {\n      return 0\n    }\n    if (!(space instanceof Space$)) {\n      return 0 // The value of this operator is defined as 0.\n    }\n    var clist = clause && clause.$\n    var offset = clist && clist.length && clist.length > 2\n      ? evaluate(clist[2], space) : 0\n    that <<= typeof offset === 'number' ? offset : 0\n    // try to save back\n    var sym = clist[0]\n    if (sym instanceof Symbol$) {\n      space.let(sym.key, that)\n    }\n    return that\n  }))\n\n  // bitwise right-shift and assign it back to the same variable\n  link($Number.proto, '>>=', operator(function (space, clause, that) {\n    if (typeof that !== 'number') {\n      return 0\n    }\n    if (!(space instanceof Space$)) {\n      return 0 // The value of this operator is defined as 0.\n    }\n    var clist = clause && clause.$\n    var offset = clist && clist.length && clist.length > 2\n      ? evaluate(clist[2], space) : 0\n    that >>= typeof offset === 'number' ? offset : 0\n    // try to save back\n    var sym = clist[0]\n    if (sym instanceof Symbol$) {\n      space.let(sym.key, that)\n    }\n    return that\n  }))\n\n  // bitwise zero-fill right-shift and assign it back to the same variable\n  link($Number.proto, '>>>=', operator(function (space, clause, that) {\n    if (typeof that !== 'number') {\n      return 0\n    }\n    if (!(space instanceof Space$)) {\n      return 0 // The value of this operator is defined as 0.\n    }\n    var clist = clause && clause.$\n    var offset = clist && clist.length && clist.length > 2\n      ? evaluate(clist[2], space) : 0\n    that >>>= typeof offset === 'number' ? offset : 0\n    // try to save back\n    var sym = clist[0]\n    if (sym instanceof Symbol$) {\n      space.let(sym.key, that)\n    }\n    return that\n  }))\n}\n","'use strict'\n\nmodule.exports = function control ($void) {\n  var $ = $void.$\n  var Tuple$ = $void.Tuple\n  var Signal$ = $void.Signal\n  var Symbol$ = $void.Symbol\n  var evaluate = $void.evaluate\n  var signalOf = $void.signalOf\n  var iterateOf = $void.iterateOf\n  var iteratorOf = $.iterator.of\n  var sharedSymbolOf = $void.sharedSymbolOf\n  var staticOperator = $void.staticOperator\n\n  var symbolElse = sharedSymbolOf('else')\n  var symbolIn = sharedSymbolOf('in')\n  var symbolUnderscore = sharedSymbolOf('_')\n\n  // (? sym) - resolve in global scope or original scope (in operator only).\n  // (? cond true-branch false-branch)\n  staticOperator('?', function (space, clause) {\n    var clist = clause.$\n    var length = clist.length\n    if (length < 2) {\n      return null // short circuit - the result will be null anyway.\n    }\n    var cond = clist[1]\n    if (length < 3) {\n      return cond instanceof Symbol$ ? space.$resolve(cond.key) : null\n    }\n    cond = evaluate(cond, space)\n    if (typeof cond !== 'undefined' && cond !== null && cond !== 0 && cond !== false) {\n      return evaluate(clist[2], space)\n    }\n    return length > 3 ? evaluate(clist[3], space) : null\n  })\n\n  // (if cond true-branch else false-branch)\n  staticOperator('if', function (space, clause) {\n    var clist = clause.$\n    var length = clist.length\n    if (length < 3) {\n      return null // short circuit - the result will be null anyway.\n    }\n\n    var result, i, expr\n    var cond = evaluate(clist[1], space)\n    if (typeof cond !== 'undefined' && cond !== null && cond !== 0 && cond !== false) { //\n      expr = clist[2]\n      if (expr === symbolElse) {\n        return null // no true branch.\n      }\n      // otherwise this expr is always taken as part of the true branch.\n      result = evaluate(expr, space)\n      for (i = 3; i < length; i++) {\n        expr = clist[i]\n        if (expr === symbolElse) {\n          return result\n        }\n        result = evaluate(expr, space)\n      }\n      return result\n    }\n    // else, cond is false\n    // skip true branch\n    for (i = 2; i < length; i++) {\n      if (clist[i] === symbolElse) {\n        break\n      }\n    }\n    if (i >= length) { // no else\n      return null // no false branch\n    }\n    result = null // in case of the else is the ending expression.\n    for (i += 1; i < length; i++) {\n      result = evaluate(clist[i], space)\n    }\n    return result\n  })\n\n  // break current loop and use the argument(s) as result\n  staticOperator('break', signalOf('break'))\n  // skip the rest expressions in this round of loop.\n  staticOperator('continue', signalOf('continue'))\n\n  function loopTest (space, cond) {\n    if (cond instanceof Symbol$) {\n      return space.resolve.bind(space, cond.key)\n    }\n    if (cond instanceof Tuple$) {\n      return evaluate.bind(null, cond, space)\n    }\n    return cond === false || cond === null || cond === 0\n  }\n\n  // condition-based loop\n  // (while cond ... )\n  staticOperator('while', function (space, clause) {\n    var clist = clause.$\n    var length = clist.length\n    if (length < 2) {\n      return null // no condition\n    }\n\n    var test = loopTest(space, clist[1])\n    var staticCond = typeof test !== 'function'\n    var result = null\n    while (true) {\n      try {\n        if (staticCond) {\n          if (test) { return null }\n        } else { // break/continue can be used in condition expression.\n          var cond = test()\n          if (cond === false || typeof cond === 'undefined' || cond === null || cond === 0) {\n            break\n          }\n        }\n        for (var i = 2; i < length; i++) {\n          result = evaluate(clist[i], space)\n        }\n      } catch (signal) {\n        if (signal instanceof Signal$) {\n          if (signal.id === 'continue') {\n            result = signal.value\n            continue\n          }\n          if (signal.id === 'break') {\n            result = signal.value\n            break\n          }\n        }\n        throw signal\n      }\n    }\n    return result\n  })\n\n  // a shortcut operator of (iterator of ...)\n  staticOperator('in', function (space, clause) {\n    var clist = clause.$\n    return iteratorOf(clist.length > 1 ? evaluate(clist[1], space) : null)\n  })\n\n  // iterator-based loop\n  // (for iterable body) - in this case, a variable name '_' is used.\n  // (for i in iterable body)\n  // (for (i, j) in iterable body)\n  staticOperator('for', function (space, clause) {\n    var clist = clause.$\n    var length = clist.length\n    if (length < 3) {\n      return null // short circuit - no loop body\n    }\n    var test = clist[2]\n    return test === symbolIn\n      ? length < 5 ? null // short circuit - no loop body\n        : forEach(space, clause, clist[1], evaluate(clist[3], space), 4)\n      : forEach(space, clause, symbolUnderscore, evaluate(clist[1], space), 2)\n  })\n\n  // (for value in iterable body) OR\n  // (for (value) in iterable body) OR\n  // (for (key value) in iterable body)\n  function forEach (space, clause, fields, next, offset) {\n    var clist = clause.$\n    var length = clist.length\n    // find out vars\n    var vars\n    if (fields instanceof Symbol$) {\n      vars = [fields.key]\n    } else if (fields instanceof Tuple$) {\n      vars = []\n      var flist = fields.$\n      for (var v = 0; v < flist.length; v++) {\n        var field = flist[v]\n        if (field instanceof Symbol$) {\n          vars.push(field.key)\n        }\n      }\n    } else {\n      vars = [] // the value is not being caught.\n    }\n    // evaluate the iterator\n    next = iterateOf(next)\n    if (!next) {\n      return null // no iterator.\n    }\n    // start to loop\n    var result = null\n    var values = next()\n    while (typeof values !== 'undefined' && values !== null) {\n      if (!Array.isArray(values)) {\n        values = [values]\n      }\n      for (var i = 0; i < vars.length; i++) {\n        space.var(vars[i], i < values.length ? values[i] : null)\n      }\n      try {\n        for (var j = offset; j < length; j++) {\n          result = evaluate(clist[j], space)\n        }\n      } catch (signal) {\n        if (signal instanceof Signal$) {\n          if (signal.id === 'continue') {\n            result = signal.value\n            values = next()\n            continue\n          }\n          if (signal.id === 'break') {\n            result = signal.value\n            break\n          }\n        }\n        throw signal\n      }\n      values = next()\n    }\n    return result\n  }\n}\n","'use strict'\n\nmodule.exports = function load ($void) {\n  var $ = $void.$\n  var $Promise = $.promise\n  var run = $void.$run\n  var warn = $void.$warn\n  var Tuple$ = $void.Tuple\n  var Promise$ = $void.Promise\n  var evaluate = $void.evaluate\n  var completeFile = $void.completeFile\n  var sharedSymbolOf = $void.sharedSymbolOf\n  var staticOperator = $void.staticOperator\n\n  var promiseAll = $Promise.all\n  var symbolFetch = sharedSymbolOf('fetch')\n  var promiseOfResolved = $Promise['of-resolved']\n\n  // fetch: asynchronously load a module from source.\n  var operator = staticOperator('fetch', function (space, clause) {\n    var clist = clause.$\n    if (clist.length < 2) {\n      return null // at least one file.\n    }\n    if (!space.app) {\n      warn('fetch', 'invalid without an app context.')\n      return null\n    }\n    var loader = $void.loader\n    var dirs = space.local['-module'] ? [loader.dir(space.local['-module'])] : []\n    var fetching = fetch.bind(null, loader, dirs)\n    var tasks = []\n    for (var i = 1; i < clist.length; i++) {\n      tasks.push(fetching(evaluate(clist[i], space)))\n    }\n    return promiseAll(tasks)\n  })\n\n  function fetch (loader, dirs, source) {\n    if (!source || typeof source !== 'string') {\n      warn('fetch', 'invalid resource uri to fetch.', source)\n      return promiseOfResolved(source)\n    }\n    source = completeFile(source)\n    if (!loader.isResolved(source)) {\n      source = loader.resolve(source, dirs)\n      if (typeof source !== 'string') {\n        warn('fetch', 'failed to resolve ', source)\n        return promiseOfResolved(source)\n      }\n    }\n    return source.endsWith('@.es')\n      ? new Promise$(function (resolve, reject) {\n        loader.fetch(source).then(function () {\n          var result = run(source)\n          if (result instanceof Promise$) {\n            result.then(resolve, reject)\n          } else {\n            resolve(result)\n          }\n        }, reject)\n      })\n      : loader.fetch(source)\n  }\n\n  $void.bindOperatorFetch = function (space) {\n    return (space.$fetch = function (uris) {\n      var clist = Array.isArray(uris) ? uris.slice()\n        : Array.prototype.slice.call(arguments)\n      clist.unshift(symbolFetch)\n      for (var i = 1; i < clist.length; i++) {\n        var uri = clist[i]\n        if (!uri || typeof uri !== 'string') {\n          warn('$fetch', 'invalid source uri:', uri)\n          clist[i] = null\n        }\n      }\n      return operator(space, new Tuple$(clist))\n    })\n  }\n}\n","'use strict'\n\nmodule.exports = function function_ ($void) {\n  var $ = $void.$\n  var $Tuple = $.tuple\n  var $Symbol = $.symbol\n  var $Lambda = $.lambda\n  var $Function = $.function\n  var Tuple$ = $void.Tuple\n  var evaluate = $void.evaluate\n  var signalOf = $void.signalOf\n  var lambdaOf = $void.lambdaOf\n  var functionOf = $void.functionOf\n  var staticLambdaOf = $void.staticLambdaOf\n  var staticOperator = $void.staticOperator\n\n  // create lambda operator\n  staticOperator('=', createOperator(lambdaOf, $Lambda.noop))\n\n  // create static lambda (pure function) operator - reserved\n  staticOperator('->', createOperator(staticLambdaOf, $Lambda.noop))\n\n  // create function operator\n  staticOperator('=>', createOperator(functionOf, $Function.noop))\n\n  // call this function by tail-recursion (elimination)\n  staticOperator('redo', signalOf('redo'))\n\n  // leave function or module.\n  staticOperator('return', signalOf('return'))\n\n  // request to stop the execution of current module.\n  staticOperator('exit', signalOf('exit'))\n\n  // create the implementation\n  function createOperator (funcOf, empty) {\n    return function (space, clause) {\n      var clist = clause.$\n      var length = clist.length\n      if (length < 2) {\n        return empty\n      }\n      var params\n      var offset\n      if (clist[1] === $Symbol.pairing) {\n        params = length > 2 ? clist[2] : $Tuple.empty\n        offset = 2\n      } else if (length > 2 && clist[2] === $Symbol.pairing) {\n        params = clist[1]\n        offset = 3\n      } else {\n        return funcOf(space, clause, 1)\n      }\n      // instant evaluation\n      if (length <= (offset + 1)) {\n        return null // no body\n      }\n      var func = funcOf(space, clause, offset)\n      if (params instanceof Tuple$) {\n        var plist = params.$\n        if (plist.length < 1) {\n          return func()\n        }\n        var args = []\n        for (var i = 0; i < plist.length; i++) {\n          args.push(evaluate(plist[i], space))\n        }\n        return func.apply(null, args)\n      } else {\n        return func(evaluate(params, space))\n      }\n    }\n  }\n}\n","'use strict'\n\nmodule.exports = function general ($void) {\n  var $ = $void.$\n  var $String = $.string\n  var link = $void.link\n  var Space$ = $void.Space\n  var Symbol$ = $void.Symbol\n  var operator = $void.operator\n  var thisCall = $void.thisCall\n  var evaluate = $void.evaluate\n  var numberValueOf = $.number.of\n  var staticOperator = $void.staticOperator\n\n  staticOperator('+', function (space, clause) {\n    var clist = clause.$\n    var length = clist.length\n    if (length > 1) {\n      var base = evaluate(clist[1], space)\n      return typeof base === 'number'\n        ? sum(space, base, clist)\n        : concat(space, base, clist)\n    }\n    return 0\n  })\n\n  function concat (space, str, clist) {\n    var length = clist.length\n    if (typeof str !== 'string') {\n      str = thisCall(str, 'to-string')\n    }\n    for (var i = 2; i < length; i++) {\n      var value = evaluate(clist[i], space)\n      str += typeof value === 'string' ? value : thisCall(value, 'to-string')\n    }\n    return str\n  }\n\n  function sum (space, num, clist) {\n    var length = clist.length\n    for (var i = 2; i < length; i++) {\n      var value = evaluate(clist[i], space)\n      if (typeof value === 'number') {\n        num += value\n      } else {\n        num += numberValueOf(value)\n      }\n    }\n    return num\n  }\n\n  // (str += str ... )\n  link($String.proto, '+=', operator(function (space, clause, that) {\n    if (!(space instanceof Space$)) {\n      return 0 // The value of this operator is defined as 0.\n    }\n    if (typeof that !== 'string') {\n      that = ''\n    }\n    var clist = clause && clause.$ && clause.$.length ? clause.$ : []\n    for (var i = 2; i < clist.length; i++) {\n      var value = evaluate(clist[i], space)\n      if (typeof value === 'string') {\n        that += value\n      } else {\n        that += thisCall(value, 'to-string')\n      }\n    }\n    var sym = clist[0]\n    if (sym instanceof Symbol$) {\n      space.let(sym.key, that)\n    }\n    return that\n  }))\n\n  // (str -= str ... ) or (str -= num)\n  link($String.proto, '-=', operator(function (space, clause, that) {\n    if (!(space instanceof Space$)) {\n      return 0 // The value of this operator is defined as 0.\n    }\n    if (typeof that !== 'string') {\n      return null\n    }\n    if (that.length < 1) {\n      return that\n    }\n    var clist = clause && clause.$ && clause.$.length ? clause.$ : []\n    for (var i = 2; i < clist.length; i++) {\n      var value = evaluate(clist[i], space)\n      if (typeof value === 'string') {\n        if (that.endsWith(value)) {\n          that = that.substring(0, that.length - value.length)\n        }\n      } else if (typeof value === 'number') {\n        that = that.substring(0, that.length - value)\n      } else {\n        value = thisCall(value, 'to-string')\n        if (that.endsWith(value)) {\n          that = that.substring(0, that.length - value.length)\n        }\n      }\n    }\n    var sym = clist[0]\n    if (sym instanceof Symbol$) {\n      space.let(sym.key, that)\n    }\n    return that\n  }))\n}\n","'use strict'\n\nmodule.exports = function import_ ($void) {\n  var $ = $void.$\n  var compile = $.compile\n  var $Object = $.object\n  var Tuple$ = $void.Tuple\n  var Symbol$ = $void.Symbol\n  var warn = $void.$warn\n  var execute = $void.execute\n  var evaluate = $void.evaluate\n  var isObject = $void.isObject\n  var completeFile = $void.completeFile\n  var sharedSymbolOf = $void.sharedSymbolOf\n  var staticOperator = $void.staticOperator\n\n  var symbolFrom = sharedSymbolOf('from')\n  var symbolImport = sharedSymbolOf('import')\n\n  // import: a module from source.\n  //   (import src), or\n  //   (import field from module), or\n  //   (import (fields ...) from module)\n  var operator = staticOperator('import', function (space, clause) {\n    var clist = clause.$\n    if (clist.length < 2) {\n      return null\n    }\n    if (!space.app) {\n      warn('import', 'invalid without an app context.')\n      return null\n    }\n    var src\n    if (clist.length < 3 || clist[2] !== symbolFrom) {\n      // look into current space to have the base uri.\n      src = importModule(space,\n        space.local['-app-home'],\n        space.local['-module'],\n        evaluate(clist[1], space)\n      )\n      // clone to protect inner exporting object.\n      return src && Object.assign($Object.empty(), src)\n    }\n    // (import field-or-fields from src)\n    src = evaluate(clist[3], space)\n    var imported\n    if (isObject(src)) {\n      imported = src\n    } else if (typeof src !== 'string') {\n      warn('import', 'invalid source object or path:', src)\n      return null\n    } else {\n      imported = importModule(space,\n        space.local['-app-home'],\n        space.local['-module'],\n        src\n      )\n      if (!imported) {\n        return null // importing failed.\n      }\n    }\n\n    // find out fields\n    var fields = clist[1]\n    if (fields instanceof Symbol$) {\n      return imported[fields.key] // import only a single field.\n    }\n    if (!(fields instanceof Tuple$)) {\n      return null // invalid field descriptor\n    }\n\n    var i\n    var flist = fields.$\n    fields = []\n    for (i = 0; i < flist.length; i++) {\n      if (flist[i] instanceof Symbol$) {\n        fields.push(flist[i].key)\n      }\n    }\n    // import fields into an array.\n    var values = []\n    for (i = 0; i < fields.length; i++) {\n      var value = imported[fields[i]]\n      values.push(typeof value === 'undefined' ? null : value)\n    }\n    return values\n  })\n\n  function importModule (space, appHome, moduleUri, source) {\n    if (typeof source !== 'string' || !source) {\n      warn('import', 'invalid module source:', source)\n      return null\n    }\n    var type\n    var offset = source.indexOf('$')\n    if (offset >= 0) {\n      type = source.substring(0, ++offset)\n    }\n    // try to locate the source in dirs.\n    var uri = type ? source.substring(offset) // native module\n      : resolve(space, appHome, moduleUri, source)\n    if (!uri) {\n      return null\n    }\n    // look up it in cache.\n    var module_ = lookupInCache(space.modules, type ? source : uri, moduleUri)\n    if (module_.status) {\n      return module_.exporting\n    }\n\n    module_.status = 100 // indicate loading\n    module_.exporting = (type ? loadNativeModule : loadModule)(\n      space, uri, module_, source, moduleUri\n    )\n    return Object.assign(module_.exporting, module_.props)\n  }\n\n  function resolve (space, appHome, moduleUri, source) {\n    var loader = $void.loader\n    var isResolved = loader.isResolved(source)\n    if (!moduleUri && isResolved) {\n      warn('import', \"It's forbidden to import a module from an absolute uri.\")\n      return null\n    }\n    var dirs = isResolved ? [] : dirsOf(source,\n      moduleUri && loader.dir(moduleUri),\n      appHome + '/modules',\n      $void.$env('user-home') + '/.es/modules',\n      $void.$env('home') + '/modules', // working dir\n      $void.runtime('home') + '/modules'\n    )\n    var uri = loader.resolve(completeFile(source), dirs)\n    if (typeof uri === 'string') {\n      return uri\n    }\n    // try to load native Espresso modules.\n    if ($void.require.resolve && !isRelative(source)) {\n      uri = $void.require.resolve(source, appHome,\n        space.local['-app-dir'], $void.$env('user-home')\n      )\n      if (typeof uri === 'string') {\n        return uri\n      } // else, make sure to display both warnings.\n    }\n    warn('import', 'failed to resolve', source, 'in', dirs)\n    return null\n  }\n\n  function isRelative (source) {\n    return source.startsWith('./') || source.startsWith('../')\n  }\n\n  function dirsOf (source, moduleDir, appDir, userDir, homeDir, runtimeDir) {\n    return moduleDir\n      ? isRelative(source)\n        ? [ moduleDir ]\n        : [ runtimeDir, appDir, userDir, homeDir ]\n      : [ runtimeDir ] // for dynamic or unknown-source code.\n  }\n\n  function lookupInCache (modules, uri, moduleUri) {\n    var module_ = modules[uri]\n    if (!module_) {\n      module_ = modules[uri] = Object.assign(Object.create(null), {\n        status: 0, // an empty module.\n        props: Object.assign($Object.empty(), {\n          '-module': uri\n        }),\n        timestamp: Date.now()\n      })\n    } else if (module_.status === 100) {\n      warn('import', 'loop dependency when loading', uri, 'from', moduleUri)\n    }\n    return module_\n  }\n\n  function loadModule (space, uri, module_, source, moduleUri) {\n    try {\n      // -module-dir is only meaningful for an Espresso module.\n      module_.props['-module-dir'] = $void.loader.dir(uri)\n      // try to load file\n      var doc = $void.loader.load(uri)\n      var text = doc[0]\n      if (typeof text !== 'string') {\n        module_.status = 415 // unsupported media type\n        warn('import', 'failed to read', source, 'for', doc[1])\n        return null\n      }\n      // compile text\n      var code = compile(text, uri, doc[1])\n      if (!(code instanceof Tuple$)) {\n        module_.status = 400 //\n        warn('import', 'failed to compile', source, 'for', code)\n        return null\n      }\n      // to load module\n      var scope = execute(space, code, uri, {\n        // in reloading, the old exporting is accessible for module code.\n        this: module_.exporting || null\n      })[1]\n      if (scope) {\n        module_.status = 200\n        return scope.exporting\n      }\n      module_.status = 500\n      warn('import', 'failed when executing', code)\n    } catch (signal) {\n      module_.status = 503\n      warn('import', 'invalid call to', signal.id,\n        'in', code, 'at', uri, 'from', moduleUri)\n    }\n    return null\n  }\n\n  function loadNativeModule (space, uri, module_, source, moduleUri) {\n    try {\n      // the native module must export a loader function.\n      var importing = $void.require(uri, moduleUri)\n      if (typeof importing !== 'function') {\n        module_.status = 400\n        warn('import', 'invalid native module', source, 'at', uri)\n        return null\n      }\n      var scope = $void.createModuleSpace(uri, space)\n      var status = importing.call(\n        module_.exporting || null, // to serve reloading.\n        scope.exporting, scope.context, $void\n      )\n      if (status === true) { // the loader can report error details\n        module_.status = 200\n        return scope.exporting\n      }\n      module_.status = 500 // internal error\n      warn('import', 'failed to import native module of', source,\n        'for', status, 'at', uri)\n    } catch (err) {\n      module_.status = 503 // service unavailable\n      warn('import', 'failed to import native module of', source,\n        'for', err, 'at', uri, 'from', moduleUri)\n    }\n    return null\n  }\n\n  $void.bindOperatorImport = function (space) {\n    return (space.$import = function (uri) {\n      if (!uri || typeof uri !== 'string') {\n        warn('$import', 'invalid source uri:', uri)\n        return null\n      }\n      return operator(space, new Tuple$([symbolImport, uri]))\n    })\n  }\n}\n","'use strict'\n\nmodule.exports = function literal ($void) {\n  var $ = $void.$\n  var $Class = $.class\n  var $Object = $.object\n  var $Symbol = $.symbol\n  var symbolOf = $Symbol.of\n  var Tuple$ = $void.Tuple\n  var Symbol$ = $void.Symbol\n  var ClassType$ = $void.ClassType\n  var thisCall = $void.thisCall\n  var evaluate = $void.evaluate\n  var arraySet = $.array.proto.set\n  var staticOperator = $void.staticOperator\n\n  var symbolPairing = $Symbol.pairing\n  var symbolAll = $Symbol.all\n  var symbolLiteral = $Symbol.literal\n  var symbolArray = $Symbol.of('array')\n  var symbolObject = $Symbol.of('object')\n  var symbolClass = $Symbol.of('class')\n\n  // (@ value ...)\n  function arrayCreate (space, clist, offset) {\n    var result = []\n    var index, value\n    while (offset < clist.length) {\n      value = evaluate(clist[offset++], space)\n      if (offset < clist.length && clist[offset] === symbolPairing) {\n        offset += 1\n        index = typeof value === 'number' ? value >> 0 : result.length\n        arraySet.call(result, index, offset >= clist.length ? null\n          : evaluate(clist[offset++], space)\n        )\n      } else {\n        result.push(value)\n      }\n    }\n    return result\n  }\n\n  // (@ symbol: value ...)\n  function objectCreate (space, clist, type, offset) {\n    var obj = type.empty()\n    var length = clist.length\n    while (offset < length) {\n      var name = clist[offset++]\n      if (name instanceof Symbol$) {\n        name = name.key\n      } else if (typeof name !== 'string') {\n        if (name instanceof Tuple$) {\n          name = evaluate(name, space)\n        }\n        if (name instanceof Symbol$) {\n          name = name.key\n        } else if (typeof name !== 'string') {\n          name = thisCall(name, 'to-string')\n        }\n      }\n      if (clist[offset] === symbolPairing) {\n        obj[name] = ++offset < length ? evaluate(clist[offset++], space) : null\n      } else {\n        obj[name] = evaluate(symbolOf(name), space)\n      }\n    }\n    // activate a typed object\n    var activator = type.proto.activator\n    if (typeof activator === 'function') {\n      activator.call(obj, obj)\n    }\n    return obj\n  }\n\n  staticOperator('@', function (space, clause) {\n    var clist = clause.$\n    var length = clist.length\n    if (length < 2) { // (@)\n      return []\n    }\n    var indicator = clist[1]\n    if (indicator !== symbolPairing) {\n      return length <= 2 || clist[2] !== symbolPairing ||\n          typeof indicator === 'number' || indicator instanceof Tuple$\n        ? arrayCreate(space, clist, 1) // (@ ...) or (@ offset: value ...)\n        : objectCreate(space, clist, $Object, 1) // (@ name: ...) or (@ \"name\": ...)\n    }\n    // (@: ...)\n    if (length < 3) { // (@:)\n      return Object.create($Object.proto)\n    }\n    // (@:a-type ...)\n    var type = clist[2]\n    return type === symbolClass\n      ? $Class.of(objectCreate(space, clist, $Object, 3)) // (@:class ...)\n      : type === symbolLiteral || type === symbolObject\n        ? objectCreate(space, clist, $Object, 3) // (@:@ ...) (@:object ...)\n        : type === symbolAll || type === symbolArray\n          ? arrayCreate(space, clist, 3) // (@:* ...) (@:array ...)\n          : objectCreate(space, clist,\n            (type = evaluate(type, space)) instanceof ClassType$\n              ? type // (@:a-class ...)\n              : $Object, // ignore type and treat it as a common object.\n            3)\n  })\n}\n","'use strict'\n\nmodule.exports = function load ($void) {\n  var $ = $void.$\n  var compile = $.compile\n  var Tuple$ = $void.Tuple\n  var warn = $void.$warn\n  var execute = $void.execute\n  var evaluate = $void.evaluate\n  var completeFile = $void.completeFile\n  var sharedSymbolOf = $void.sharedSymbolOf\n  var staticOperator = $void.staticOperator\n\n  var symbolLoad = sharedSymbolOf('load')\n\n  // load: a module from source.\n  var operator = staticOperator('load', function (space, clause) {\n    var clist = clause.$\n    if (clist.length < 2) {\n      return null\n    }\n    if (!space.app) {\n      warn('load', 'invalid without an app context.')\n      return null\n    }\n    // look into current space to have the base uri.\n    return loadData(space, space.local['-app-dir'], space.local['-module'],\n      evaluate(clist[1], space),\n      clist.length > 2 ? evaluate(clist[2], space) : null\n    )\n  })\n\n  function loadData (space, appDir, moduleUri, source, args) {\n    if (!source || typeof source !== 'string') {\n      warn('load', 'invalid source:', source)\n      return null\n    }\n    // try to locate the source uri\n    var uri = resolve(appDir, moduleUri, completeFile(source))\n    if (typeof uri !== 'string') {\n      return null\n    }\n    // try to load file\n    var doc = $void.loader.load(uri)\n    var text = doc[0]\n    if (!text) {\n      warn('load', 'failed to load', source, 'for', doc[1])\n      return null\n    }\n    // compile text\n    var code = compile(text, uri, doc[1])\n    if (!(code instanceof Tuple$)) {\n      warn('load', 'compiler warnings:', code)\n      return null\n    }\n\n    try { // to load data\n      var result = execute(space, code, uri,\n        Array.isArray(args) ? args.slice() : args)\n      var scope = result[1]\n      return scope && Object.getOwnPropertyNames(scope.exporting).length > 0\n        ? scope.exporting : result[0]\n    } catch (signal) {\n      warn('load', 'invalid call to', signal.id,\n        'in', code, 'from', uri, 'on', moduleUri)\n      return null\n    }\n  }\n\n  function resolve (appDir, moduleUri, source) {\n    if (!moduleUri) {\n      warn('load', \"It's forbidden to load a module\", 'from an anonymous module.')\n      return null\n    }\n    var loader = $void.loader\n    var dirs = loader.isResolved(source) ? []\n      : dirsOf(source, loader.dir(moduleUri), appDir)\n    var uri = loader.resolve(source, dirs)\n    if (typeof uri !== 'string') {\n      warn('load', 'failed to resolve', source, 'in', dirs)\n      return null\n    }\n    if (uri !== moduleUri) {\n      return uri\n    }\n    warn('load', 'a module,', moduleUri, ', cannot load itself by resolving', source, 'in', dirs)\n    return null\n  }\n\n  function dirsOf (source, moduleDir, appDir) {\n    return source.startsWith('./') || source.startsWith('../')\n      ? [ moduleDir ]\n      : [ moduleDir, appDir, $void.$env('home'), $void.runtime('home') ]\n  }\n\n  $void.bindOperatorLoad = function (space) {\n    return (space.$load = function (uri) {\n      if (!uri || typeof uri !== 'string') {\n        warn('$load', 'invalid source uri:', uri)\n        return null\n      }\n      return operator(space, new Tuple$([symbolLoad, uri]))\n    })\n  }\n}\n","'use strict'\n\nmodule.exports = function logical ($void) {\n  var $ = $void.$\n  var $Type = $.type\n  var $Bool = $.bool\n  var Null = $void.null\n  var link = $void.link\n  var Space$ = $void.Space\n  var operator = $void.operator\n  var evaluate = $void.evaluate\n  var thisCall = $void.thisCall\n  var symbolSubject = $.symbol.subject\n  var staticOperator = $void.staticOperator\n\n  var not = staticOperator('!', function (space, clause) {\n    if (clause.$.length < 2) {\n      return false\n    }\n    var value = evaluate(clause.$[1], space)\n    return value === false || value === null || value === 0\n  })\n\n  staticOperator('not', not)\n\n  // global logical AND operator\n  link(Null, ['&&', 'and'], operator(function (space, clause, that) {\n    if (!(space instanceof Space$)) {\n      return null\n    }\n    var clist = clause.$\n    if (typeof that === 'undefined') {\n      return null\n    }\n    if (that === false || that === null || that === 0) {\n      return that\n    }\n    var value = that\n    var i = clist[0] === symbolSubject ? 3 : 2\n    for (; i < clist.length; i++) {\n      value = evaluate(clist[i], space)\n      if (value === false || value === null || value === 0) {\n        return value\n      }\n    }\n    return value\n  }))\n\n  // global logical OR operator\n  link(Null, ['||', 'or'], operator(function (space, clause, that) {\n    var clist = clause && clause.$\n    if (typeof that === 'undefined') {\n      that = null\n    }\n    if (that !== false && that !== null && that !== 0) {\n      return that\n    }\n    if (!(space instanceof Space$)) {\n      return null\n    }\n    var value = that\n    var i = clist[0] === symbolSubject ? 3 : 2\n    for (; i < clist.length; i++) {\n      value = evaluate(clist[i], space)\n      if (value !== false && value !== null && value !== 0) {\n        return value\n      }\n    }\n    return value\n  }))\n\n  // Boolean Test.\n  // (x ?) - booleanize, returns true or false.\n  // (x ? y) - boolean fallback, returns x itself or returns y if x is equivalent to false.\n  // (x ? y z) - boolean switch, returns y if x is equivalent to true, returns z otherwise.\n  link(Null, '?', operator(function (space, clause, that) {\n    var clist = clause && clause.$\n    if (!clist || !clist.length || clist.length < 2) {\n      return null // invalid call\n    }\n    var base = clist[0] === symbolSubject ? 3 : 2\n    if (typeof that !== 'undefined' && that !== false && that !== null && that !== 0) {\n      switch (clist.length - base) { // true logic\n        case 0:\n          return true\n        case 1:\n          return that\n        default:\n          return space instanceof Space$ ? evaluate(clist[base], space) : null\n      }\n    }\n    switch (clist.length - base) { // false logic\n      case 0:\n        return false\n      case 1:\n        return space instanceof Space$ ? evaluate(clist[base], space) : null\n      default:\n        return space instanceof Space$ ? evaluate(clist[base + 1], space) : null\n    }\n  }))\n\n  // Emptiness Test.\n  // (x ?*) - booleanized emptiness, returns true or false.\n  // x ?* y) - empty fallback, returns x itself or returns y if x is empty.\n  // (x ?* y z) - empty switch, returns y if x is not an empty value, returns z otherwise.\n  link(Null, '?*', operator(function (space, clause, that) {\n    var clist = clause && clause.$\n    if (!clist || !clist.length || clist.length < 2) {\n      return null // invalid call\n    }\n    var base = clist[0] === symbolSubject ? 3 : 2\n    if (thisCall(that, 'not-empty')) {\n      switch (clist.length - base) { // true logic\n        case 0:\n          return true\n        case 1:\n          return that\n        default:\n          return space instanceof Space$ ? evaluate(clist[base], space) : null\n      }\n    }\n    switch (clist.length - base) { // false logic\n      case 0:\n        return false\n      case 1:\n        return space instanceof Space$ ? evaluate(clist[base], space) : null\n      default:\n        return space instanceof Space$ ? evaluate(clist[base + 1], space) : null\n    }\n  }))\n\n  // Null Fallback\n  // (null ?? y z ...) returns the first non-null value after it if x is null.\n  link(Null, '??', operator(function (space, clause, that) {\n    if (!(space instanceof Space$)) {\n      return null\n    }\n    var clist = clause.$\n    var i = clist[0] === symbolSubject ? 3 : 2\n    for (; i < clist.length; i++) {\n      var value = evaluate(clist[i], space)\n      if (value !== null) {\n        return value\n      }\n    }\n    return null\n  }))\n\n  // (non-null ?? ...) return non-null.\n  link($Type.proto, '??', operator(function (space, clause, that) {\n    return that\n  }))\n\n  // Boolean value verification helpers.\n  link($Bool.proto, 'fails', operator(function (space, clause, that) {\n    return !that\n  }))\n  link($Bool.proto, 'succeeds', operator(function (space, clause, that) {\n    return !!that\n  }))\n}\n","'use strict'\n\nmodule.exports = function operator ($void) {\n  var $ = $void.$\n  var $Operator = $.operator\n  var operatorOf = $void.operatorOf\n  var staticOperator = $void.staticOperator\n\n  // create the operator to define an operator\n  staticOperator('=?', function (space, clause) {\n    return clause.$.length < 2 ? $Operator.noop : operatorOf(space, clause)\n  })\n}\n","'use strict'\n\nmodule.exports = function quote ($void) {\n  var staticOperator = $void.staticOperator\n\n  // pseudo explicit subject pattern operator '$'.\n  staticOperator('$', function () {\n    return null // It's implemented in evaluation function.\n  })\n\n  // pseudo explicit operation pattern operator ':'.\n  staticOperator(':', function () {\n    return null // It's implemented in evaluation function.\n  })\n}\n","'use strict'\n\nmodule.exports = function quote ($void) {\n  var $ = $void.$\n  var $Tuple = $.tuple\n  var $Symbol = $.symbol\n  var Tuple$ = $void.Tuple\n  var staticOperator = $void.staticOperator\n\n  // (` symbol), (` value) or (` (...))\n  staticOperator('`', function (space, clause) {\n    return clause.$.length > 1 ? clause.$[1] : $Symbol.empty\n  })\n\n  // (quote symbol-or-value ...)\n  staticOperator('quote', function (space, clause) {\n    return clause._quoted || (\n      clause._quoted = clause.$.length < 2 ? $Tuple.empty\n        : new Tuple$(clause.$.slice(1), false, clause.source)\n    )\n  })\n\n  // (unquote symbol-or-value ...)\n  staticOperator('unquote', function (space, clause) {\n    return clause._quoted || (\n      clause._quoted = clause.$.length < 2 ? $Tuple.blank\n        : new Tuple$(clause.$.slice(1), true, clause.source)\n    )\n  })\n}\n","'use strict'\n\nvar packageInfo = require('../../package.json')\n\nmodule.exports = function runtime ($void) {\n  var $ = $void.$\n  var $export = $void.export\n  var emptyObject = $.object.empty\n\n  var environment = Object.assign(Object.create(null), {\n    'runtime-core': 'js',\n    'runtime-host': $void.isNativeHost ? 'native' : 'browser',\n    'runtime-version': packageInfo.version,\n    'is-debugging': true,\n    'logging-level': 3\n  })\n\n  // this will be put into app space only.\n  $export($void, '$env', function (name, defaulue) {\n    return typeof name === 'undefined' || name === null\n      ? Object.assign(emptyObject(), environment)\n      : typeof name !== 'string' ? null\n        : typeof environment[name] !== 'undefined' ? environment[name]\n          : typeof defaulue !== 'undefined' ? defaulue : null\n  })\n\n  $void.env = function (name, value) {\n    return typeof value === 'undefined' ? environment[name]\n      : (environment[name] = value)\n  }\n\n  $void.runtime = function (name, value) {\n    name = 'runtime-' + name\n    return $void.env(name, value)\n  }\n}\n","'use strict'\n\nmodule.exports = function run ($void) {\n  var $ = $void.$\n  var compile = $.compile\n  var Tuple$ = $void.Tuple\n  var Symbol$ = $void.Symbol\n  var warn = $void.$warn\n  var $export = $void.export\n  var execute = $void.execute\n\n  // evaluate: a string, a symbol or a tuple in a separate space.\n  $export($, 'eval', function (expr) {\n    var code\n    if (typeof expr === 'string') {\n      // try to compile & evaluate\n      code = compile(expr)\n      if (!(code instanceof Tuple$)) {\n        warn('eval', 'invalid code', code)\n        return null\n      }\n    } else if (expr instanceof Tuple$) {\n      // evauate it\n      code = expr\n    } else if (expr instanceof Symbol$) {\n      // resolve it in global space.\n      code = new Tuple$([expr], true)\n    } else {\n      // a fix-point value.\n      return expr\n    }\n    try {\n      return execute(null, code)[0]\n    } catch (signal) { // any unexpected signal\n      if (code === expr) {\n        warn('eval', 'invalid call to', signal.id, 'for', code)\n      } else {\n        warn('eval', 'invalid call to', signal.id, 'for', code, 'of', expr)\n      }\n      return null\n    }\n  })\n}\n","'use strict'\n\nmodule.exports = function evaluate ($void) {\n  var $ = $void.$\n  var $Operator = $.operator\n  var Tuple$ = $void.Tuple\n  var Signal$ = $void.Signal\n  var Symbol$ = $void.Symbol\n  var warn = $void.$warn\n  var indexerOf = $void.indexerOf\n  var symbolPairing = $.symbol.pairing\n  var symbolSubject = $.symbol.subject\n  var staticOperators = $void.staticOperators\n\n  $void.evaluate = function evaluate (clause, space) {\n    if (!(clause instanceof Tuple$)) {\n      return clause instanceof Symbol$ ? space.resolve(clause.key) : clause\n    }\n    var clist = clause.$\n    var length = clist.length\n    if (length < 1) { // empty clause\n      return null\n    }\n    if (clause.plain) { // a plain expression list (code block)\n      var last = null\n      for (var i = 0; i < length; i++) {\n        last = evaluate(clist[i], space)\n      }\n      return last\n    }\n    // The subject and evaluation mode:\n    //  implicit: the subject will be invoked if it's a function\n    //  explicit: the subject keeps as a subject even it's a function.\n    var subject = clist[0]\n    var offset = 1\n    var implicitSubject = true // by default, use implicit mode.\n    if (subject instanceof Symbol$) {\n      if (subject === symbolSubject) { // switching to explicit mode.\n        switch (length) {\n          case 1:\n            return null // no subject.\n          case 2:\n            return evaluate(clist[1], space)\n          default:\n            subject = evaluate(clist[1], space)\n        }\n        offset = 2\n        implicitSubject = false // explicit mode\n      } else if (subject === symbolPairing) { // switching to explicit mode.\n        if (length < 2) {\n          return null // no predicate.\n        }\n        subject = evaluate(clist[1], space)\n        if (typeof subject !== 'function') {\n          return null // invalid operation\n        }\n        offset = 2\n      } else if (staticOperators[subject.key]) { // static operators\n        return staticOperators[subject.key](space, clause)\n      } else { // a common symbol\n        subject = space.resolve(subject.key)\n      }\n    } else if (subject instanceof Tuple$) { // a statement\n      subject = evaluate(subject, space)\n    } // else, the subject is a common value.\n\n    // switch subject to predicate if it's apppliable.\n    var predicate\n    if (typeof subject === 'function' && implicitSubject) {\n      if (subject.type === $Operator) {\n        return subject(space, clause)\n      }\n      predicate = subject\n      subject = null\n    } else {\n      predicate = null\n    }\n\n    // with only subject, apply evaluation to it.\n    if (offset >= length && predicate === null) {\n      return evaluate(subject, space) // explicitly calling this function.\n    }\n\n    var args = []\n    if (predicate === null) { // resolve the predicate if there is not.\n      predicate = clist[offset++]\n      if (predicate instanceof Tuple$) { // nested clause\n        predicate = evaluate(predicate, space)\n      }\n      // try to find a function as verb\n      if (predicate instanceof Symbol$) {\n        if (predicate.key === ':') {\n          predicate = indexerOf(subject) // explicitly calling the indexer\n        } else { // implicitly call the indexer\n          var indexer = indexerOf(subject)\n          predicate = indexer.get\n            ? indexer.get.call(subject, predicate.key)\n            : indexer.call(subject, predicate.key)\n          if (typeof predicate !== 'function') {\n            // interpret to getter if the result is not a function.\n            return typeof predicate === 'undefined' ? null : predicate\n          }\n        }\n      } else if (typeof predicate !== 'function') {\n        args.push(predicate)\n        predicate = indexerOf(subject)\n      }\n    }\n\n    // pass the original clause if the predicate is an operator.\n    if (predicate.type === $Operator) {\n      return predicate(space, clause, subject)\n    }\n\n    // evaluate arguments.\n    for (; offset < length; offset++) {\n      args.push(evaluate(clist[offset], space))\n    }\n\n    // evaluate the statement.\n    try {\n      var result = predicate.apply(subject, args)\n      return typeof result === 'undefined' ? null : result\n    } catch (signal) {\n      if (signal instanceof Signal$) {\n        throw signal\n      }\n      warn('evaluate', 'unknown signal:', signal, 'when evaluating', clause)\n      return null\n    }\n  }\n}\n","'use strict'\n\nmodule.exports = function execute ($void) {\n  var Signal$ = $void.Signal\n  var warn = $void.$warn\n  var evaluate = $void.evaluate\n  var createAppSpace = $void.createAppSpace\n  var createModuleSpace = $void.createModuleSpace\n\n  $void.execute = function execute (space, code, uri, args, appHome) {\n    var scope = appHome ? prepareAppSpace(uri, appHome) : createModuleSpace(uri, space)\n    scope.populate(args)\n    try {\n      return [evaluate(code, scope), scope]\n    } catch (signal) {\n      if (signal instanceof Signal$) {\n        if (signal.id === 'exit' || signal.id === 'return') {\n          return [signal.value, scope]\n        }\n        throw signal\n      }\n      warn('execute', 'unknown error:', signal,\n        'with', args, 'for', code, 'from', uri\n      )\n      return [null, null]\n    }\n  }\n\n  function prepareAppSpace (uri, appHome) {\n    var scope = $void.bootstrap\n    if (scope && scope['-app'] === uri) { // bootstrap app\n      if (scope.modules[uri]) { // re-run the bootstrap app\n        scope = createAppSpace(uri, appHome)\n      } // start to run bootstrap app\n    } else { // a new app\n      scope = createAppSpace(uri, appHome)\n    }\n    scope.modules[uri] = Object.assign(Object.create(null), {\n      status: 201,\n      exports: scope.exporting,\n      timestamp: Date.now()\n    })\n    return scope\n  }\n}\n","'use strict'\n\nmodule.exports = function function_ ($void) {\n  var $ = $void.$\n  var $Tuple = $.tuple\n  var $Symbol = $.symbol\n  var Tuple$ = $void.Tuple\n  var Signal$ = $void.Signal\n  var Symbol$ = $void.Symbol\n  var warn = $void.$warn\n  var lambda = $void.lambda\n  var stambda = $void.stambda\n  var constambda = $void.constambda\n  var evaluate_ = $void.evaluate\n  var function_ = $void.function\n  var ownsProperty = $void.ownsProperty\n  var createLambdaSpace = $void.createLambdaSpace\n  var createFunctionSpace = $void.createFunctionSpace\n  var createEmptyOperation = $void.createEmptyOperation\n\n  var alignWithGeneric = isFunctionLengthWritable()\n    ? alignWithGenericDefault\n    : alignWithGenericFallback\n\n  function evaluate (tbody, scope) {\n    var retval = evaluate_(tbody, scope)\n    return ownsProperty(scope.context, 'retval') ? scope.context.retval : retval\n  }\n\n  $void.lambdaOf = function lambdaOf (space, clause, offset) {\n    // compile code\n    var code = [$Symbol.lambda]\n    var params = formatParameters(clause.$[offset++], space)\n    code.push(params[1])\n    params = params[0]\n    var body = clause.$.slice(offset) || []\n    if (body.length > 0) {\n      var tbody = new Tuple$(body, true)\n      code.push(tbody)\n      return lambda(createLambda(\n        params, tbody, space.app, space.modules, space.local['-module']\n      ), new Tuple$(code))\n    } else {\n      code.push($Tuple.blank) // empty body\n      return params.length < 1 ? $.lambda.noop\n        : lambda(createEmptyOperation(), new Tuple$(code))\n    }\n  }\n\n  function createLambda (params, tbody, app, modules, module_) {\n    var createScope = createLambdaSpace.bind(null, app, modules, module_)\n    var $lambda = function () {\n      var scope = createScope()\n      // populate arguments\n      for (var i = 0; i < params.length; i++) {\n        scope.local[params[i]] = i < arguments.length ? arguments[i] : null\n      }\n      scope.prepare($lambda, this, Array.prototype.slice.call(arguments))\n      // execution\n      while (true) { // redo\n        try {\n          return evaluate(tbody, scope)\n        } catch (signal) {\n          if (signal instanceof Signal$) {\n            if (signal.id === 'redo') { // clear space context\n              scope = prepareToRedo(createScope(),\n                $lambda, this, params, signal.value, signal.count)\n              continue\n            } else if (signal.id !== 'exit') {\n              // return, break & continue if they're not in loop.\n              return signal.value\n            }\n            throw signal\n          }\n          warn('lambda:eval', 'unexpected error:', signal)\n          return null\n        }\n      }\n    }\n    return alignWithGeneric($lambda, params.length)\n  }\n\n  $void.staticLambdaOf = function staticLambdaOf (space, clause, offset) {\n    // compile code\n    var code = [$Symbol.stambda]\n    var params = formatParameters(clause.$[offset++], space, 1)\n    code.push(params[1])\n    params = params[0]\n    var body = clause.$.slice(offset) || []\n    if (body.length > 0) {\n      var tbody = new Tuple$(body, true)\n      code.push(tbody)\n      return (params.length > 0 ? stambda : constambda)(\n        createStaticLambda(params, tbody), new Tuple$(code)\n      )\n    } else {\n      code.push($Tuple.blank) // empty body\n      return params.length < 1 ? $.lambda.static\n        : constambda(createEmptyOperation(), new Tuple$(code))\n    }\n  }\n\n  function createStaticLambda (params, tbody) {\n    var key\n    if (params.length > 0) {\n      key = params[0]\n    }\n    var $stambda = function () {\n      var scope = createLambdaSpace()\n      // populate argument\n      if (key) {\n        key === 'this'\n          ? (scope.context.this = this)\n          : (scope.local[key] =\n            typeof arguments[0] === 'undefined' ? null : arguments[0]\n          )\n      }\n      // execution\n      try {\n        return evaluate(tbody, scope)\n      } catch (signal) {\n        if (signal instanceof Signal$) {\n          if (signal.id !== 'exit') {\n            // redo, return, break & continue if they're not in loop.\n            return signal.value\n          }\n          throw signal\n        }\n        warn('stambda:eval', 'unexpected error:', signal)\n        return null\n      }\n    }\n    if (key === 'this') {\n      return $stambda\n    }\n    $stambda = $stambda.bind(null)\n    $stambda.this = null\n    return alignWithGeneric($stambda, params.length)\n  }\n\n  $void.functionOf = function functionOf (space, clause, offset) {\n    // compile code\n    var code = [$Symbol.function]\n    var params = formatParameters(clause.$[offset++], space)\n    code.push(params[1])\n    params = params[0]\n    var body = clause.$.slice(offset) || []\n    if (body.length > 0) {\n      var tbody = new Tuple$(body, true)\n      code.push(tbody)\n      return function_(\n        createFunction(params, tbody, space.reserve()),\n        new Tuple$(code)\n      )\n    } else {\n      code.push($Tuple.blank) // empty body\n      return params.length < 1 ? $.function.noop\n        : function_(createEmptyOperation(), new Tuple$(code))\n    }\n  }\n\n  function createFunction (params, tbody, parent) {\n    var $func = function () {\n      var scope = createFunctionSpace(parent)\n      // populate arguments\n      for (var i = 0; i < params.length; i++) {\n        scope.local[params[i]] = i < arguments.length ? arguments[i] : null\n      }\n      scope.prepare($func, this, Array.prototype.slice.call(arguments))\n      // execution\n      while (true) { // redo\n        try {\n          return evaluate(tbody, scope)\n        } catch (signal) {\n          if (signal instanceof Signal$) {\n            if (signal.id === 'redo') { // clear space context\n              scope = prepareToRedo(createFunctionSpace(parent),\n                $func, this, params, signal.value, signal.count)\n              continue\n            } else if (signal.id !== 'exit') {\n              // return, break & continue if they're not in loop.\n              return signal.value\n            }\n            throw signal\n          } // for unexpected errors\n          warn('function:eval', 'unexpected error:', signal)\n          return null\n        }\n      }\n    }\n    return alignWithGeneric($func, params.length)\n  }\n\n  // to prepare a new context for redo\n  function prepareToRedo (scope, me, t, params, value, count) {\n    var args = count === 0 ? [] : count === 1 ? [value] : value\n    scope.prepare(me, t, args)\n    for (var i = 0; i < params.length; i++) {\n      scope.local[params[i]] = i < args.length ? args[i] : null\n    }\n    return scope\n  }\n\n  // accepts param, (param ...) or ((param default-value) ...)\n  // returns [params-list, code]\n  function formatParameters (params, space, maxArgs) {\n    if (params instanceof Symbol$) {\n      return [[params.key], new Tuple$([params])]\n    }\n    if (!(params instanceof Tuple$) || params.$.length < 1) {\n      return [[], $Tuple.empty]\n    }\n    params = params.$\n    maxArgs = maxArgs > 0\n      ? maxArgs > params.length ? params.length : maxArgs\n      : params.length\n    var args = []\n    var code = []\n    for (var i = 0; i < maxArgs; i++) {\n      var param = params[i]\n      if (param instanceof Symbol$) {\n        args.push(param.key)\n        code.push(param)\n      }\n    }\n    return args.length > 0 ? [args, new Tuple$(code)] : [[], $Tuple.empty]\n  }\n\n  function isFunctionLengthWritable () {\n    var func = function () {}\n    try {\n      Object.defineProperty(func, 'length', { value: 2 })\n      return true\n    } catch (err) {\n      // fortunately, this should only happen in IE, ...\n      if (err.number !== -2146823209) { // but if not, display its details.\n        warn('runtime/function', 'function\\'s length is not writable.', err)\n      }\n      return false\n    }\n  }\n\n  function alignWithGenericDefault (func, paramNo) {\n    return paramNo > 0 ? Object.defineProperties(func, {\n      length: {\n        value: paramNo\n      },\n      name: {\n        value: undefined\n      }\n    }) : Object.defineProperty(func, 'name', {\n      value: undefined\n    })\n  }\n\n  function alignWithGenericFallback (func, paramNo) {\n    func = alignParamNumber(func)\n    return !func.name ? func : Object.defineProperty(func, 'name', {\n      value: undefined\n    })\n  }\n\n  function alignParamNumber (func, paramNo) {\n    switch (paramNo) {\n      case 1: return function (a) { return func.apply(this, arguments) }\n      case 2: return function (a, b) { return func.apply(this, arguments) }\n      case 3: return function (a, b, c) { return func.apply(this, arguments) }\n      case 4: return function (a, b, c, d) {\n        return func.apply(this, arguments)\n      }\n      case 5: return function (a, b, c, d, e) {\n        return func.apply(this, arguments)\n      }\n      case 6: return function (a, b, c, d, e, f) {\n        return func.apply(this, arguments)\n      }\n      case 7: return function (a, b, c, d, e, f, g) {\n        return func.apply(this, arguments)\n      }\n      case 8: return function (a, b, c, d, e, f, g, h) {\n        return func.apply(this, arguments)\n      }\n      case 9: return function (a, b, c, d, e, f, g, h, i) {\n        return func.apply(this, arguments)\n      }\n      case 10: return function (a, b, c, d, e, f, g, h, i, j) {\n        return func.apply(this, arguments)\n      }\n      case 11: return function (a, b, c, d, e, f, g, h, i, j, k) {\n        return func.apply(this, arguments)\n      }\n      case 12: return function (a, b, c, d, e, f, g, h, i, j, k, l) {\n        return func.apply(this, arguments)\n      }\n      case 13: return function (a, b, c, d, e, f, g, h, i, j, k, l, m) {\n        return func.apply(this, arguments)\n      }\n      case 14: return function (a, b, c, d, e, f, g, h, i, j, k, l, m, n) {\n        return func.apply(this, arguments)\n      }\n      case 15: return function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) {\n        return func.apply(this, arguments)\n      }\n      case 16: return function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {\n        return func.apply(this, arguments)\n      }\n      default:\n        return func\n    }\n  }\n}\n","'use strict'\n\nmodule.exports = function interpreter ($void) {\n  var $ = $void.$\n  var compiler = $.compiler\n  var Signal$ = $void.Signal\n  var $export = $void.export\n  var evaluate = $void.evaluate\n  var isApplicable = $void.isApplicable\n  var atomicArrayOf = $void.atomicArrayOf\n  var createAppSpace = $void.createAppSpace\n\n  // interactively feed & evaluate\n  $export($void, '$interpreter', function (shell, args, appHome) {\n    if (!isApplicable(shell)) {\n      return null\n    }\n    // formalize arguments values to separate spaces.\n    args = Array.isArray(args) ? atomicArrayOf(args) : []\n    if (typeof appHome !== 'string' || appHome.length < 1) {\n      appHome = $void.runtime('home')\n    }\n    // create a module space.\n    var scope = createAppSpace(appHome + '/.') // to indicate a directory.\n    scope.populate(args)\n    // create compiler.\n    var compile = compiler(function (expr, status) {\n      if (status) {\n        shell.apply(null, [null, 'compiler:' + status].concat(\n          Array.prototype.slice.call(arguments, 2)))\n        return\n      }\n      var value = expr[0]\n      var src = expr[1]\n      try {\n        shell(evaluate(value, scope))\n      } catch (signal) {\n        if (signal instanceof Signal$) {\n          if (signal.id === 'return') {\n            shell(signal.value)\n          } else if (signal.id === 'exit') {\n            shell(signal.value, 'exiting')\n          } else {\n            shell(null, 'warning', 'invalid call to ' + signal.id, [value, src])\n          }\n        } else {\n          shell(null, 'warning', 'unexpected error in evaluation', [signal, value, src])\n        }\n      }\n    })\n\n    return function interpret (text) {\n      if (typeof text === 'string') {\n        return compile(text) // push input into compiler\n      } else {\n        return compile() // reset status.\n      }\n    }\n  })\n}\n","'use strict'\n\nmodule.exports = function operators$operator ($void) {\n  var $ = $void.$\n  var $Tuple = $.tuple\n  var $Symbol = $.symbol\n  var Tuple$ = $void.Tuple\n  var Space$ = $void.Space\n  var Symbol$ = $void.Symbol\n  var evaluate = $void.evaluate\n  var operator = $void.operator\n  var symbolPairing = $Symbol.pairing\n  var symbolSubject = $Symbol.subject\n  var createOperatorSpace = $void.createOperatorSpace\n  var createEmptyOperation = $void.createEmptyOperation\n\n  $void.operatorOf = function operatorOf (space, clause) {\n    // compile code\n    var code = [$Symbol.operator]\n    var params = formatOperands(clause.$[1])\n    code.push(params[1])\n    params = params[0]\n    var body = clause.$.slice(2) || []\n    if (body.length > 0) {\n      markOperatorClause(body)\n      var tbody = new Tuple$(body, true)\n      code.push(tbody)\n      return operator(createOperator(params, tbody, space.local), new Tuple$(code))\n    } else {\n      code.push($Tuple.blank) // empty body\n      return params.length < 1 ? $.operator.noop\n        : operator(createEmptyOperation(), new Tuple$(code))\n    }\n  }\n\n  function markOperatorClause (statement) {\n    for (var i = 0; i < statement.length; i++) {\n      var expr = statement[i]\n      if (expr instanceof Tuple$ && expr.$.length > 0) {\n        expr.inop = true\n        markOperatorClause(expr.$)\n      }\n    }\n  }\n\n  function createOperator (params, tbody, origin) {\n    return function (space, clause, that) {\n      if (!(space instanceof Space$)) {\n        return null // invalid call.\n      }\n      // populate operands\n      var clist = clause.$\n      var offset = typeof that !== 'undefined'\n        ? clist[0] === symbolSubject ? 3 : 2\n        : clist[0] === symbolPairing ? 2 : 1\n      var scope = createOperatorSpace(space, origin)\n      for (var i = 0; i < params.length; i++) {\n        var j = i + offset\n        scope.context[params[i]] = j < clist.length ? clist[j] : null\n      }\n      scope.prepareOp(clause, offset, that)\n      return evaluate(tbody, scope)\n    }\n  }\n\n  // accepts operand or (operand ...)\n  // returns [operand-list, code]\n  function formatOperands (params) {\n    if (params instanceof Symbol$) {\n      return [[params.key], new Tuple$([params])]\n    }\n    if (!(params instanceof Tuple$) || params.$.length < 1) {\n      return [[], $Tuple.empty]\n    }\n    var oprs = []\n    var code = []\n    params = params.$\n    for (var i = 0; i < params.length; i++) {\n      var param = params[i]\n      if (param instanceof Symbol$) {\n        oprs.push(param.key)\n        code.push(param)\n      }\n    }\n    return oprs.length < 1 ? [[], $Tuple.empty] : [oprs, new Tuple$(code)]\n  }\n}\n","'use strict'\n\nmodule.exports = function run ($void) {\n  var $ = $void.$\n  var compile = $.compile\n  var Tuple$ = $void.Tuple\n  var warn = $void.$warn\n  var $export = $void.export\n  var execute = $void.execute\n  var completeFile = $void.completeFile\n  var atomicArrayOf = $void.atomicArrayOf\n\n  // run a module from source as an application.\n  $export($void, '$run', function (appSource, args, appHome) {\n    if (typeof appSource !== 'string') {\n      return null\n    }\n    // formalize arguments values to separate spaces.\n    args = Array.isArray(args) ? atomicArrayOf(args) : []\n    // try to resolve the base uri of the whole application\n    if (typeof appHome !== 'string' || appHome.length < 1) {\n      appHome = $void.$env('home')\n    }\n    // try to resolve the uri for source\n    var loader = $void.loader\n    appSource = completeFile(appSource)\n    var uri = loader.resolve(appSource, [\n      appHome, $void.runtime('home')\n    ])\n    if (typeof uri !== 'string') {\n      warn('run', 'failed to resolve source for', uri)\n      return null\n    }\n    // try to load file\n    var doc = loader.load(uri)\n    var text = doc[0]\n    if (!text) {\n      warn('run', 'failed to read source', appSource, 'for', doc[1])\n      return null\n    }\n    // compile text\n    var code = compile(text, uri, doc[1])\n    if (!(code instanceof Tuple$)) {\n      warn('run', 'compiler warnings:', code)\n      return null\n    }\n    try {\n      return execute(null, code, uri, args, appHome)[0]\n    } catch (signal) {\n      warn('run', 'invalid call to', signal.id,\n        'in', text, 'from', uri, 'with', args)\n      return null\n    }\n  })\n}\n","'use strict'\n\nmodule.exports = function ($void) {\n  var Signal$ = $void.Signal\n  var evaluate = $void.evaluate\n\n  $void.signalOf = function $signalOf (type) {\n    return function (space, clause) {\n      var clist = clause.$\n      var length = clist.length\n      if (length < 2) {\n        throw new Signal$(type, 0, null)\n      }\n      if (length === 2) {\n        throw new Signal$(type, 1, evaluate(clist[1], space))\n      }\n      var result = []\n      var i\n      for (i = 1; i < length; i++) {\n        result.push(evaluate(clist[i], space))\n      }\n      throw new Signal$(type, i - 1, result)\n    }\n  }\n}\n","'use strict'\n\nmodule.exports = function ($void) {\n  // the signal object to be used in control flow.\n  $void.Signal = function Signal$ (id, count, value) {\n    this.id = id\n    this.count = count\n    this.value = value\n  }\n}\n","'use strict'\n\nmodule.exports = function space ($void) {\n  var $ = $void.$\n  var $Object = $.object\n  var ClassInst$ = $void.ClassInst\n  var isObject = $void.isObject\n  var indexerOf = $void.indexerOf\n  var defineConst = $void.defineConst\n  var ownsProperty = $void.ownsProperty\n\n  // shared empty array\n  var EmptyArray = Object.freeze([])\n\n  var atomOf = $.tuple['atom-of']\n  // to be used for safely separating spaces.\n  $void.atomicArrayOf = function (src) {\n    var values = []\n    for (var i = 0; i < src.length; i++) {\n      values.push(atomOf(src[i]))\n    }\n    return values\n  }\n\n  $void.Space = Space$\n  function Space$ (local, locals, context, export_) {\n    this.local = local\n    this.context = context || Object.create(local)\n    if (locals) {\n      this.locals = locals\n    }\n    if (export_) {\n      this.exporting = export_\n    }\n  }\n  Space$.prototype = Object.assign(Object.create(null), {\n    resolve: function (key) {\n      var value = $[key]\n      if (typeof value !== 'undefined') {\n        return value\n      }\n      value = this.context[key]\n      if (typeof value !== 'undefined') {\n        return value\n      }\n      var this_ = this.context.this\n      return typeof this_ === 'undefined' || this_ === null ? null\n        : indexerOf(this_).call(this_, key)\n    },\n    $resolve: function (key) {\n      return typeof $[key] === 'undefined' ? null : $[key]\n    },\n    var: function (key, value) {\n      return (this.local[key] = value)\n    },\n    const: function (key, value) {\n      return defineConst(this.local, key, value)\n    },\n    lvar: function (key, value) {\n      return (this.context[key] = value)\n    },\n    lconst: function (key, value) {\n      return defineConst(this.context, key, value)\n    },\n    let: function (key, value) {\n      if (ownsProperty(this.local, key)) {\n        return (this.local[key] = value)\n      }\n      if (this.locals) {\n        for (var i = this.locals.length - 1; i >= 0; i--) {\n          if (ownsProperty(this.locals[i], key)) {\n            return (this.locals[i][key] = value)\n          }\n        }\n      }\n      var this_ = this.context.this\n      if (isObject(this_) && (ownsProperty(this_, key) || (\n        (this_ instanceof ClassInst$) && key !== 'type' &&\n        ownsProperty(this_.type.proto, key)\n      ))) {\n        // auto field assignment only works for an existing field of an object.\n        return indexerOf(this_).call(this_, key, value)\n      }\n      return (this.local[key] = value)\n    },\n    export: function (key, value) {\n      this.exporting && typeof this.exporting[key] === 'undefined' &&\n        (this.exporting[key] = value)\n      return this.var(key, value)\n    },\n    populate: function (ctx) {\n      if (Array.isArray(ctx)) {\n        this.context.arguments = ctx.length < 1 ? EmptyArray\n          : Object.isFrozen(ctx) ? ctx : Object.freeze(ctx)\n        return\n      }\n      if (ctx === null || typeof ctx !== 'object') {\n        return\n      }\n\n      var keys = Object.getOwnPropertyNames(ctx)\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i]\n        switch (key) {\n          case 'this':\n            this.context.this = ctx.this\n            break\n          case 'arguments':\n            if (Array.isArray(ctx.arguments)) {\n              this.context.arguments = ctx.arguments.length < 1 ? EmptyArray\n                : Object.isFrozen(ctx.arguments) ? ctx.arguments\n                  : Object.freeze(ctx.arguments.slice())\n            }\n            break\n          default:\n            this.local[key] = ctx[key]\n        }\n      }\n    },\n    prepare: function (do_, this_, args) {\n      this.context.do = do_\n      this.context.this = typeof this_ === 'undefined' ? null : this_\n      this.context.arguments = args.length < 1\n        ? EmptyArray : Object.freeze(args)\n    },\n    prepareOp: function (operation, operand, that) {\n      this.context.operation = operation\n      this.context.operand = operand\n      this.context.that = typeof that !== 'undefined' ? that : null\n    },\n    reserve: function () {\n      return this._reserved || (\n        this._reserved = {\n          local: this.local,\n          locals: this.locals,\n          app: this.app,\n          modules: this.modules\n        }\n      )\n    },\n    bindOperators: function () {\n      // convert operators to internal helper functions\n      $void.bindOperatorFetch(this)\n      $void.bindOperatorImport(this)\n      $void.bindOperatorLoad(this)\n    }\n  })\n\n  $void.createAppSpace = function (uri, home) {\n    var app = Object.create($)\n    app['-app'] = uri\n    app['-app-dir'] = $void.loader.dir(uri)\n    app['-app-home'] = home || app['-app-dir']\n    app.env = $void.$env\n    app.run = $void.$run\n    app.interpreter = $void.$interpreter\n    app.warn = $void.$warn\n    app.print = $void.$print\n    app.printf = $void.$printf\n    app.espress = $void.$espress\n    app.timer = $void.$timer\n\n    var local = Object.create(app)\n    local['-module'] = uri\n    local['-module-dir'] = $void.loader.dir(uri)\n\n    var exporting = Object.create($Object.proto)\n    var space = new Space$(local, null, null, exporting)\n    space.app = app\n    space.modules = Object.create(null)\n    space.export = function (key, value) {\n      if (typeof exporting[key] === 'undefined') {\n        app[key] = value\n        exporting[key] = value\n      }\n      return space.var(key, value)\n    }\n    return space\n  }\n\n  // a bootstrap app space can be used to fetch app's dependencies.\n  $void.createBootstrapSpace = function (appUri) {\n    var bootstrap = $void.bootstrap = $void.createAppSpace(appUri)\n    bootstrap.bindOperators()\n    return bootstrap\n  }\n\n  $void.createModuleSpace = function (uri, appSpace) {\n    var app = appSpace && appSpace.app\n    var local = Object.create(app || $)\n    local['-module'] = uri || ''\n    if (uri && $void.loader.isResolved(uri)) {\n      local['-module-dir'] = $void.loader.dir(uri)\n    }\n    var export_ = Object.create($Object.proto)\n    var space = new Space$(local, null, null, export_)\n    if (app) {\n      space.app = app\n      space.modules = appSpace.modules\n    }\n    return space\n  }\n\n  $void.createLambdaSpace = function (app, modules, module_) {\n    var space\n    if (app) {\n      space = new Space$(Object.create(app))\n      space.app = app\n      space.modules = modules\n    } else {\n      space = new Space$(Object.create($))\n    }\n    if (module_) {\n      space.local['-module'] = module_ || ''\n      space.local['-module-dir'] = module_ ? $void.loader.dir(module_) : ''\n    }\n    return space\n  }\n\n  $void.createFunctionSpace = function (parent) {\n    var space = new Space$(Object.create(parent.local),\n      parent.locals ? parent.locals.concat(parent.local) : [parent.local]\n    )\n    if (parent.app) {\n      space.app = parent.app\n      space.modules = parent.modules\n    }\n    return space\n  }\n\n  // customized the behaviour of the space of an operator\n  $void.OperatorSpace = OperatorSpace$\n  function OperatorSpace$ (parent, origin) {\n    // the original context is preferred over global.\n    this.$ = origin\n    // operator context is accessible to the context of calling function.\n    this.context = Object.create(parent.context)\n    // use the same local of calling function.\n    this.local = parent.local\n    if (parent.locals) {\n      this.locals = parent.locals\n    }\n    // reserve app\n    if (parent.app) {\n      this.app = parent.app\n      this.modules = parent.modules\n    }\n  }\n  OperatorSpace$.prototype = Object.assign(Object.create(Space$.prototype), {\n    inop: true, // indicates this is an operator space.\n    $resolve: function (key) {\n      // global entities are not overridable\n      return typeof $[key] !== 'undefined' ? $[key]\n        : typeof this.$[key] === 'undefined' ? null : this.$[key]\n    }\n  })\n\n  $void.createOperatorSpace = function (parent, origin) {\n    return new OperatorSpace$(parent, origin)\n  }\n}\n","'use strict'\n\nfunction initializeSpace ($void) {\n  require('./generic/void')($void)\n  require('./generic/encoding')($void)\n\n  require('./generic/null')($void)\n  require('./generic/type')($void)\n\n  require('./generic/bool')($void)\n  require('./generic/string')($void)\n  require('./generic/number')($void)\n  require('./generic/date')($void)\n  require('./generic/range')($void)\n\n  require('./generic/symbol')($void)\n  require('./generic/tuple')($void)\n\n  require('./generic/operator')($void)\n  require('./generic/lambda')($void)\n  require('./generic/function')($void)\n\n  require('./generic/iterator')($void)\n  require('./generic/promise')($void)\n\n  require('./generic/array')($void)\n  require('./generic/object')($void)\n  require('./generic/class')($void)\n\n  require('./generic/global')($void)\n}\n\nfunction initializeLib ($void, stdout) {\n  require('./lib/stdout')($void, stdout)\n  require('./lib/format')($void)\n  require('./lib/math')($void)\n  require('./lib/uri')($void)\n  require('./lib/json')($void)\n  require('./lib/emitter')($void)\n  require('./lib/timer')($void)\n  require('./lib/espress')($void)\n}\n\nfunction initializeRuntime ($void) {\n  require('./runtime/env')($void)\n  require('./runtime/signal')($void)\n  require('./runtime/space')($void)\n  require('./runtime/evaluate')($void)\n  require('./runtime/signal-of')($void)\n  require('./runtime/function')($void)\n  require('./runtime/operator')($void)\n\n  require('./runtime/execute')($void)\n  require('./runtime/eval')($void)\n\n  require('./runtime/run')($void)\n  require('./runtime/interpreter')($void)\n}\n\nfunction initializeOperators ($void) {\n  require('./operators/pattern')($void)\n  require('./operators/quote')($void)\n\n  require('./operators/assignment')($void)\n  require('./operators/control')($void)\n\n  require('./operators/general')($void)\n  require('./operators/logical')($void)\n  require('./operators/bitwise')($void)\n  require('./operators/arithmetic')($void)\n\n  require('./operators/literal')($void)\n  require('./operators/function')($void)\n  require('./operators/operator')($void)\n\n  require('./operators/import')($void)\n  require('./operators/load')($void)\n  require('./operators/fetch')($void)\n}\n\nmodule.exports = function start (stdout) {\n  // Hello, world.\n  var $void = require('./generic/genesis')()\n\n  // create generic type system\n  initializeSpace($void)\n\n  // prepare primary lib\n  initializeLib($void, stdout($void))\n\n  // prepare tokenizer & compiler\n  require('./tokenizer')($void)\n  require('./compiler')($void)\n\n  // assemble runtime functions\n  initializeRuntime($void)\n\n  // assemble & publish operators\n  initializeOperators($void)\n\n  return $void\n}\n","'use strict'\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var symbolOf = $.symbol.of\n  var intValueOf = $.number['parse-int']\n  var strUnescape = $.string.unescape\n  var warn = $void.$warn\n  var $export = $void.export\n  var isApplicable = $void.isApplicable\n\n  var Constants = $void.constantValues\n  var RegexDecimal = $void.regexDecimal\n  var RegexSpecialSymbol = $void.regexSpecialSymbol\n\n  var tokenizer = $export($, 'tokenizer', function (parse, srcUri) {\n    if (!isApplicable(parse)) {\n      return $.tokenize\n    }\n\n    var srcText = ''\n    if (!srcUri || typeof srcUri !== 'string') {\n      srcUri = ''\n    }\n\n    var lineNo, lineOffset, lastChar, spacing, indenting, clauseIndent\n    var waiter, pendingText, pendingLine, pendingOffset, pendingIndent\n    var escaping, stringPadding\n    resumeParsing() // initialize context\n\n    function resumeParsing () {\n      // general states\n      lineNo = 0\n      lineOffset = 0\n      lastChar = null\n      spacing = false\n      indenting = 0\n      clauseIndent = 0\n      // escaping states\n      waiter = null\n      pendingText = ''\n      pendingLine = 0\n      pendingOffset = 0\n      pendingIndent = -1\n      escaping = false\n      stringPadding = -1\n    }\n\n    var singleQuoteWaiter = createStringWaiter(\"'\", 'format')\n    var doubleQuoteWaiter = createStringWaiter('\"')\n\n    return function tokenizing (text) {\n      if (typeof text !== 'string') {\n        srcText = ''\n        waiter && waiter() // finalize pending action\n        resumeParsing() // clear parsing context\n        return false // indicate a reset happened.\n      }\n      srcText = text\n      // start parsing\n      for (var i = 0; i < text.length; i++) {\n        var c = text[i]\n        if (!waiter || !waiter(c)) {\n          processChar(c)\n        }\n        finalizeChar(c)\n      }\n      return true // keep waiting more code\n    }\n\n    function processChar (c) {\n      switch (c) {\n        case '(':\n          parse('punctuation', c, [clauseIndent, lineNo, lineOffset])\n          clauseIndent = -1 // clear beginning indent\n          break\n        case ')':\n          parse('punctuation', c, [indenting, lineNo, lineOffset])\n          break\n        case '\\\\': // force to start a symbol.\n          escaping = true\n          beginSymbol('')\n          break\n        case '`':\n        case '@':\n        case ':':\n        case '$':\n        case ',': // logical separator\n        case ';': // line-closing\n        case '[': // reserved as annotation block beginning.\n        case ']': // reserved as annotation block.\n        case '{': // reserved as block punctuation\n        case '}': // reserved as block punctuation\n          parse('symbol', symbolOf(c), [indenting, lineNo, lineOffset])\n          break\n        case \"'\":\n          // always use double quote internally.\n          beginWaiting('\"', singleQuoteWaiter)\n          break\n        case '\"':\n          beginWaiting('\"', doubleQuoteWaiter)\n          break\n        case '#':\n          beginWaiting('', commentWaiter)\n          break\n        case ' ':\n        case '\\t': // It may spoil well foramtted code.\n          processWhitespace(c)\n          break\n        default:\n          beginSymbol(c)\n          break\n      }\n    }\n\n    function finalizeChar (c) {\n      lastChar = c\n      spacing = !waiter && /[\\s]/.test(c)\n      if (c !== ' ' && c !== '\\t') {\n        indenting = -1\n      }\n      if (c === '\\n') {\n        lineNo += 1\n        lineOffset = indenting = clauseIndent = 0\n      } else {\n        lineOffset += 1\n      }\n    }\n\n    function beginWaiting (c, stateWaiter) {\n      waiter = stateWaiter\n      pendingText = c\n      pendingLine = lineNo\n      pendingOffset = lineOffset\n      pendingIndent = indenting\n    }\n\n    function processWhitespace (c) {\n      if (indenting < 0) {\n        return raiseSpace(c)\n      }\n      if (c === '\\t') {\n        warn('tokenizer', 'TAB-space is not suggested in indention.',\n          [srcUri || srcText, lineNo, lineOffset, indenting])\n      }\n      clauseIndent = ++indenting\n    }\n\n    function createStringWaiter (quote, tokenType) {\n      function raiseValue () {\n        parse(tokenType || 'value', strUnescape(pendingText + '\"'),\n          [pendingIndent, pendingLine, pendingOffset, lineNo, lineOffset])\n        waiter = null\n        return true\n      }\n\n      return function (c) {\n        if (typeof c === 'undefined') { // unexpected ending\n          warn('tokenizer', 'a string value is not properly closed.',\n            [srcUri || srcText, lineNo, lineOffset, pendingLine, pendingOffset])\n          return raiseValue()\n        }\n        if (c === '\\r') { // skip '\\r' anyway\n          return true\n        }\n        if (c === '\\n') { // multiline string.\n          if (escaping) { // trailing escaping char indicates to keep the '\\n'\n            pendingText += 'n'\n            stringPadding = 1 // use the new-line as space padding.\n            escaping = false\n          } else if (stringPadding < 0) {\n            stringPadding = 0 // turn on space padding\n          }\n          return true\n        }\n        if (/[\\s]/.test(c)) {\n          if (stringPadding >= 0) { // padding or padded\n            if (stringPadding === 0) { // pading\n              if (pendingText.length > 1) { // avoid a leading whitespace\n                pendingText += ' ' // keeps the first space character.\n              }\n              stringPadding = 1\n            }\n            return true\n          }\n          // fallback to common string logic\n        } else {\n          stringPadding = -1 // turn off string padding\n        }\n        if (escaping) { // common escaping\n          pendingText += c\n          escaping = false\n          return true\n        }\n        if (c === quote) {\n          return raiseValue()\n        }\n        pendingText += quote === \"'\" && c === '\"' ? '\\\\' + c : c\n        if (c === '\\\\') {\n          escaping = true\n        }\n        return true\n      }\n    }\n\n    function raiseSpace (c) {\n      if (!spacing || c === '\\n') { // only raise once for common spaces, but\n        // raise every new-line in case parser giving it special meanings.\n        parse('space', c, [indenting, lineNo, lineOffset])\n      }\n    }\n\n    function commentWaiter (c) {\n      if (typeof c === 'undefined' || c === '\\n') {\n        parse('comment', pendingText,\n          [pendingIndent, pendingLine, pendingOffset, lineNo, lineOffset])\n        waiter = null\n      } else if (pendingText.length < 1 && c === '(') {\n        pendingText = '('\n        waiter = blockCommentWaiter // upgrade to block comment\n      } else {\n        pendingText += c\n      }\n      return c !== '\\n'\n    }\n\n    function blockCommentWaiter (c) {\n      if (c) {\n        if (lastChar !== ')' || c !== '#') {\n          pendingText += c\n          return true\n        } // else, normal ending\n      } else {\n        pendingText += ')'\n        warn('tokenizer', 'a block comment is not properly closed.',\n          [srcUri || srcText, lineNo, lineOffset, pendingLine, pendingOffset])\n      }\n      parse('comment', pendingText,\n        [pendingIndent, pendingLine, pendingOffset, lineNo, lineOffset])\n      waiter = null\n      return true\n    }\n\n    function beginSymbol (c) {\n      /[\\s]/.test(c) ? raiseSpace(c) // report space once.\n        : beginWaiting(c, symbolWaiter)\n    }\n\n    function symbolWaiter (c) {\n      if (c && escaping) {\n        pendingText += c\n        escaping = false\n        return true\n      }\n      if (c === '\\\\') {\n        escaping = true\n        return true\n      }\n      if (c && !RegexSpecialSymbol.test(c)) {\n        pendingText += c\n        return true\n      }\n      raiseSymbol()\n      escaping = false\n      waiter = null\n      return false // return the char to tokenizer.\n    }\n\n    function raiseSymbol () {\n      var type, value\n      if (typeof Constants[pendingText] !== 'undefined') { // a constant value\n        value = Constants[pendingText]\n      } else if (RegexDecimal.test(pendingText)) { // a decimal number\n        value = /(\\.|e|E|^-0$)/.test(pendingText)\n          ? parseFloat(pendingText) : intValueOf(pendingText)\n      } else if (pendingText.startsWith('0')) { // a special integer number\n        value = intValueOf(pendingText)\n      } else { // a common symbol\n        type = 'symbol'\n        value = symbolOf(pendingText)\n      }\n      parse(type || 'value', value,\n        [pendingIndent, pendingLine, pendingOffset, lineNo, lineOffset - 1])\n    }\n  })\n\n  // a helper function to tokenize a piece of text.\n  $export($, 'tokenize', function (text) {\n    var tokens = []\n    var tokenizing = tokenizer(function collector () {\n      tokens.push(Array.prototype.slice.call(arguments))\n    })\n    tokenizing(text)\n    tokenizing() // notify the end of stream.\n    return tokens\n  })\n}\n","'use strict'\n\nvar KeyPrefix = '/es/loaded:'\nvar KeyVersion = KeyPrefix + 'version:'\n\nfunction createStore (localStorage) {\n  function enumKeys () {\n    var keys = []\n    for (var i = 0, len = localStorage.length; i < len; i++) {\n      var key = localStorage.key(i)\n      if (key.startsWith(KeyPrefix)) {\n        keys.push(localStorage.key(i))\n      }\n    }\n    return keys\n  }\n  return {\n    keys: enumKeys,\n    getItem: localStorage.getItem.bind(localStorage),\n    setItem: localStorage.setItem.bind(localStorage),\n    removeItem: localStorage.removeItem.bind(localStorage),\n    clear: function () {\n      var keys = enumKeys()\n      for (var i = 0, len = keys.length; i < len; i++) {\n        localStorage.removeItem(keys[i])\n      }\n      return keys\n    }\n  }\n}\n\nfunction tryGlobal () {\n  return typeof window === 'undefined' ? null\n    : window.localStorage ? createStore(window.localStorage) : useMemory()\n}\n\nfunction tryModule () {\n  if (typeof window !== 'undefined') {\n    return null\n  }\n  try {\n    // optional dependency\n    var LocalStorage = require('node-localstorage').LocalStorage\n    return createStore(new LocalStorage('./.es/loaded'))\n  } catch (err) {\n    return null\n  }\n}\n\nfunction useMemory () {\n  var store = Object.create(null)\n  return {\n    keys: function () {\n      return Object.getOwnPropertyNames(store)\n    },\n    getItem: function (key) {\n      return store[key] || null\n    },\n    setItem: function (key, value) {\n      store[key] = value\n    },\n    removeItem: function (key) {\n      delete store[key]\n    },\n    clear: function () {\n      store = Object.create(null)\n    }\n  }\n}\n\nfunction keyOf (uri) {\n  return typeof uri === 'string' && uri ? KeyPrefix + uri : null\n}\n\nfunction versionKeyOf (uri) {\n  return typeof uri === 'string' && uri ? KeyVersion + uri : null\n}\n\nfunction generateTimestamp (version) {\n  return 'local:' + Math.trunc(Date.now() / 600 / 1000)\n}\n\nmodule.exports = function (inStorage) {\n  var store = inStorage ? tryGlobal() || tryModule() || useMemory()\n    : useMemory()\n\n  return {\n    store: { // management API\n      list: function (filter) {\n        var uris = []\n        var keys = store.keys()\n        for (var i = 0; i < keys.length; i++) {\n          if (keys[i].startsWith(KeyVersion)) {\n            if (typeof filter !== 'string' || keys[i].indexOf(filter) > 0) {\n              uris.push([keys[i].substring(KeyVersion.length), store.getItem(keys[i])])\n            }\n          }\n        }\n        return uris\n      },\n      read: function (uri) {\n        var keys = store.keys()\n        for (var i = 0; i < keys.length; i++) {\n          if (keys[i].startsWith(KeyVersion)) {\n            if (typeof uri !== 'string' || keys[i].indexOf(uri) > 0) {\n              return store.getItem(keyOf(keys[i].substring(KeyVersion.length)))\n            }\n          }\n        }\n      },\n      reset: function (filter) {\n        var counter = 0\n        var keys = store.keys()\n        for (var i = 0; i < keys.length; i++) {\n          if (keys[i].startsWith(KeyVersion)) {\n            if (typeof filter !== 'string' || keys[i].indexOf(filter) > 0) {\n              counter++\n              store.removeItem(keys[i])\n              store.removeItem(keyOf(keys[i].substring(KeyVersion.length)))\n            }\n          }\n        }\n        return counter\n      },\n      clear: function () {\n        store.clear()\n        return true\n      }\n    },\n\n    get: function (uri) {\n      var key = keyOf(uri)\n      return key ? store.getItem(key) : null\n    },\n    ver: function (uri) {\n      var key = versionKeyOf(uri)\n      return key ? store.getItem(key) : null\n    },\n    isTimestamp: function (version) {\n      return version.startsWith('local:')\n    },\n    isExpired: function (version) {\n      return version !== generateTimestamp()\n    },\n    set: function (uri, value, version) {\n      if (typeof value !== 'string') {\n        return null // invalid call.\n      }\n      var key = keyOf(uri)\n      var verKey = versionKeyOf(uri)\n      if (!key || !verKey) {\n        return null // invalid call.\n      }\n      if (typeof version !== 'string' || !key) {\n        version = generateTimestamp()\n      }\n      store.setItem(key, value)\n      store.setItem(verKey, version)\n      return version\n    }\n  }\n}\n","'use strict'\n\nvar axios = require('axios')\nvar cache = require('./loader-cache')(true)\n\nfunction isResolved (url) {\n  return /^(http[s]?:\\/\\/)/i.test(url)\n}\n\nfunction join (base, path) {\n  while (base.charAt(base.length - 1) === '/') {\n    base = base.substring(0, base.length - 1)\n  }\n  while (path.charAt(0) === '/') {\n    base = base.substring(1)\n  }\n  var origin = base.indexOf('://');\n  (origin > 0) && (origin += 3)\n  while (path.startsWith('./') || path.startsWith('../')) {\n    if (path.charAt(1) === '/') {\n      path = path.substring(2) // skipping leading ./\n    } else {\n      path = path.substring(3)\n      var offset = base.lastIndexOf('/')\n      while (base.charAt(offset - 1) === '/') {\n        offset--\n      }\n      if (offset > origin) {\n        base = base.substring(0, offset)\n      }\n    }\n  }\n  return base + '/' + path\n}\n\nfunction getHostUrl (moduleUri) {\n  var offset = moduleUri ? moduleUri.indexOf('://') : 0\n  return offset > 0\n    ? moduleUri.substring(0, moduleUri.indexOf('/', offset + 3))\n    : typeof window === 'undefined' ? 'http://localhost'\n      : window.location.origin\n}\n\nfunction getBaseUrl (moduleUri) {\n  return moduleUri && moduleUri.indexOf('://') > 0 ? moduleUri\n    : typeof window === 'undefined' ? 'http://localhost'\n      : window.location.origin + window.location.pathname\n}\n\nfunction allowNotModified (status) {\n  return (status >= 200 && status < 300) || status === 304\n}\n\nfunction generateConfig (version) {\n  return !version || cache.isTimestamp(version) ? null : {\n    validateStatus: allowNotModified,\n    headers: {\n      'If-None-Match': version\n    }\n  }\n}\n\nfunction notCached (url, dirs) {\n  return [404, 'Not Cached', dirs ? [url, dirs] : [url]]\n}\n\nfunction responseError (url, response) {\n  return [response.status, response.statusText, [url]]\n}\n\nfunction responseUnavailable (url, error) {\n  return [503, 'Response Unavailable', [url, error]]\n}\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var $Promise = $.promise\n  var promiseOfResolved = $Promise['of-resolved']\n\n  var proxy = axios.create({\n    timeout: 30000,\n    transformResponse: undefined,\n    responseType: 'text',\n    keepAlive: 'timeout=10, max=1000'\n  })\n\n  return {\n    cache: cache, // for mgmt. purpose only.\n\n    dir: function (url) {\n      var offset = url.lastIndexOf('/')\n      return offset === 0 ? '/'\n        : offset > 0 ? url.substring(0, offset) : ''\n    },\n    isResolved: isResolved,\n    resolve: function (source, dirs) {\n      if (isResolved(source)) {\n        return source\n      }\n      if (dirs.length <= 0) {\n        dirs = [source.startsWith('/') ? getHostUrl() : getBaseUrl()]\n      }\n      if (dirs.length === 1) {\n        return join(dirs[0], source)\n      }\n      for (var i = 0; i < dirs.length; i++) {\n        var url = join(dirs[i], source)\n        if (cache.ver(url)) {\n          return url\n        }\n      }\n      return notCached(source, dirs)\n    },\n    load: function (url) {\n      var data = cache.get(url)\n      return data ? [data, cache.ver(url)] : [null, notCached(url)]\n    },\n    fetch: function (url) {\n      var version = cache.ver(url)\n      return !cache.isExpired(version) ? promiseOfResolved(url)\n        : $Promise.of(function (async) {\n          proxy.get(url,\n            generateConfig(version)\n          ).then(function (response) {\n            if (response.status !== 304) {\n              cache.set(url, response.data, response.headers['etag'])\n            }\n            async.resolve(url)\n          }).catch(function (error) {\n            async.reject(error.response\n              ? responseError(url, error.response)\n              : responseUnavailable(url, error)\n            )\n          })\n        })\n    }\n  }\n}\n","'use strict'\n\nvar httpLoader = require('./loader-http')\n\nfunction localLoader ($void, http) {\n  var fileLoader = require('./loader-fs')\n  var fs = fileLoader($void)\n\n  return {\n    cache: http.cache,\n    fsCache: fs.cache,\n\n    dir: fs.dir,\n    isResolved: function (uri) {\n      return fs.isResolved(uri) || http.isResolved(uri)\n    },\n    resolve: function (path, dirs) {\n      return http.isResolved(path) || fs.isResolved(path) ? path\n        : dirs && dirs.length > 0 && http.isResolved(dirs[0])\n          ? http.resolve(path, dirs)\n          : fs.resolve(path, dirs)\n    },\n    load: function (uri) {\n      return http.isResolved(uri) ? http.load(uri) : fs.load(uri)\n    },\n    fetch: function (uri) {\n      return http.isResolved(uri) ? http.fetch(uri) : fs.fetch(uri)\n    }\n  }\n}\n\nmodule.exports = function ($void) {\n  var http = httpLoader($void)\n  return typeof window === 'undefined' ? localLoader($void, http) : http\n}\n","'use strict'\n\nvar records = module.exports = []\nvar JS = global || window\n\n/* functions are ported from MDN */\nif (typeof Object.assign !== 'function') {\n  records.push('Object.assign')\n\n  JS.Object.assign = function (target) {\n    if (typeof target === 'undefined' || target === null) {\n      return null\n    }\n    var output = Object(target)\n    for (var index = 1; index < arguments.length; index++) {\n      var source = arguments[index]\n      if (typeof source !== 'undefined' && source !== null) {\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            output[key] = source[key]\n          }\n        }\n      }\n    }\n    return output\n  }\n}\n\nif (typeof Object.create !== 'function') {\n  records.push('Object.create')\n\n  JS.Object.create = (function () {\n    var Temp = function () {}\n    return function (prototype) {\n      if (prototype === null) {\n        prototype = {}\n      } else if (prototype !== Object(prototype)) {\n        return null\n      }\n      Temp.prototype = prototype\n      var result = new Temp()\n      Temp.prototype = null\n      return result\n    }\n  })()\n}\n\nif (typeof Object.is !== 'function') {\n  records.push('Object.is')\n\n  JS.Object.is = function (x, y) {\n    if (x === y) {\n      return x !== 0 || 1 / x === 1 / y\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y // eslint-disable-line no-self-compare\n    }\n  }\n}\n\nif (typeof Object.getOwnPropertyNames !== 'function') {\n  records.push('Object.getOwnPropertyNames')\n\n  JS.Object.getOwnPropertyNames = function (obj) {\n    var names = []\n    for (var name in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, name)) {\n        names.push(name)\n      }\n    }\n    return names\n  }\n}\n\nif (typeof Object.freeze !== 'function') {\n  records.push('Object.freeze')\n\n  JS.Object.freeze = function (obj) {\n    obj && typeof obj === 'object' && (obj.__es_frozen = true)\n    return obj\n  }\n}\n\nif (typeof Object.isFrozen !== 'function') {\n  records.push('Object.isFrozen')\n\n  JS.Object.isFrozen = function (obj) {\n    return obj ? obj.__es_frozen === true : false\n  }\n}\n\nif (typeof String.prototype.startsWith !== 'function') {\n  records.push('String.prototype.startsWith')\n\n  JS.String.prototype.startsWith = function (searchString, position) {\n    position = position || 0\n    return this.substr(position, searchString.length) === searchString\n  }\n}\n\nif (typeof String.prototype.endsWith !== 'function') {\n  records.push('String.prototype.endsWith')\n\n  JS.String.prototype.endsWith = function (searchString, position) {\n    var subjectString = this.toString()\n    if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {\n      position = subjectString.length\n    }\n    position -= searchString.length\n    var lastIndex = subjectString.indexOf(searchString, position)\n    return lastIndex !== -1 && lastIndex === position\n  }\n}\n\nif (typeof String.prototype.trim !== 'function') {\n  records.push('String.prototype.trim')\n\n  JS.String.prototype.trim = function () {\n    return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '')\n  }\n}\n\nif (typeof String.prototype.trimLeft !== 'function') {\n  records.push('String.prototype.trimLeft')\n\n  JS.String.prototype.trimLeft = function () {\n    return this.replace(/^[\\s\\uFEFF\\xA0]+/g, '')\n  }\n}\n\nif (typeof String.prototype.trimRight !== 'function') {\n  records.push('String.prototype.trimRight')\n\n  JS.String.prototype.trimRight = function () {\n    return this.replace(/[\\s\\uFEFF\\xA0]+$/g, '')\n  }\n}\n\nif (typeof Array.isArray !== 'function') {\n  records.push('Array.isArray')\n\n  JS.Array.isArray = function (arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]'\n  }\n}\n\nif (typeof Number.isInteger !== 'function') {\n  records.push('Number.isInteger')\n\n  JS.Number.isInteger = function (value) {\n    return typeof value === 'number' &&\n      isFinite(value) &&\n      Math.floor(value) === value\n  }\n}\n\nif (typeof Number.MAX_SAFE_INTEGER !== 'number') {\n  records.push('Number.MAX_SAFE_INTEGER')\n\n  JS.Number.MAX_SAFE_INTEGER = (Math.pow(2, 53) - 1)\n}\n\nif (typeof Number.MIN_SAFE_INTEGER !== 'number') {\n  records.push('Number.MIN_SAFE_INTEGER')\n\n  JS.Number.MIN_SAFE_INTEGER = -(Math.pow(2, 53) - 1)\n}\n\nif (typeof Number.isSafeInteger !== 'function') {\n  records.push('Number.isSafeInteger')\n\n  JS.Number.isSafeInteger = function (value) {\n    return Number.isInteger(value) &&\n      value >= Number.MIN_SAFE_INTEGER &&\n      value <= Number.MAX_SAFE_INTEGER\n  }\n}\n\nif (typeof Date.now !== 'function') {\n  records.push('Date.now')\n\n  JS.Date.now = function () {\n    return (new Date()).getTime()\n  }\n}\n\nif (typeof Math.trunc !== 'function') {\n  records.push('Math.trunc')\n\n  JS.Math.trunc = function (x) {\n    return isNaN(x) || Number.isInteger(x) ? x\n      : x > 0 ? Math.floor(x) : Math.ceil(x)\n  }\n}\n\nif (typeof Math.log2 !== 'function') {\n  records.push('Math.log2')\n\n  JS.Math.log2 = function (x) {\n    return Math.log(x) * Math.LOG2E\n  }\n}\n\nif (typeof Math.log10 !== 'function') {\n  records.push('Math.log10')\n\n  JS.Math.log10 = function (x) {\n    return Math.log(x) * Math.LOG10E\n  }\n}\n\nif (typeof console !== 'object') {\n  records.push('console.log')\n  records.push('console.warn')\n\n  JS.console = {\n    log: function () {},\n    warn: function () {}\n  }\n}\n","'use strict'\n\nmodule.exports = function ($void, reader, proc) {\n  var $ = $void.$\n  var typeOf = $.type.of\n  var warn = $void.$warn\n  var print = $void.$print\n  var printf = $void.$printf\n  var thisCall = $void.thisCall\n\n  var $shell = $void.$shell = {}\n\n  return function agent (args, echo, profile) {\n    var echoing = false\n    if (typeof echo !== 'function') {\n      echo = print.bind(null, '=')\n    }\n    if (typeof profile !== 'string' || !profile) {\n      profile = '(var * (load \"profile\"))'\n    }\n\n    function exit () {\n      print('See you again.')\n      reader.close()\n      return proc.exit(0)\n    }\n\n    // create the interpreter\n    function typeInfoOf (prefix, value) {\n      var info = '#(' + prefix + thisCall(typeOf(value), 'to-string')\n      var name = !value ? ''\n        : typeof value.name === 'string' ? value.name\n          : ''\n      return name ? info + ': ' + name + ')# ' : info + ')# '\n    }\n\n    function format (value, prefix) {\n      return typeInfoOf(prefix || '', value) + thisCall(value, 'to-string')\n    }\n\n    function resolve (value) {\n      if (!(value instanceof Promise)) {\n        return echo(format(value))\n      }\n      echo('#(promise: waiting ...)#')\n      value.then(function (result) {\n        echo(format(result, '... result: '))\n      }, function (err) {\n        echo(format(err, '... excuse: '))\n      })\n    }\n\n    function explain (status) {\n      status === 'exiting' ? echo(exit())\n        : warn.apply(null, Array.prototype.slice.call(arguments, 1))\n    }\n\n    var interpret = $void.$interpreter(function (value, status) {\n      if (status) {\n        explain(status)\n      } else if (echoing) {\n        resolve(value)\n      }\n    }, args, proc.env('PWD'))\n\n    // display version.\n    interpret('(run \"tools/version\")\\n')\n\n    // expose local loader cache.\n    printf('# shell object', 'gray'); printf(' .loader', 'yellow')\n    $shell['.loader'] = $void.loader.cache.store\n\n    printf(', and', 'gray')\n    printf(' functions', 'gray'); printf(' .echo', 'blue')\n    //  toggle on/of the printing of evaluation result.\n    $shell['.echo'] = function echo () {\n      echoing = !echoing\n      if (echoing) {\n        return true\n      }\n      printf('  ') // this is only visible on console.\n      return printf('#(bool)# false\\n', 'gray')\n    }\n\n    printf(',', 'gray'); printf(' .debug', 'blue')\n    //  display, enable or disable debug output.\n    $shell['.debug'] = function debug (enabled) {\n      var isDebugging = $void.env('is-debugging')\n      return typeof enabled === 'undefined' ? isDebugging\n        : $void.env('is-debugging',\n          enabled !== null && enabled !== 0 && enabled !== false\n        )\n    }\n\n    printf(' and', 'gray'); printf(' .logging', 'blue')\n    //  display or update logging level.\n    $shell['.logging'] = function logging (level) {\n      var loggingLevel = $void.env('logging-level')\n      return typeof level !== 'number' ? loggingLevel\n        : $void.env('logging-level', (level >>= 0) < 0 ? 0\n          : level > 127 ? 127 : level\n        )\n    }\n    printf(' are imported.\\n', 'gray')\n\n    // initialize shell environment\n    interpret('(var * (import \"$shell\"))\\n')\n    interpret(profile + '\\n')\n    echoing = true\n\n    // waiting for input\n    reader.prompt()\n    reader.on('line', function (input) {\n      interpret(input)\n      var depth = interpret('\\n')\n      reader.prompt(depth > 1 ? '..' : '> ')\n    })\n  }\n}\n","'use strict'\n\nvar render, isIE\nif (typeof window === 'undefined') {\n  render = require('colors/safe')\n  isIE = false\n} else {\n  render = null\n  isIE = /MSIE \\d|Trident.*rv:/.test(navigator.userAgent)\n}\n\nvar styleClasses = Object.assign(Object.create(null), {\n  red: 'color',\n  green: 'color',\n  blue: 'color',\n  yellow: 'color',\n  grey: 'color',\n  gray: 'color',\n  underline: 'text-decoration'\n})\n\nfunction formatterOf (props) {\n  return render ? function format (text) {\n    for (var key in props) {\n      var value = props[key]\n      text = render[value](text)\n    }\n    return text\n  } : null\n}\n\nfunction applyClass (cls) {\n  var values = cls.split(/\\s/)\n  var props = {}\n  var enabled = false\n  for (var i = 0; i < values.length; i++) {\n    var value = values[i]\n    if (styleClasses[value]) {\n      enabled = true\n      props[styleClasses[value]] = value\n    }\n  }\n  return enabled && formatterOf(props)\n}\n\nfunction applyStyle (obj) {\n  var props = {}\n  var enabled = false\n  for (var key in obj) {\n    var value = obj[key]\n    if (styleClasses[value] === key) {\n      enabled = true\n      props[key] = value\n    }\n  }\n  return enabled && formatterOf(props)\n}\n\nvar bindToConsole = isIE ? function (method, prompt) {\n  return function () {\n    var args = Array.prototype.slice.call(arguments)\n    args.unshift(prompt)\n    console[method].apply(console, args)\n  }\n} : function (method, prompt) {\n  return console[method].bind(console, prompt)\n}\n\nmodule.exports = function ($void, tracing) {\n  var $ = $void.$\n  var stringOf = $.string.of\n\n  const write = tracing || typeof window !== 'undefined' ? null\n    : function (text) {\n      process.stdout.write(text)\n      return text\n    }\n\n  function formatArgs () {\n    var strings = []\n    for (var i = 0; i < arguments.length; i++) {\n      strings.push(stringOf(arguments[i]))\n    }\n    return strings.join(' ')\n  }\n\n  function bindTo (method, type, color) {\n    var log = !console[method]\n      ? bindToConsole('log', '#' + type)\n      : $void.isNativeHost\n        ? bindToConsole(method, render.gray('#' + type))\n        : bindToConsole(method, '#')\n\n    return $void.isNativeHost ? function () {\n      var text = formatArgs.apply(null, arguments)\n      log(color ? color(text) : text)\n      return text\n    } : function () {\n      log.apply(null, arguments)\n      return formatArgs.apply(null, arguments)\n    }\n  }\n\n  // default native output methods\n  return {\n    print: function () {\n      var text = formatArgs.apply(null, arguments)\n      !tracing && console.log(text)\n      return text\n    },\n    printf: function (value, format) {\n      var text = formatArgs(value)\n      if (write) {\n        var formatted = null\n        if (format && render) {\n          var formatter = typeof format === 'string' ? applyClass(format)\n            : typeof format === 'object' ? applyStyle(format) : null\n          formatted = formatter ? formatter(text) : text\n        }\n        write(formatted || text)\n      }\n      return text\n    },\n    // by default, write logs to js console even in tracing mode (web browser).\n    verbose: bindTo('info', 'V', render && render.gray),\n    info: bindTo('info', 'I', render && render.gray),\n    warn: bindTo('warn', 'W', render && render.yellow),\n    error: bindTo('error', 'E', render && render.red),\n    debug: bindTo('debug', 'D', render && render.blue)\n  }\n}\n","'use strict'\n\nmodule.exports = function ($void) {\n  // a loader can fully control the importing process of a native module.\n  var loaders = []\n\n  function loadDefault (moduleUri) {\n    switch (moduleUri) {\n      case 'io':\n        return require('./io')\n      case 'restful':\n        return require('./restful')\n      case 'shell':\n        return require('./shell')\n      case 'symbols':\n        return require('./symbols')\n      case 'window':\n        return require('./window')\n      default:\n        return null\n    }\n  }\n\n  function $require (moduleUri, baseUri) {\n    var importing = loadDefault(moduleUri)\n    if (importing) {\n      return importing\n    }\n    // latest loader has higher priority.\n    for (var i = loaders.length - 1; i >= 0; i--) {\n      importing = loaders[i](moduleUri, baseUri, $void)\n      if (typeof importing === 'function') {\n        return importing\n      }\n    }\n    return null\n  }\n\n  function register (loader) {\n    if (typeof loader === 'function') {\n      loaders.unshift(loader)\n      return loader\n    }\n    return null\n  }\n\n  function unregister (loader) {\n    for (var i = loaders.length - 1; i >= 0; i--) {\n      if (loaders[i] === loader) {\n        loaders.splice(i, 1)\n        return loader\n      }\n    }\n    return null\n  }\n\n  function copy (exporting, source, context) {\n    context._generic = source // mostly reserved for future.\n    $void.safelyAssign(exporting, source)\n    return exporting\n  }\n\n  function use (targetUri, module_, profile) {\n    return register(function loader (moduleUri) {\n      return moduleUri !== targetUri ? null\n        // generate a default importing-all function for a native module.\n        : function importing (exporting, context, $void) {\n          copy(exporting, module_, context)\n          return true\n        }\n    })\n  }\n\n  $require.register = register\n  $require.unregister = unregister\n  $require.copy = copy\n  $require.use = use\n\n  return $require\n}\n","'use strict'\n\nmodule.exports = function (exporting, context, $void) {\n  // to expose all native io members.\n  Object.assign(exporting, $void.$io)\n  return true\n}\n","'use strict'\n\nvar axios = require('axios')\n\nvar AxiosMethods = [\n  'request', 'options', 'head', 'get', 'post', 'put', 'patch', 'delete'\n]\n\nfunction bind (agent, service) {\n  for (var i = 0; i < AxiosMethods.length; i++) {\n    var method = AxiosMethods[i]\n    agent[method] = service[method].bind(service)\n  }\n  return agent\n}\n\nmodule.exports = function (exporting, context, $void) {\n  var $ = $void.$\n  var $Object = $.object\n\n  // export operations on default instance.\n  bind(exporting, axios)\n\n  // create a service instance with a particular configuration set.\n  exporting.of = function (config) {\n    if (!config || typeof config !== 'object') {\n      config = $Object.empty()\n    }\n    return bind($Object.of({ config: config }), axios.create(config))\n  }\n\n  return true\n}\n","'use strict'\n\nmodule.exports = function (exporting, context, $void) {\n  // to connect global shell commands with app space.\n  Object.assign(exporting, $void.$shell)\n  return true\n}\n","'use strict'\n\nvar proc = typeof window === 'undefined' ? global.process : {\n  // a fake process object for web browser.\n  platform: 'browser',\n  env: {\n    'DISPLAY': window.navigator.userAgent\n  }\n}\nvar os = proc.platform\n\nmodule.exports = function (exporting) {\n  // define special indicator characters.\n  if (os === 'win32') {\n    exporting.passed = '\\u221a '\n    exporting.failed = '\\u00d7 '\n    exporting.pending = '~ '\n  } else if (os === 'darwin' || proc.env['DISPLAY']) {\n    exporting.passed = '✓ '\n    exporting.failed = '✘ '\n    exporting.pending = '\\u22EF '\n  } else { // *nix without X.\n    exporting.passed = '= '\n    exporting.failed = 'x '\n    exporting.pending = '~ '\n  }\n  // it always succeeds.\n  return true\n}\n","'use strict'\n\nmodule.exports = function (exporting, context, $void) {\n  if (typeof window === 'undefined') {\n    $void.$warn('module/window', 'window object is missing')\n  } else {\n    $void.safelyAssign(exporting, window)\n  }\n  return true\n}\n","module.exports = require('./lib/axios');","'use strict';\n\nvar utils = require('./../utils');\nvar settle = require('./../core/settle');\nvar buildURL = require('./../helpers/buildURL');\nvar parseHeaders = require('./../helpers/parseHeaders');\nvar isURLSameOrigin = require('./../helpers/isURLSameOrigin');\nvar createError = require('../core/createError');\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    // Listen for ready state\n    request.onreadystatechange = function handleLoad() {\n      if (!request || request.readyState !== 4) {\n        return;\n      }\n\n      // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      }\n\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(createError('Request aborted', config, 'ECONNABORTED', request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      var cookies = require('./../helpers/cookies');\n\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?\n        cookies.read(config.xsrfCookieName) :\n        undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (config.withCredentials) {\n      request.withCredentials = true;\n    }\n\n    // Add responseType to request if needed\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.\n        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.\n        if (config.responseType !== 'json') {\n          throw e;\n        }\n      }\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (requestData === undefined) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n","'use strict';\n\nvar utils = require('./utils');\nvar bind = require('./helpers/bind');\nvar Axios = require('./core/Axios');\nvar mergeConfig = require('./core/mergeConfig');\nvar defaults = require('./defaults');\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(mergeConfig(axios.defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = require('./cancel/Cancel');\naxios.CancelToken = require('./cancel/CancelToken');\naxios.isCancel = require('./cancel/isCancel');\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = require('./helpers/spread');\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n","'use strict';\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n","'use strict';\n\nvar Cancel = require('./Cancel');\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n","'use strict';\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar buildURL = require('../helpers/buildURL');\nvar InterceptorManager = require('./InterceptorManager');\nvar dispatchRequest = require('./dispatchRequest');\nvar mergeConfig = require('./mergeConfig');\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = arguments[1] || {};\n    config.url = arguments[0];\n  } else {\n    config = config || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n  config.method = config.method ? config.method.toLowerCase() : 'get';\n\n  // Hook up interceptors middleware\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n","'use strict';\n\nvar enhanceError = require('./enhanceError');\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar transformData = require('./transformData');\nvar isCancel = require('../cancel/isCancel');\nvar defaults = require('../defaults');\nvar isAbsoluteURL = require('./../helpers/isAbsoluteURL');\nvar combineURLs = require('./../helpers/combineURLs');\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Support baseURL config\n  if (config.baseURL && !isAbsoluteURL(config.url)) {\n    config.url = combineURLs(config.baseURL, config.url);\n  }\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData(\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers || {}\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData(\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData(\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n","'use strict';\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n\n  error.toJSON = function() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code\n    };\n  };\n  return error;\n};\n","'use strict';\n\nvar utils = require('../utils');\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  utils.forEach(['url', 'method', 'params', 'data'], function valueFromConfig2(prop) {\n    if (typeof config2[prop] !== 'undefined') {\n      config[prop] = config2[prop];\n    }\n  });\n\n  utils.forEach(['headers', 'auth', 'proxy'], function mergeDeepProperties(prop) {\n    if (utils.isObject(config2[prop])) {\n      config[prop] = utils.deepMerge(config1[prop], config2[prop]);\n    } else if (typeof config2[prop] !== 'undefined') {\n      config[prop] = config2[prop];\n    } else if (utils.isObject(config1[prop])) {\n      config[prop] = utils.deepMerge(config1[prop]);\n    } else if (typeof config1[prop] !== 'undefined') {\n      config[prop] = config1[prop];\n    }\n  });\n\n  utils.forEach([\n    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',\n    'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',\n    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'maxContentLength',\n    'validateStatus', 'maxRedirects', 'httpAgent', 'httpsAgent', 'cancelToken',\n    'socketPath'\n  ], function defaultToConfig2(prop) {\n    if (typeof config2[prop] !== 'undefined') {\n      config[prop] = config2[prop];\n    } else if (typeof config1[prop] !== 'undefined') {\n      config[prop] = config1[prop];\n    }\n  });\n\n  return config;\n};\n","'use strict';\n\nvar createError = require('./createError');\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n};\n","'use strict';\n\nvar utils = require('./utils');\nvar normalizeHeaderName = require('./helpers/normalizeHeaderName');\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  // Only Node.JS has a process variable that is of [[Class]] process\n  if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = require('./adapters/http');\n  } else if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = require('./adapters/xhr');\n  }\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) { /* Ignore */ }\n    }\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n","'use strict';\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%40/gi, '@').\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n","'use strict';\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n","'use strict';\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n        // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n","'use strict';\n\nvar utils = require('../utils');\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n","'use strict';\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n","'use strict';\n\nvar bind = require('./helpers/bind');\nvar isBuffer = require('is-buffer');\n\n/*global toString:true*/\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (typeof result[key] === 'object' && typeof val === 'object') {\n      result[key] = merge(result[key], val);\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Function equal to merge with the difference being that no reference\n * to original objects is kept.\n *\n * @see merge\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction deepMerge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (typeof result[key] === 'object' && typeof val === 'object') {\n      result[key] = deepMerge(result[key], val);\n    } else if (typeof val === 'object') {\n      result[key] = deepMerge({}, val);\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  deepMerge: deepMerge,\n  extend: extend,\n  trim: trim\n};\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","'use strict'\n\nvar symbols = Object.create(null)\nrequire('../modules/symbols')(symbols)\n\nmodule.exports = function ($void) {\n  var $ = $void.$\n  var print = $void.$print\n  var printf = $void.$printf\n\n  // provide a field to print for testing purpose\n  ;(print.bound || print).nativeField = true\n\n  var printInColor = function (color) {\n    return function (text) {\n      printf(text + '\\n', color)\n    }\n  }\n\n  var red = printInColor('red')\n  var gray = printInColor('gray')\n  var green = printInColor('green')\n\n  var signPassed = function () {\n    printf('    ' + symbols.passed + '[PASSED] ', 'green')\n  }\n  var signFailed = function () {\n    printf('    ' + symbols.failed + '[FAILED] ', 'red')\n  }\n\n  var passing = 0\n  var failing = []\n\n  return function () {\n    // check native environment\n    print('\\n  Checking JavaScript environment')\n    checkJavascript()\n    checkPolyfill()\n\n    // check espresso runtime.\n    checkRuntime()\n\n    // start to report result\n    green('\\n  passing: ' + passing)\n    if (failing.length < 1) {\n      green('\\n  Espresso is ready to run.\\n')\n      return true\n    }\n\n    // print failures\n    red('  failing: ' + failing.length)\n    print('\\n  There might be some issues to prevent running Espresso')\n    for (var i = 0; i < failing.length; i++) {\n      red('  - ' + failing[i])\n    }\n    print()\n    return false\n  }\n\n  function passed (feature) {\n    passing += 1\n    signPassed(); gray(feature)\n  }\n\n  function failed (feature) {\n    failing.push(feature)\n    signFailed(); red(feature)\n  }\n\n  function checkJavascript () {\n    passed('JS is using the space of ' + (global ? 'global.' : 'window.'));\n    (typeof Promise === 'undefined' ? failed : passed)('Promise');\n    (typeof Object.defineProperty !== 'function' ? failed : passed)('Object.defineProperty')\n  }\n\n  function checkPolyfill () {\n    var polyfill = require('../lib/polyfill')\n    if (polyfill.length > 0) {\n      passed('Espresso is using some polyfill functions:')\n      var padding = '      - '\n      gray(padding + polyfill.join('\\n' + padding))\n    } else {\n      green('      Congratulations! Espresso does not need any polyfill.')\n    }\n  }\n\n  function checkRuntime () {\n    print('\\n  Checking Espresso Runtime ...')\n    checkObjects($void, '[Void / Null] ', [\n      'null'\n    ])\n\n    checkFunctions($void, '[Void / constructors] ', [\n      // genesis\n      'Type', 'Date', 'Range', 'Symbol', 'Tuple',\n      'Iterator', 'Promise',\n      'Object', 'ClassType',\n      // runtime\n      'Signal', 'Space', 'OperatorSpace'\n    ])\n\n    checkFunctions($void, '[Void / functions] ', [\n      // genesis\n      'operator', 'lambda', 'function',\n      // runtime\n      'createAppSpace', 'createModuleSpace',\n      'createLambdaSpace', 'createFunctionSpace', 'createOperatorSpace',\n      'signalOf',\n      'lambdaOf', 'functionOf', 'operatorOf',\n      'evaluate', 'execute'\n    ])\n\n    checkStaticOperators('[void / operators] ', [\n      '`', 'quote', 'unquote',\n      'export', 'var', 'let', 'const', 'local', 'locon',\n      '?', 'if', 'while', 'in', 'for', 'break', 'continue',\n      '+', '++', '--', '!', 'not', '~',\n      '@', '=?', '=', '->', '=>', 'redo', 'return', 'exit',\n      'import', 'load', 'fetch',\n      'debug', 'log'\n    ])\n\n    checkObjects($, '[Espresso / types] ', [\n      'type',\n      'bool', 'string', 'number', 'date', 'range',\n      'symbol', 'tuple',\n      'operator', 'lambda', 'function',\n      'iterator', 'promise',\n      'array', 'object', 'class'\n    ])\n\n    checkFunctions($, '[Espresso / functions] ', [\n      // generic\n      'commit', 'commit*', 'commit?',\n      // runtime\n      'eval',\n      // bootstrap\n      'tokenizer', 'tokenize', 'compiler', 'compile'\n    ])\n\n    checkFunctions($void, '[Espresso / functions] ', [\n      // runtime\n      '$env', '$run', '$interpreter'\n    ])\n\n    checkFunctions($, '[Espresso / lib / functions] ', [\n      'max', 'min'\n    ])\n\n    checkFunctions($void, '[Espresso / lib / app-only functions] ', [\n      '$print', '$printf', '$warn', '$espress'\n    ])\n\n    checkObjects($, '[Espresso / lib / objects] ', [\n      'uri', 'math', 'json'\n    ])\n\n    checkObjects($, '[Espresso / lib / classes] ', [\n      'emitter'\n    ])\n\n    checkObjects($void, '[Espresso / lib / classes] ', [\n      '$timer'\n    ])\n\n    // bootstrap tests\n    checkTypeOf()\n    checkIndexerOf()\n\n    checkTypes()\n    checkAssignment()\n    checkOperators()\n    checkControl()\n    checkOperations()\n  }\n\n  function checkObjects ($, group, names) {\n    print('\\n  -', group)\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i]\n      if (typeof $[name] === 'object') {\n        passed(name)\n      } else {\n        failed(group + name)\n      }\n    }\n  }\n\n  function checkFunctions ($, group, names) {\n    print('\\n  -', group)\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i]\n      if (typeof $[name] === 'function') {\n        passed(name)\n      } else {\n        failed(group + name)\n      }\n    }\n  }\n\n  function checkStaticOperators (group, names) {\n    print('\\n  -', group)\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i]\n      if (typeof $void.staticOperators[name] === 'function') {\n        passed(name)\n      } else {\n        failed(group + name)\n      }\n    }\n  }\n\n  function check (feature, result, error) {\n    result ? passed(feature) : failed(error ? feature + ' - ' + error : feature)\n  }\n\n  function checkTypeOf () {\n    print('\\n  - Static type-of')\n    var typeOf = $.type.of\n\n    check('[undefined]', typeOf() === null)\n    check('null', typeOf(null) === null)\n\n    check('bool', typeOf(true) === $.bool)\n    check('string', typeOf('') === $.string)\n    check('number', typeOf(1) === $.number)\n    check('date', typeOf($.date.empty) === $.date)\n    check('range', typeOf($.range.empty) === $.range)\n    check('symbol', typeOf($.symbol.empty) === $.symbol)\n    check('tuple', typeOf($.tuple.empty) === $.tuple)\n\n    check('operator', typeOf($.operator.empty()) === $.operator)\n    check('lambda', typeOf($.lambda.noop) === $.lambda)\n    check('stambda', typeOf($.lambda.static) === $.lambda)\n    check('function', typeOf($.function.empty()) === $.function)\n    check('function (generic)', typeOf(function () {}) === $.function)\n\n    check('iterator', typeOf($.iterator.empty) === $.iterator)\n    check('promise', typeOf($.promise.empty) === $.promise)\n\n    check('array', typeOf($.array.empty()) === $.array)\n    check('array (generic)', typeOf([]) === $.array)\n\n    check('object', typeOf($.object.empty()) === $.object)\n    check('object (generic)', typeOf({}) === $.object)\n\n    check('class', typeOf($.class.empty()) === $.class)\n  }\n\n  function checkIndexerOf () {\n    print('\\n  - Static indexer-of')\n    var indexerOf = $void.indexerOf\n\n    check('undefined', indexerOf() === $void.null[':'])\n    check('null', indexerOf(null) === $void.null[':'])\n    check('type', indexerOf($.type) === $.type[':'])\n\n    check('bool', indexerOf($.bool) === $.bool[':'])\n    check('bool: true', indexerOf(true) === $.bool.proto[':'])\n    check('bool: false', indexerOf(false) === $.bool.proto[':'])\n\n    check('string', indexerOf($.string) === $.string[':'])\n    check('string: empty', indexerOf('') === $.string.proto[':'])\n\n    check('number', indexerOf($.number) === $.number[':'])\n    check('number: 0', indexerOf(0) === $.number.proto[':'])\n\n    check('date', indexerOf($.date) === $.date[':'])\n    check('date: empty', indexerOf($.date.empty) === $.date.proto[':'])\n\n    check('range', indexerOf($.range) === $.range[':'])\n    check('range: empty', indexerOf($.range.empty) === $.range.proto[':'])\n\n    check('symbol', indexerOf($.symbol) === $.symbol[':'])\n    check('symbol: empty', indexerOf($.symbol.empty) === $.symbol.proto[':'])\n\n    check('operator', indexerOf($.operator) === $.operator[':'])\n    check('operator.empty', indexerOf($.operator.empty()) === $.operator.proto[':'])\n\n    check('lambda', indexerOf($.lambda) === $.lambda[':'])\n    check('lambda: empty', indexerOf($.lambda.empty()) === $.lambda.proto[':'])\n\n    check('function', indexerOf($.function) === $.function[':'])\n    check('function: empty', indexerOf($.function.empty()) === $.function.proto[':'])\n    check('function: generic', indexerOf(function () {}) === $.function.proto[':'])\n\n    check('array', indexerOf($.iterator.empty) === $.iterator.proto[':'])\n    check('array', indexerOf($.promise.empty) === $.promise.proto[':'])\n\n    check('array', indexerOf($.array) === $.array[':'])\n    check('array: empty', indexerOf($.array.empty()) === $.array.proto[':'])\n    check('array: generic', indexerOf([]) === $.array.proto[':'])\n\n    check('object', indexerOf($.object) === $.object[':'])\n    check('object: empty', indexerOf($.object.empty()) === $.object.proto[':'])\n    check('object: generic', indexerOf({}) === $.object.proto[':'])\n  }\n\n  function eval_ (expected, expr, desc) {\n    var result = $.eval(expr)\n    var success = typeof expected === 'function' ? expected(result) : Object.is(result, expected)\n    check(expr || desc, success, success || 'evaluated to a value of ' +\n      (typeof result) + ': ' + (result ? result.toString() : result))\n  }\n\n  function checkTypes () {\n    print('\\n  - Primary Types')\n    eval_(null, '', '<empty>')\n    eval_(null, '()')\n    eval_(null, 'null')\n\n    eval_($.type, 'type')\n\n    eval_($.bool, 'bool')\n    eval_(true, 'true')\n    eval_(false, 'false')\n\n    eval_($.string, 'string')\n    eval_($.string.empty, '\"\"')\n    eval_('ABC', '\"ABC\"')\n    eval_('ABC', '(\"ABC\")')\n    eval_(3, '(\"ABC\" length)')\n    eval_('ABCDEF', '(\"ABC\" + \"DEF\")')\n\n    eval_($.number, 'number')\n    eval_(3, '(1 + 2)')\n    eval_(-1, '(1 - 2)')\n    eval_(2, '(1 * 2)')\n    eval_(0.5, '(1 / 2)')\n\n    eval_($.date, 'date')\n    eval_(function (d) {\n      return d instanceof Date\n    }, '(date now)')\n\n    eval_($.range, 'range')\n    eval_(function (r) {\n      return r.begin === 0 && r.end === 3 && r.step === 1\n    }, '(0 3)')\n    eval_(function (r) {\n      return r.begin === 10 && r.end === 20 && r.step === 2\n    }, '(10 20 2)')\n\n    eval_($.symbol, 'symbol')\n    eval_(function (s) {\n      return s.key === 'x'\n    }, '(` x)')\n\n    eval_($.tuple, 'tuple')\n    eval_(function (t) {\n      var l = t.$\n      return t instanceof $void.Tuple && l[0].key === 'x' && l[1] === 1 && l[2] === 'y' && l[3] === true\n    }, '(` (x 1 \"y\" true))')\n\n    eval_($.operator, 'operator')\n    eval_(function (s) {\n      return s.type === $.operator\n    }, '(=? () )')\n    eval_(function (s) {\n      return s.type === $.operator\n    }, '(=? (X Y) (+ (X) (Y).')\n\n    eval_($.lambda, 'lambda')\n    eval_(function (s) {\n      return s.type === $.lambda\n    }, '(= () )')\n    eval_(function (s) {\n      return s.type === $.lambda\n    }, '(= (x y) (+ x y).')\n\n    eval_($.function, 'function')\n    eval_(function (s) {\n      return s.type === $.function\n    }, '(=> () )')\n    eval_(function (s) {\n      return s.type === $.function\n    }, '(=> (x y) (+ x y).')\n\n    eval_($.array, 'array')\n    eval_(function (a) {\n      return a.length === 2 && a[0] === 1 && a[1] === 2\n    }, '(array of 1 2)')\n    eval_(2, '((@ 10 20) length)')\n    eval_(20, '((@ 10 20) 1)')\n\n    eval_($.object, 'object')\n    eval_(function (obj) {\n      return obj.x === 1 && obj.y === 2\n    }, '(@ x: 1 y: 2)')\n    eval_(10, '((@ x: 10 y: 20) x)')\n    eval_(20, '((@ x: 10 y: 20) y)')\n    eval_(200, '((@ x: 10 y: 20) \"y\" 200)')\n\n    eval_($.class, 'class')\n    eval_(function (c) {\n      return c.type === $.class\n    }, '(@:class x: 1 y: 0)')\n    eval_(function (c) {\n      return c.type === $.class\n    }, '(class of (@: x: 1 y: 0).')\n  }\n\n  function checkAssignment () {\n    print('\\n  - Assignment')\n    eval_(1, '(let x 1)')\n    eval_(2, '(let x 1) (let y 2)')\n    eval_(2, '(let (x y) (@ 1 2). y')\n    eval_(2, '(let (x y) (@ x: 1 y: 2). y')\n    eval_(2, '(let * (@ x: 1 y: 2). y')\n\n    eval_(1, '(var x 1)')\n    eval_(2, '(var x 1) (var y 2)')\n    eval_(2, '(var (x y) (@ 1 2). y')\n    eval_(2, '(var (x y) (@ x: 1 y: 2). y')\n    eval_(2, '(var * (@ x: 1 y: 2). y')\n\n    eval_(1, '(export x 1)')\n    eval_(2, '(export x 1) (export y 2)')\n    eval_(2, '(export (x y) (@ x: 1 y: 2). y')\n    eval_(2, '(export * (@ x: 1 y: 2). y')\n  }\n\n  function checkOperators () {\n    print('\\n  - Operators')\n    eval_(1, '(? true 1 0)')\n    eval_(0, '(? false 1 0)')\n\n    eval_(110, '(+ 10 100)')\n    eval_(-110, '(+ -10 -100)')\n\n    eval_('10100', '(+ \"10\" \"100\")')\n    eval_('-10-100', '(+ \"-10\" \"-100\")')\n\n    eval_(1, '(++)')\n    eval_(-1, '(--)')\n\n    eval_(1, '(++ null)')\n    eval_(-1, '(-- null)')\n\n    eval_(1, '(++ 0)')\n    eval_(-1, '(-- 0)')\n\n    eval_(1, '(let x 0)(++ x)x')\n    eval_(-1, '(let x 0)(-- x)x')\n\n    eval_(true, '(1 ?)')\n    eval_(false, '(0 ?)')\n    eval_(false, '(null ?)')\n\n    eval_(true, '(true ? 1)')\n    eval_(1, '(false ? 1)')\n\n    eval_(1, '(true ? 1 0)')\n    eval_(0, '(false ? 1 0)')\n\n    eval_(0, '(null ?? 0)')\n    eval_(false, '(false ?? 0)')\n    eval_(0, '(0 ?? 1)')\n    eval_('', '(\"\" ?? 1)')\n  }\n\n  function checkControl () {\n    print('\\n  - Control')\n    eval_(0, '(if true 1 0)')\n    eval_(null, '(if false 1 0)')\n    eval_(1, '(if true 1 else 0)')\n    eval_(0, '(if false 1 else 0)')\n\n    eval_(10, '(for x in (100 110) (++ i).')\n    eval_(99, '(while ((++ i) < 100) i)')\n    eval_(100, '(let i 0)(while ((i ++) < 100) i)')\n    eval_(100, '(while ((++ i) < 100). i')\n    eval_(101, '(let i 0)(while ((i ++) < 100). i')\n    eval_('done', '(while ((++ i) < 100) (if (i == 10) (break \"done\").')\n  }\n\n  function checkOperations () {\n    print('\\n  - Operations')\n    eval_(21, '(let x 1) (let y 20) (let add (=? (a b) ((a) + (b). (add x y)')\n\n    eval_(21, '(let z 100) (let add (= (x y) (x + y z). (add 1 20)')\n    eval_(21, '(let z 100) (= (1 20): (x y) (x + y z).')\n\n    eval_(121, '(let z 100) (let add (=> (x y) (x + y z). (add 1 20)')\n    eval_(121, '(let z 100) (=> (1 20): (x y) (x + y z).')\n\n    eval_(11, '(let summer (@:class add: (= () ((this x) + (this y). (let s (summer of (@ x: 1 y: 10). (s add)')\n    eval_(11, '(let summer (@:class type: (@ add: (= (x y ) (+ x y). (summer add 1 10)')\n  }\n}\n","'use strict'\n\nvar espresso = require('../es')\nvar loadIOProvider = require('./lib/io')\nvar consoleTerm = require('./lib/console')\nvar terminalStdin = require('./lib/stdin')\nvar terminalStdout = require('./lib/stdout')\nvar defaultLoader = require('../lib/loader')\n\nfunction ensure (factory, alternative) {\n  return typeof factory === 'function' ? factory : alternative\n}\n\nfunction getDefaultHome () {\n  var href = window.location.href\n  return href.substring(0, href.lastIndexOf('/'))\n}\n\nmodule.exports = function (term, stdin, stdout, loader) {\n  term = typeof term === 'object' ? term : consoleTerm()\n  stdout = typeof stdout === 'function' ? stdout : terminalStdout(term)\n  loader = ensure(loader, defaultLoader)\n\n  var $void = espresso(stdout, loader)\n  loadIOProvider($void)\n\n  // prepare app environment.\n  var home = getDefaultHome()\n  $void.env('home', home)\n  $void.env('user-home', home)\n  $void.env('os', window.navigator.userAgent)\n\n  var isObject = $void.isObject\n  var bootstrap = $void.createBootstrapSpace(home + '/@')\n\n  var run = function (appHome, context, args, app) {\n    return initialize(context, function () {\n      $void.$['-enable-console'] = enableConsole\n      return $void.$run(app || 'app', args, appHome)\n    })\n  }\n\n  function initialize (context, main) {\n    var preparing = prepare(context)\n    var prepared = preparing(bootstrap, $void)\n    return !(prepared instanceof Promise) ? main()\n      : new Promise(function (resolve, reject) {\n        prepared.then(function () { resolve(main()) }, reject)\n      })\n  }\n\n  function prepare (context) {\n    return typeof context === 'function'\n      ? context // a customized initializer function.\n      : typeof context === 'string'\n        ? executor.bind(null, context) // an initialization profile.\n        : Array.isArray(context) ? function () {\n          // a list of dependency modules\n          return bootstrap.$fetch(context)\n        } : function () {\n          // try to fetch the default root module loader.\n          return bootstrap.$fetch('@')\n        }\n  }\n\n  function executor (profile) {\n    return new Promise(function (resolve, reject) {\n      bootstrap.$fetch(profile).then(function () {\n        resolve(bootstrap.$load(profile))\n      }, reject)\n    })\n  }\n\n  function enableConsole (context, args, profile) {\n    return shell(context || ['_@', '_profile'], args,\n      profile && typeof profile === 'string' ? profile\n        : '(var * (load \"_profile\"))'\n    )\n  }\n\n  function shell (context, args, profile) {\n    return initialize(context, function () {\n      var reader = ensure(stdin, terminalStdin)($void, term)\n      var agent = require('../lib/shell')($void, reader,\n        require('./lib/process')($void)\n      )\n      // export global shell commands\n      $void.$shell['test-bootstrap'] = require('../test/test')($void)\n      if (isObject(args)) {\n        Object.assign($void.$shell, args)\n        args = []\n      }\n      agent(args, term.echo, profile)\n      return reader.open()\n    })\n  }\n\n  return {\n    run: run,\n    shell: shell\n  }\n}\n","'use strict'\n\nfunction nop () {}\n\nmodule.exports = function () {\n  var term = {}\n  var buffer = ''\n\n  // serve stdout\n  term.print = function (text) {\n    if (buffer) {\n      text = buffer + text\n      buffer = ''\n    }\n    console.log(text)\n  }\n  term.printf = function (text) {\n    var lines = text.split('\\n')\n    var ending = lines.pop()\n    if (lines.length > 0) {\n      lines[0] = buffer + lines[0]\n      buffer = ending\n      console.log(lines.join('\\n'))\n    } else {\n      buffer += ending\n    }\n  }\n\n  // serve stderr\n  term.verbose = nop\n  term.info = nop\n  term.warn = nop\n  term.error = nop\n  term.debug = nop\n\n  // serve shell\n  var echos = []\n  term.echo = function (text) {\n    echos.push(text)\n  }\n\n  // serve stdin\n  var inputPrompt = '>'\n  term.prompt = function (text) {\n    text && (inputPrompt = text)\n  }\n\n  term.connect = function (reader) {\n    window['_$'] = function shell (line) {\n      if (typeof line === 'string') {\n        reader(line)\n        if (echos.length > 0) {\n          var output = echos.join('\\n '); echos = []\n          return output\n        }\n        if (!inputPrompt.startsWith('>')) {\n          console.info(inputPrompt)\n        }\n      } else {\n        console.error('input is not a string:', line)\n      }\n    }\n    return reader\n  }\n  term.disconnect = function () {\n    window['_$'] = null\n  }\n  return term\n}\n","'use strict'\n\nvar tempStorage = Object.create(null)\nvar tempSession = Object.create(null)\n\nfunction storeOf (storage) {\n  return {\n    getItem: function (key) {\n      return storage[key]\n    },\n    setItem: function (key, value) {\n      storage[key] = value\n    }\n  }\n}\n\nmodule.exports = function ($void) {\n  var warn = $void.$warn\n  var thisCall = $void.thisCall\n  var stringOf = $void.$.string.of\n\n  var $io = $void.$io = {}\n\n  var storage = window.localStorage || storeOf(tempStorage)\n  var session = window.sessionStorage || storeOf(tempSession)\n\n  function chooseStoreBy (path) {\n    return path.startsWith('~/') ? session : storage\n  }\n\n  function formatPath (method, path) {\n    if (path && typeof path === 'string') {\n      return path\n    }\n    if (!Array.isArray(path)) {\n      warn('io:' + method, 'argument path is not a string or strings.', [path])\n      return null\n    }\n    path = path.slice()\n    for (var i = 0, len = path.length; i < len; i++) {\n      if (typeof path[i] !== 'string') {\n        path[i] = thisCall(path[i], 'to-string')\n      }\n    }\n    return path.join('/')\n  }\n\n  $io.read = function read (path) {\n    path = formatPath('read', path)\n    return path ? chooseStoreBy(path).getItem(path) : null\n  }\n\n  $io.write = function write (path, value) {\n    path = formatPath('write', path)\n    if (!path) {\n      return null\n    }\n    value = typeof value === 'undefined' ? stringOf() : stringOf(value)\n    chooseStoreBy(path).setItem(path, value)\n    return value\n  }\n\n  $io['to-read'] = function read_ (path) {\n    path = formatPath('to-read', path)\n    return !path ? Promise.reject(warn())\n      : Promise.resolve(chooseStoreBy(path).getItem(path))\n  }\n\n  $io['to-write'] = function write_ (path, value) {\n    path = formatPath('to-write', path)\n    if (!path) {\n      return Promise.reject(warn())\n    }\n    value = typeof value === 'undefined' ? stringOf() : stringOf(value)\n    chooseStoreBy(path).setItem(path, value)\n    return Promise.resolve(value)\n  }\n}\n","'use strict'\n\nfunction safePathname (pathname) {\n  var offset = pathname.indexOf('?')\n  if (offset >= 0) {\n    pathname = pathname.substring(0, offset)\n  }\n  return pathname || ''\n}\n\nfunction safeDirname (pathname) {\n  var offset = pathname.lastIndexOf('/')\n  return offset <= 0 ? ''\n    : offset === (pathname.length - 1) ? pathname\n      : pathname.substring(0, offset) || ''\n}\n\nfunction reload (print) {\n  var counter = 3\n  setInterval(function () {\n    if (counter > 0) {\n      print(counter--)\n    } else {\n      window.location.reload()\n    }\n  }, 500)\n  return 'reloading ...'\n}\n\nmodule.exports = function ($void, environ, exit) {\n  environ = Object.assign(Object.create(null), environ)\n\n  var location = window.location\n  environ['_'] = location.href\n\n  var origin = location.origin || (location.protocol + '://' + location.host)\n  environ['HOME'] = origin\n\n  var pathname = safePathname(location.pathname)\n  environ['PATH'] = origin + pathname\n  environ['PWD'] = origin + safeDirname(pathname)\n\n  return {\n    env: function (name) {\n      if (typeof name !== 'string') {\n        return null\n      }\n      var value = environ[name]\n      return typeof value === 'string' ? value : null\n    },\n    exit: function (code) {\n      code = typeof code === 'number' ? code >> 0 : 1\n      return typeof exit === 'function' ? exit(code) : reload(function (counter) {\n        switch (counter) {\n          case 1:\n            return $void.$printf('.' + counter, 'red')\n          case 2:\n            return $void.$printf('..' + counter, 'yellow')\n          default:\n            return $void.$printf('...' + counter, 'blue')\n        }\n      })\n    }\n  }\n}\n","'use strict'\n\nvar $void = require('../index')\nvar term = require('./term')\n\nvar espresso = $void(term()/*, stdin, stdout, loader */)\n// start shell and expose the shell's reader function.\nvar initializing = espresso.shell(/* context, args, profile */)\nif (!(initializing instanceof Promise)) {\n  console.info('shell is ready.')\n} else {\n  console.info('initializing shell ...')\n  initializing.then(function () {\n    console.info('shell is ready now.')\n  }, function (err) {\n    console.error('shell failed to be initialized for', err)\n  })\n}\n","'use strict'\n\nmodule.exports = function ($void, term) {\n  var interpreter = null\n  var reader = function (line) {\n    return interpreter && interpreter(line)\n  }\n\n  return {\n    prompt: term.prompt,\n    open: function () {\n      return term.connect(reader)\n    },\n    on: function (event, callback) {\n      // only allow line event now.\n      switch (event) {\n        case 'line':\n          interpreter = callback\n          return event\n        default:\n          return null\n      }\n    },\n    close: function () {\n      term.disconnect()\n    }\n  }\n}\n","'use strict'\n\nvar tracer = require('../../lib/stdout')\n\nfunction connectTo (term, tracing, type) {\n  return function () {\n    var trace = tracing[type]\n    var text = trace.apply(null, arguments)\n    term[type](text)\n    return text\n  }\n}\n\nmodule.exports = function (term) {\n  return function ($void) {\n    var tracing = tracer($void, true)\n    var connect = connectTo.bind(null, term, tracing)\n    var stdout = {}\n    for (var type in tracing) {\n      stdout[type] = type !== 'printf' ? connect(type)\n        : function (value, format) {\n          value = tracing.printf(value)\n          term.printf(value, format)\n          return value\n        }\n    }\n    return stdout\n  }\n}\n","'use strict'\n\nvar MaxLines = 2400\nvar DrainBatch = 300\n\nvar KeyEnter = 0x0D\nvar KeyUpArrow = 0x26\nvar KeyDownArrow = 0x28\n\n// the key to be used in localStorage\nvar InputHistoryKey = '~/.es_history'\n\n// Firefox, IE and Edge require a non-zero timeout to refresh UI.\nvar MinimalDelay = 20 // milliseconds\n\nvar pool = []\nvar spooling = false\nvar panel, input, enter\n\nfunction enqueue (todo) {\n  if (pool.length > (MaxLines * 2)) {\n    pool = pool.slice(MaxLines)\n  }\n  pool.push(todo)\n}\n\nfunction drain () {\n  if (pool.length < 1) { return }\n  setTimeout(function () {\n    var todos = pool.splice(0, DrainBatch)\n    for (var i = 0, len = todos.length; i < len; i++) {\n      var todo = todos[i]\n      todo[0](todo[1], todo[2], true)\n    }\n    drain()\n  }, MinimalDelay)\n}\n\nfunction updatePanel () {\n  if (panel.childElementCount > MaxLines) {\n    var half = MaxLines / 2\n    while (panel.childElementCount > half) {\n      panel.removeChild(panel.firstElementChild)\n    }\n  }\n  window.scrollTo(0, document.body.scrollHeight)\n  input.focus()\n}\n\nvar currentLine = null\n\nfunction writeTo (panel) {\n  function write (text, render, draining) {\n    if (!draining && (spooling || pool.length > 0)) {\n      return enqueue([write, text, render])\n    }\n    var lines = text.split('\\n')\n    var spans = []\n    for (var i = 0, last = lines.length - 1; i <= last; i++) {\n      var line = lines[i]\n      if (i > 0 || !line) {\n        currentLine = null\n      }\n      if (line) {\n        spans.push(\n          appendText(currentLine || (currentLine = createNewLine()), line)\n        )\n      } else if (i < last) {\n        createNewLine(document.createElement('br'))\n      }\n    }\n    if (render && spans.length > 0) {\n      for (var j = 0, len = spans.length; j < len; j++) {\n        render(spans[j])\n      }\n    }\n    updatePanel()\n  }\n  return write\n}\n\nfunction createNewLine (child) {\n  var li = document.createElement('li')\n  li.className = 'print'\n  if (child) {\n    li.appendChild(child)\n  }\n  panel.appendChild(li)\n  return li\n}\n\nfunction appendText (li, text) {\n  var span = document.createElement('span')\n  span.className = 'text'\n  span.appendChild(document.createTextNode(replaceWhitespace(text)))\n  li.appendChild(span)\n  return span\n}\n\nfunction styleOf (format) {\n  var style = ''\n  for (var key in format) {\n    var value = format[key]\n    if (typeof value === 'string') {\n      style += key + ': ' + value + ';'\n    }\n  }\n  return style\n}\n\nvar styleClasses = Object.assign(Object.create(null), {\n  red: 'color',\n  green: 'color',\n  blue: 'color',\n  yellow: 'color',\n  grey: 'color',\n  gray: 'color',\n  underline: '*text-decoration',\n  overline: '*text-decoration',\n  'line-through': '*text-decoration'\n})\n\nfunction applyClass (cls) {\n  var values = cls.split(/\\s/)\n  var style = {}\n  for (var i = 0; i < values.length; i++) {\n    var value = values[i]\n    if (styleClasses[value]) {\n      var key = styleClasses[value]\n      if (key.startsWith('*')) {\n        key = key.substring(1)\n        style[key] = style[key] ? style[key] + ' ' + value : value\n      } else {\n        style[key] = value\n      }\n    }\n  }\n  return applyStyle(style)\n}\n\nfunction applyStyle (obj) {\n  var style = styleOf(obj)\n  return style && function (span) {\n    span.style.cssText = style\n  }\n}\n\nfunction logTo (panel, type, max) {\n  function log (prompt, text, draining) {\n    if (!draining && (spooling || pool.length > 0)) {\n      return enqueue([log, prompt, text])\n    }\n    if (max && text.length > max) {\n      text = text.substring(0, max - 10) + '... ... ...' +\n        text.substring(text.length - 10) +\n        ' # use (print ...) to display all text.'\n    }\n    var lines = text.split('\\n')\n    for (var i = 0, len = lines.length; i < len; i++) {\n      var li = document.createElement('li')\n      li.className = type\n      lines[i] ? appendLine(li, lines[i], i > 0 ? '' : prompt)\n        : li.appendChild(document.createElement('br'))\n      panel.appendChild(li)\n    }\n    updatePanel()\n  }\n  return log\n}\n\nfunction appendLine (li, text, prompt) {\n  var span = document.createElement('span')\n  span.className = 'prompt'\n  if (prompt) {\n    span.appendChild(document.createTextNode(prompt))\n  }\n  li.appendChild(span)\n  span = document.createElement('span')\n  span.className = 'text'\n  span.appendChild(document.createTextNode(replaceWhitespace(text)))\n  li.appendChild(span)\n}\n\nfunction replaceWhitespace (text) {\n  var spaces = ''\n  for (var i = 0; i < text.length; i++) {\n    if (!/\\s/.test(text.charAt(i))) {\n      return spaces + text.slice(i)\n    } else {\n      spaces += '\\u00A0'\n    }\n  }\n  return text\n}\n\nfunction loadHistory () {\n  if (!window.localStorage) {\n    return []\n  }\n  var data = window.localStorage.getItem(InputHistoryKey)\n  if (!data) {\n    return []\n  }\n  try {\n    var history = JSON.parse(data)\n    return Array.isArray(history) ? history : []\n  } catch (err) {\n    console.warn('failed to load input history:', err)\n    return []\n  }\n}\n\nfunction updateHistory (records, value) {\n  if (records.length > 0 && records[records.length - 1] === value) {\n    return records.length\n  }\n  records.push(value)\n  if (records.length > 1000) {\n    records = records.slice(-1000)\n  }\n  if (window.localStorage) {\n    try {\n      window.localStorage.setItem(InputHistoryKey, JSON.stringify(records))\n    } catch (err) {\n      console.warn('failed to save input history:', err)\n    }\n  }\n  return records.length\n}\n\nfunction bindInput (term) {\n  var inputHistory = loadHistory()\n  var inputOffset = inputHistory.length\n  var inputValue = ''\n\n  function exec (value) {\n    if (term.reader) {\n      setTimeout(function () {\n        spooling = true\n        term.reader(value)\n        spooling = false\n        drain()\n      }, MinimalDelay)\n    }\n  }\n\n  enter.onclick = function () {\n    if (!input.value) {\n      return\n    }\n    var value = input.value\n    input.value = ''\n    inputValue = ''\n    inputOffset = updateHistory(inputHistory, value)\n    term.input(value)\n    exec(value)\n  }\n  input.addEventListener('keypress', function (event) {\n    if (event.keyCode === KeyEnter) {\n      event.preventDefault()\n      enter.onclick()\n    }\n  })\n  input.addEventListener('keydown', function (event) {\n    switch (event.keyCode) {\n      case KeyUpArrow:\n        (inputOffset === inputHistory.length) && (inputValue = input.value)\n        if (--inputOffset >= 0 && inputOffset < inputHistory.length) {\n          input.value = inputHistory[inputOffset]\n        } else {\n          inputOffset = inputHistory.length\n          input.value = inputValue\n        }\n        break\n      case KeyDownArrow:\n        (inputOffset === inputHistory.length) && (inputValue = input.value)\n        if (++inputOffset < inputHistory.length) {\n          input.value = inputHistory[inputOffset]\n        } else if (inputOffset > inputHistory.length) {\n          inputOffset = 0\n          if (inputOffset < inputHistory.length) {\n            input.value = inputOffset < inputHistory.length\n              ? inputHistory[inputOffset] : ''\n          }\n        } else {\n          input.value = inputValue\n        }\n        break\n      default:\n        return\n    }\n    event.preventDefault()\n  })\n  input.focus()\n}\n\nmodule.exports = function () {\n  var term = {}\n  panel = document.getElementById('stdout-panel')\n  input = document.getElementById('stdin-input')\n  enter = document.getElementById('stdin-enter')\n\n  // serve stdout\n  var writerOf = writeTo.bind(null, panel)\n  var write = writerOf('print')\n  term.print = function (text) {\n    write(text.charAt(text.length - 1) === '\\n' ? text : text + '\\n')\n  }\n  term.printf = function (text, format) {\n    var render = typeof format === 'string' ? applyClass(format)\n      : typeof format === 'object' ? applyStyle(format) : null\n    write(text, render)\n  }\n\n  // serve stderr\n  var loggerOf = logTo.bind(null, panel)\n  term.verbose = loggerOf('verbose').bind(null, '#V')\n  term.info = loggerOf('info').bind(null, '#I')\n  term.warn = loggerOf('warn').bind(null, '#W')\n  term.error = loggerOf('error').bind(null, '#E')\n  term.debug = loggerOf('debug').bind(null, '#D')\n\n  // serve shell\n  term.echo = loggerOf('echo', 150).bind(null, '=')\n\n  // serve stdin\n  var inputPrompt = '>'\n  var prompt = document.getElementById('stdin-prompt')\n  term.prompt = function (text) {\n    if (text) {\n      prompt.innerText = inputPrompt = text\n    }\n  }\n  var writeInput = loggerOf('input')\n  term.input = function (text) {\n    writeInput(inputPrompt, text)\n  }\n  bindInput(term)\n  term.connect = function (reader) {\n    return (term.reader = typeof reader === 'function' ? reader : null)\n  }\n  term.disconnect = function () {\n    term.reader = null\n  }\n  return term\n}\n"],"sourceRoot":""}